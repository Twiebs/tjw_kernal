
bin/kernel:     file format elf64-x86-64

Decoded dump of debug contents of section .debug_line:

CU: src/utility.h:
File name                            Line number    Starting address
utility.h                                     20            0x109000

utility.h                                     21            0x109015
utility.h                                     22            0x10901f
utility.h                                     21            0x109030
utility.h                                     21            0x109035
utility.h                                     24            0x10903f
utility.h                                     26            0x109042
utility.h                                     27            0x109056
utility.h                                     28            0x109060
utility.h                                     27            0x10907b
utility.h                                     27            0x109080
utility.h                                     30            0x10908a
utility.h                                     33            0x10908d
utility.h                                     34            0x109099
utility.h                                     35            0x1090a1
utility.h                                     36            0x1090a3
utility.h                                     35            0x1090a8
utility.h                                     37            0x1090ba
utility.h                                     38            0x1090be
utility.h                                     47            0x1090c0
utility.h                                     48            0x1090d8
utility.h                                     48            0x1090e2
utility.h                                     49            0x1090e9
utility.h                                     50            0x1090f3
utility.h                                     51            0x109113
utility.h                                     49            0x10911a
utility.h                                     49            0x10911f
utility.h                                     54            0x109129
utility.h                                     55            0x10912e
utility.h                                     58            0x109130
utility.h                                     59            0x109144
utility.h                                     60            0x10914e
utility.h                                     60            0x10916e
utility.h                                     59            0x109175
utility.h                                     59            0x10917a
utility.h                                     61            0x109184
utility.h                                     62            0x109189
utility.h                                     65            0x10918b
utility.h                                     66            0x109198
utility.h                                     66            0x10919e
utility.h                                     66            0x1091a4
utility.h                                     67            0x1091aa
utility.h                                     68            0x1091b0
utility.h                                     71            0x1091b7
utility.h                                     72            0x1091bc

src/kernel_synch.h:
kernel_synch.h                                 6            0x1091be
kernel_synch.h                                 7            0x1091ca
kernel_synch.h                                 7            0x1091cb
kernel_synch.h                                 8            0x1091e7
kernel_synch.h                                 9            0x1091ea
kernel_synch.h                                12            0x1091ed
kernel_synch.h                                13            0x1091f9
kernel_synch.h                                14            0x1091fc
kernel_synch.h                                15            0x109206

src/kernel.h:
kernel.h                                      29            0x109209
kernel.h                                      30            0x10921c
kernel.h                                      31            0x109225
kernel.h                                      40            0x109228
kernel.h                                      42            0x109236
kernel.h                                      43            0x109240
kernel.h                                      44            0x109244
kernel.h                                      55            0x109246
kernel.h                                      59            0x10924e
kernel.h                                      60            0x10925c
kernel.h                                      61            0x109260
kernel.h                                      62            0x109261

src/kernel_graphics.c:
kernel_graphics.c                             25            0x109264
kernel_graphics.c                             26            0x10927d
kernel_graphics.c                             27            0x109293
kernel_graphics.c                             28            0x1092a0
kernel_graphics.c                             29            0x1092ad
kernel_graphics.c                             30            0x1092c3
kernel_graphics.c                             31            0x1092d9
kernel_graphics.c                             32            0x109312
kernel_graphics.c                             33            0x109324
kernel_graphics.c                             34            0x109347
kernel_graphics.c                             28            0x10935d
kernel_graphics.c                             28            0x109362
kernel_graphics.c                             27            0x10936d
kernel_graphics.c                             27            0x109372
kernel_graphics.c                             38            0x10937d
kernel_graphics.c                             41            0x109380
kernel_graphics.c                             42            0x10938c
kernel_graphics.c                             43            0x1093b3

/usr/lib/gcc/x86_64-pc-linux-gnu/6.1.1/include/emmintrin.h:
emmintrin.h                                  755            0x1093bf

src/kernel_graphics.c:
kernel_graphics.c                             44            0x1093c3
kernel_graphics.c                             45            0x1093c7

/usr/lib/gcc/x86_64-pc-linux-gnu/6.1.1/include/emmintrin.h:
emmintrin.h                                  710            0x1093e2

src/kernel_graphics.c:
kernel_graphics.c                             47            0x1093ee
kernel_graphics.c                             45            0x1093fa
kernel_graphics.c                             45            0x1093ff
kernel_graphics.c                             49            0x109409
kernel_graphics.c                             79            0x10940c
kernel_graphics.c                             83            0x109423
kernel_graphics.c                             84            0x109440
kernel_graphics.c                             85            0x109454
kernel_graphics.c                             86            0x10946c
kernel_graphics.c                             89            0x10946f
kernel_graphics.c                             93            0x10947b
kernel_graphics.c                             95            0x1094ab
kernel_graphics.c                             96            0x1094d0
kernel_graphics.c                             97            0x1094dd
kernel_graphics.c                             98            0x1094e9
kernel_graphics.c                             99            0x109515
kernel_graphics.c                            100            0x109532
kernel_graphics.c                            101            0x109551
kernel_graphics.c                            102            0x10955b
kernel_graphics.c                            101            0x109586
kernel_graphics.c                            101            0x10958b
kernel_graphics.c                             96            0x109595
kernel_graphics.c                             96            0x10959a
kernel_graphics.c                            106            0x1095a8
kernel_graphics.c                            107            0x1095c8
kernel_graphics.c                            108            0x1095d2
kernel_graphics.c                            107            0x10960c
kernel_graphics.c                            107            0x109611
kernel_graphics.c                            110            0x10961b
kernel_graphics.c                            170            0x10961e
kernel_graphics.c                            171            0x10962a
kernel_graphics.c                            172            0x109640
kernel_graphics.c                            174            0x10964b
kernel_graphics.c                            178            0x10965b
kernel_graphics.c                            179            0x109663
kernel_graphics.c                            180            0x10966f
kernel_graphics.c                            181            0x109685
kernel_graphics.c                            182            0x1096a5
kernel_graphics.c                            183            0x1096c2
kernel_graphics.c                            184            0x1096cf
kernel_graphics.c                            185            0x1096da
kernel_graphics.c                            186            0x109706
kernel_graphics.c                            187            0x109723
kernel_graphics.c                            188            0x10973b
kernel_graphics.c                            189            0x109745
kernel_graphics.c                            188            0x109789
kernel_graphics.c                            188            0x10978e
kernel_graphics.c                            183            0x109798
kernel_graphics.c                            183            0x10979d
kernel_graphics.c                            193            0x1097aa
kernel_graphics.c                            194            0x1097c3
kernel_graphics.c                            195            0x1097cd
kernel_graphics.c                            194            0x10981e
kernel_graphics.c                            194            0x109823
kernel_graphics.c                            199            0x10982f
kernel_graphics.c                            171            0x10983d
kernel_graphics.c                            201            0x10983e

src/kernel_acpi.c:
kernel_acpi.c                                 41            0x109840
kernel_acpi.c                                 42            0x109859
kernel_acpi.c                                 45            0x109863
kernel_acpi.c                                 42            0x109867
kernel_acpi.c                                 43            0x109876
kernel_acpi.c                                 42            0x109881
kernel_acpi.c                                 43            0x109885
kernel_acpi.c                                 44            0x109894
kernel_acpi.c                                 43            0x10989f
kernel_acpi.c                                 44            0x1098a3
kernel_acpi.c                                 45            0x1098b2
kernel_acpi.c                                 44            0x1098bd
kernel_acpi.c                                 45            0x1098c1
kernel_acpi.c                                 45            0x1098d0
kernel_acpi.c                                 45            0x1098d7
kernel_acpi.c                                 42            0x1098dc
kernel_acpi.c                                 46            0x1098e0
kernel_acpi.c                                 47            0x1098f4
kernel_acpi.c                                 51            0x1098f9
kernel_acpi.c                                 52            0x109901
kernel_acpi.c                                 53            0x109920
kernel_acpi.c                                 54            0x10992f
kernel_acpi.c                                 55            0x109943
kernel_acpi.c                                 56            0x10994f
kernel_acpi.c                                 57            0x10995c
kernel_acpi.c                                 58            0x109977
kernel_acpi.c                                 59            0x10998e
kernel_acpi.c                                 60            0x1099a4
kernel_acpi.c                                 65            0x1099ac
kernel_acpi.c                                 71            0x1099c0
kernel_acpi.c                                 78            0x1099c8
kernel_acpi.c                                 80            0x1099db
kernel_acpi.c                                 81            0x1099e7
kernel_acpi.c                                104            0x1099ec
kernel_acpi.c                                106            0x109a10
kernel_acpi.c                                107            0x109a18
kernel_acpi.c                                110            0x109a2a
kernel_acpi.c                                111            0x109a3c
kernel_acpi.c                                112            0x109a65
kernel_acpi.c                                116            0x109a82
kernel_acpi.c                                114            0x109a84
kernel_acpi.c                                116            0x109a98
kernel_acpi.c                                128            0x109a9a
kernel_acpi.c                                132            0x109aa2
kernel_acpi.c                                133            0x109ab2
kernel_acpi.c                                139            0x109ac6
kernel_acpi.c                                135            0x109ac8
kernel_acpi.c                                139            0x109adc
kernel_acpi.c                                141            0x109ade
kernel_acpi.c                                144            0x109adf
kernel_acpi.c                                 81            0x109af5
kernel_acpi.c                                148            0x109b14
kernel_acpi.c                                149            0x109b24
kernel_acpi.c                                 56            0x109b38
kernel_acpi.c                                 56            0x109b3d
kernel_acpi.c                                154            0x109b4a

src/kernel_apic.c:
kernel_apic.c                                 37            0x109b4c
kernel_apic.c                                 38            0x109b60
kernel_apic.c                                 39            0x109b68
kernel_apic.c                                 40            0x109b72
kernel_apic.c                                 41            0x109b7f
kernel_apic.c                                 44            0x109b82
kernel_apic.c                                 45            0x109b93
kernel_apic.c                                 46            0x109b9b
kernel_apic.c                                 47            0x109ba5
kernel_apic.c                                 48            0x109baf
kernel_apic.c                                 51            0x109bb1
kernel_apic.c                                 52            0x109bc4
kernel_apic.c                                 53            0x109bd3
kernel_apic.c                                 54            0x109bdc
kernel_apic.c                                 57            0x109bdf
kernel_apic.c                                 58            0x109beb
kernel_apic.c                                 61            0x109bec
kernel_apic.c                                 62            0x109bf3
kernel_apic.c                                 63            0x109bfa
kernel_apic.c                                 64            0x109bfe
kernel_apic.c                                 65            0x109c12
kernel_apic.c                                 66            0x109c26
kernel_apic.c                                 67            0x109c27
kernel_apic.c                                 70            0x109c2a
kernel_apic.c                                 71            0x109c36
kernel_apic.c                                 80            0x109c37
kernel_apic.c                                 81            0x109c4d
kernel_apic.c                                 88            0x109c63
kernel_apic.c                                 89            0x109c84
kernel_apic.c                                 90            0x109c85
kernel_apic.c                                 93            0x109c88
kernel_apic.c                                107            0x109c9d
kernel_apic.c                                107            0x109ca3
kernel_apic.c                                107            0x109cab
kernel_apic.c                                107            0x109cb1
kernel_apic.c                                109            0x109cb4
kernel_apic.c                                110            0x109cce
kernel_apic.c                                111            0x109ceb
kernel_apic.c                                112            0x109d0a
kernel_apic.c                                116            0x109d0d
kernel_apic.c                                154            0x109d23
kernel_apic.c                                155            0x109d2a
kernel_apic.c                                156            0x109d45
kernel_apic.c                                157            0x109d4c
kernel_apic.c                                162            0x109d53
kernel_apic.c                                163            0x109d5c
kernel_apic.c                                164            0x109d65
kernel_apic.c                                165            0x109d7e
kernel_apic.c                                167            0x109d97
kernel_apic.c                                168            0x109db3
kernel_apic.c                                169            0x109dcf
kernel_apic.c                                170            0x109dd1
kernel_apic.c                                169            0x109de5
kernel_apic.c                                173            0x109df0
kernel_apic.c                                173            0x109dfa
kernel_apic.c                                173            0x109e00
kernel_apic.c                                176            0x109e0a
kernel_apic.c                                177            0x109e11
kernel_apic.c                                178            0x109e2c
kernel_apic.c                                179            0x109e48
kernel_apic.c                                180            0x109e64
kernel_apic.c                                180            0x109e6e
kernel_apic.c                                180            0x109e74
kernel_apic.c                                181            0x109e7e
kernel_apic.c                                182            0x109e9a
kernel_apic.c                                183            0x109eb6

src/kernel_descriptor.c:
kernel_descriptor.c                           59            0x109eb9
kernel_descriptor.c                           60            0x109ed4
kernel_descriptor.c                           60            0x109edd
kernel_descriptor.c                           61            0x109f0d
kernel_descriptor.c                           61            0x109f13
kernel_descriptor.c                           62            0x109f43
kernel_descriptor.c                           62            0x109f49
kernel_descriptor.c                           81            0x109f79

kernel_descriptor.c                           82            0x109f8d
kernel_descriptor.c                           83            0x109f95
kernel_descriptor.c                           84            0x109fa0
kernel_descriptor.c                           85            0x109faf
kernel_descriptor.c                           87            0x109fba
kernel_descriptor.c                           88            0x109fc1
kernel_descriptor.c                           90            0x109fdb
kernel_descriptor.c                           91            0x109fe5
kernel_descriptor.c                           92            0x109fef
kernel_descriptor.c                           93            0x10a007
kernel_descriptor.c                           94            0x10a022
kernel_descriptor.c                           96            0x10a03a
kernel_descriptor.c                           97            0x10a055
kernel_descriptor.c                           98            0x10a06e
kernel_descriptor.c                          101            0x10a071
kernel_descriptor.c                          110            0x10a086
kernel_descriptor.c                          111            0x10a08e
kernel_descriptor.c                          112            0x10a09b
kernel_descriptor.c                          113            0x10a0ad
kernel_descriptor.c                          114            0x10a0be
kernel_descriptor.c                          114            0x10a0d6
kernel_descriptor.c                          114            0x10a0df
kernel_descriptor.c                          114            0x10a0e6
kernel_descriptor.c                          115            0x10a0ef
kernel_descriptor.c                          116            0x10a0f9
kernel_descriptor.c                          117            0x10a101
kernel_descriptor.c                          125            0x10a104
kernel_descriptor.c                          126            0x10a112
kernel_descriptor.c                          142            0x10a113
kernel_descriptor.c                          143            0x10a11b
kernel_descriptor.c                          145            0x10a135
kernel_descriptor.c                          146            0x10a13c
kernel_descriptor.c                          147            0x10a13d

src/kernel_exceptions.c:
kernel_exceptions.c                           41            0x10a140
kernel_exceptions.c                           71            0x10a148
kernel_exceptions.c                           72            0x10a14f
kernel_exceptions.c                           73            0x10a15a
kernel_exceptions.c                           74            0x10a16e
kernel_exceptions.c                           74            0x10a179
kernel_exceptions.c                           74            0x10a180
kernel_exceptions.c                           74            0x10a185
kernel_exceptions.c                           75            0x10a19c
kernel_exceptions.c                           76            0x10a1c9
kernel_exceptions.c                           77            0x10a1ea
kernel_exceptions.c                           84            0x10a1f6
kernel_exceptions.c                           82            0x10a1f8
kernel_exceptions.c                           84            0x10a204
kernel_exceptions.c                           87            0x10a207
kernel_exceptions.c                           95            0x10a20f
kernel_exceptions.c                           96            0x10a216
kernel_exceptions.c                           97            0x10a228
kernel_exceptions.c                           98            0x10a23a
kernel_exceptions.c                           99            0x10a24c
kernel_exceptions.c                          100            0x10a25e
kernel_exceptions.c                          102            0x10a270
kernel_exceptions.c                          102            0x10a277
kernel_exceptions.c                          102            0x10a27e
kernel_exceptions.c                          102            0x10a283
kernel_exceptions.c                          102            0x10a28a
kernel_exceptions.c                          102            0x10a291
kernel_exceptions.c                          102            0x10a296
kernel_exceptions.c                          102            0x10a29d
kernel_exceptions.c                          102            0x10a2a4
kernel_exceptions.c                          102            0x10a2a9
kernel_exceptions.c                          102            0x10a2b0
kernel_exceptions.c                          102            0x10a2b7
kernel_exceptions.c                          102            0x10a2bc
kernel_exceptions.c                          102            0x10a2c3
kernel_exceptions.c                          102            0x10a2ca
kernel_exceptions.c                          102            0x10a2cf
kernel_exceptions.c                          109            0x10a2f7
kernel_exceptions.c                          111            0x10a303
kernel_exceptions.c                          117            0x10a30a
kernel_exceptions.c                          118            0x10a314
kernel_exceptions.c                          124            0x10a320
kernel_exceptions.c                          121            0x10a322
kernel_exceptions.c                          122            0x10a336
kernel_exceptions.c                          124            0x10a342

src/kernel_entry.c:
kernel_entry.c                                48            0x10a345
kernel_entry.c                                63            0x10a349
kernel_entry.c                                64            0x10a366
kernel_entry.c                                66            0x10a383
kernel_entry.c                                67            0x10a3a0
kernel_entry.c                                69            0x10a3bd
kernel_entry.c                                70            0x10a3da
kernel_entry.c                                73            0x10a3f7
kernel_entry.c                                74            0x10a414
kernel_entry.c                                77            0x10a431
kernel_entry.c                                78            0x10a447
kernel_entry.c                                79            0x10a45d
kernel_entry.c                                80            0x10a473
kernel_entry.c                                81            0x10a489
kernel_entry.c                                82            0x10a49d
kernel_entry.c                               109            0x10a4a0
kernel_entry.c                               118            0x10a4af
kernel_entry.c                               119            0x10a4c5
kernel_entry.c                               120            0x10a4df
kernel_entry.c                               121            0x10a4f8
kernel_entry.c                               122            0x10a522
kernel_entry.c                               123            0x10a534
kernel_entry.c                               124            0x10a544
kernel_entry.c                               127            0x10a547
kernel_entry.c                               131            0x10a54f
kernel_entry.c                               132            0x10a558
kernel_entry.c                               133            0x10a56a
kernel_entry.c                               131            0x10a579
kernel_entry.c                               131            0x10a57d
kernel_entry.c                               169            0x10a586
kernel_entry.c                               170            0x10a598
kernel_entry.c                               171            0x10a5aa
kernel_entry.c                               172            0x10a5bc
kernel_entry.c                               173            0x10a5ce
kernel_entry.c                               174            0x10a5e0
kernel_entry.c                               175            0x10a5f2
kernel_entry.c                               176            0x10a604
kernel_entry.c                               177            0x10a616
kernel_entry.c                               178            0x10a628
kernel_entry.c                               179            0x10a63a
kernel_entry.c                               180            0x10a64c
kernel_entry.c                               181            0x10a65e
kernel_entry.c                               182            0x10a670
kernel_entry.c                               183            0x10a682
kernel_entry.c                               184            0x10a694
kernel_entry.c                               185            0x10a6a6
kernel_entry.c                               186            0x10a6b8
kernel_entry.c                               187            0x10a6ca
kernel_entry.c                               188            0x10a6dc
kernel_entry.c                               189            0x10a6ee
kernel_entry.c                               190            0x10a700
kernel_entry.c                               191            0x10a712
kernel_entry.c                               192            0x10a724
kernel_entry.c                               193            0x10a736
kernel_entry.c                               194            0x10a748
kernel_entry.c                               195            0x10a75a
kernel_entry.c                               196            0x10a76c
kernel_entry.c                               197            0x10a77e
kernel_entry.c                               198            0x10a790
kernel_entry.c                               199            0x10a7a2
kernel_entry.c                               200            0x10a7b4
kernel_entry.c                               214            0x10a7c6
kernel_entry.c                               215            0x10a7d2
kernel_entry.c                               216            0x10a7de
kernel_entry.c                               217            0x10a7f3
kernel_entry.c                               218            0x10a808
kernel_entry.c                               219            0x10a822
kernel_entry.c                               226            0x10a83c
kernel_entry.c                               227            0x10a84b
kernel_entry.c                               228            0x10a84f
kernel_entry.c                               229            0x10a850
kernel_entry.c                               230            0x10a864

src/hardware_serial.c:
hardware_serial.c                             18            0x10a867
hardware_serial.c                             19            0x10a86b
hardware_serial.c                             20            0x10a87a
hardware_serial.c                             21            0x10a889
hardware_serial.c                             22            0x10a898
hardware_serial.c                             23            0x10a8a7
hardware_serial.c                             24            0x10a8b6
hardware_serial.c                             25            0x10a8c5
hardware_serial.c                             26            0x10a8d4
hardware_serial.c                             28            0x10a8d7
hardware_serial.c                             29            0x10a8db
hardware_serial.c                             30            0x10a8eb
hardware_serial.c                             39            0x10a8ed
hardware_serial.c                             40            0x10a8fd
hardware_serial.c                             41            0x10a907
hardware_serial.c                             41            0x10a908
hardware_serial.c                             42            0x10a916
hardware_serial.c                             40            0x10a933
hardware_serial.c                             40            0x10a938
hardware_serial.c                             44            0x10a942

src/kernel_memory.c:
kernel_memory.c                               37            0x10a945
kernel_memory.c                               38            0x10a959
kernel_memory.c                               38            0x10a967
kernel_memory.c                               39            0x10a997
kernel_memory.c                               39            0x10a9a5
kernel_memory.c                               40            0x10a9d5
kernel_memory.c                               41            0x10a9e6
kernel_memory.c                               42            0x10a9f7
kernel_memory.c                               43            0x10aa08
kernel_memory.c                               44            0x10aa10
kernel_memory.c                               45            0x10aa20
kernel_memory.c                               46            0x10aa30
kernel_memory.c                               47            0x10aa5c
kernel_memory.c                               49            0x10aa5f
kernel_memory.c                               50            0x10aa6f
kernel_memory.c                               50            0x10aa7d
kernel_memory.c                               51            0x10aaad
kernel_memory.c                               51            0x10aabb
kernel_memory.c                               52            0x10aaeb
kernel_memory.c                               53            0x10aafc
kernel_memory.c                               54            0x10ab0d
kernel_memory.c                               55            0x10ab1e
kernel_memory.c                               55            0x10ab25
kernel_memory.c                               55            0x10ab2c
kernel_memory.c                               56            0x10ab5c
kernel_memory.c                               56            0x10ab6d
kernel_memory.c                               57            0x10ab9d
kernel_memory.c                               58            0x10abc2
kernel_memory.c                               60            0x10abc5
kernel_memory.c                               61            0x10abd5
kernel_memory.c                               62            0x10abdd
kernel_memory.c                               63            0x10abea
kernel_memory.c                               64            0x10abf2
kernel_memory.c                               65            0x10ac05
kernel_memory.c                               66            0x10ac09
kernel_memory.c                               68            0x10ac0b
kernel_memory.c                               69            0x10ac0f
kernel_memory.c                               70            0x10ac2b
kernel_memory.c                               71            0x10ac35

src/kernel_entry.c:
kernel_entry.c                               237            0x10ac38
kernel_entry.c                               238            0x10ac3c
kernel_entry.c                               239            0x10ac3d

src/elf64.h:
elf64.h                                      304            0x10ac40
elf64.h                                      305            0x10ac4b
elf64.h                                      305            0x10ac51
elf64.h                                      305            0x10ac5b
elf64.h                                      305            0x10ac61
elf64.h                                      305            0x10ac6b
elf64.h                                      305            0x10ac71
elf64.h                                      305            0x10ac7b
elf64.h                                      305            0x10ac81
elf64.h                                      305            0x10ac8b
elf64.h                                      305            0x10ac91
elf64.h                                      305            0x10ac9b
elf64.h                                      305            0x10aca1
elf64.h                                      305            0x10acab
elf64.h                                      305            0x10acb1
elf64.h                                      305            0x10acbb
elf64.h                                      305            0x10acc1
elf64.h                                      305            0x10accb
elf64.h                                      305            0x10acd1
elf64.h                                      305            0x10acdb
elf64.h                                      305            0x10ace1
elf64.h                                      305            0x10aceb
elf64.h                                      305            0x10acf1
elf64.h                                      305            0x10acfb
elf64.h                                      305            0x10ad01
elf64.h                                      305            0x10ad0b
elf64.h                                      305            0x10ad11
elf64.h                                      305            0x10ad1b
elf64.h                                      305            0x10ad21
elf64.h                                      305            0x10ad2b
elf64.h                                      305            0x10ad31
elf64.h                                      305            0x10ad3b
elf64.h                                      305            0x10ad41
elf64.h                                      305            0x10ad4b
elf64.h                                      305            0x10ad51
elf64.h                                      305            0x10ad5b
elf64.h                                      305            0x10ad61
elf64.h                                      305            0x10ad6b
elf64.h                                      305            0x10ad71
elf64.h                                      305            0x10ad7b
elf64.h                                      305            0x10ad81
elf64.h                                      305            0x10ad8b
elf64.h                                      305            0x10ad91
elf64.h                                      305            0x10ad9b
elf64.h                                      305            0x10ada1
elf64.h                                      305            0x10adab
elf64.h                                      305            0x10adb1
elf64.h                                      305            0x10adbb
elf64.h                                      305            0x10adc1
elf64.h                                      305            0x10adcb
elf64.h                                      305            0x10add1
elf64.h                                      305            0x10addb
elf64.h                                      305            0x10ade1
elf64.h                                      305            0x10adeb
elf64.h                                      305            0x10adf1
elf64.h                                      305            0x10adfb
elf64.h                                      305            0x10ae01
elf64.h                                      305            0x10ae0b
elf64.h                                      305            0x10ae11
elf64.h                                      305            0x10ae1b
elf64.h                                      305            0x10ae21
elf64.h                                      305            0x10ae2b
elf64.h                                      305            0x10ae31
elf64.h                                      305            0x10ae3b
elf64.h                                      305            0x10ae41
elf64.h                                      305            0x10ae4b
elf64.h                                      305            0x10ae51
elf64.h                                      305            0x10ae5b
elf64.h                                      305            0x10ae61
elf64.h                                      305            0x10ae6b
elf64.h                                      305            0x10ae71
elf64.h                                      305            0x10ae7b
elf64.h                                      305            0x10ae81
elf64.h                                      305            0x10ae8b
elf64.h                                      305            0x10ae91
elf64.h                                      305            0x10ae9b
elf64.h                                      305            0x10aea1
elf64.h                                      305            0x10aeab
elf64.h                                      305            0x10aeb1
elf64.h                                      305            0x10aebb
elf64.h                                      305            0x10aec1
elf64.h                                      305            0x10aecb
elf64.h                                      305            0x10aed1
elf64.h                                      305            0x10aedb
elf64.h                                      305            0x10aee1
elf64.h                                      305            0x10aeeb
elf64.h                                      305            0x10aef1
elf64.h                                      305            0x10aefb
elf64.h                                      305            0x10af01
elf64.h                                      305            0x10af0b
elf64.h                                      305            0x10af11
elf64.h                                      305            0x10af1b
elf64.h                                      305            0x10af21
elf64.h                                      305            0x10af2b
elf64.h                                      305            0x10af31
elf64.h                                      305            0x10af3b
elf64.h                                      305            0x10af41
elf64.h                                      305            0x10af4b
elf64.h                                      305            0x10af51
elf64.h                                      305            0x10af5b
elf64.h                                      305            0x10af61
elf64.h                                      305            0x10af6b
elf64.h                                      305            0x10af71
elf64.h                                      305            0x10af7b
elf64.h                                      305            0x10af81
elf64.h                                      305            0x10af8b
elf64.h                                      305            0x10af91
elf64.h                                      305            0x10af9b
elf64.h                                      305            0x10afa1
elf64.h                                      305            0x10afa8
elf64.h                                      305            0x10afae
elf64.h                                      305            0x10afb5
elf64.h                                      305            0x10afbb
elf64.h                                      305            0x10afc2
elf64.h                                      305            0x10afc8
elf64.h                                      305            0x10afcf
elf64.h                                      305            0x10afd5
elf64.h                                      305            0x10afdc
elf64.h                                      305            0x10afe2
elf64.h                                      305            0x10afe9
elf64.h                                      305            0x10afef
elf64.h                                      305            0x10aff6
elf64.h                                      305            0x10afff
elf64.h                                      305            0x10b006
elf64.h                                      305            0x10b00f
elf64.h                                      306            0x10b016
elf64.h                                      307            0x10b01b
elf64.h                                      309            0x10b01d
elf64.h                                      310            0x10b028
elf64.h                                      310            0x10b02e
elf64.h                                      310            0x10b038
elf64.h                                      310            0x10b03e
elf64.h                                      310            0x10b048
elf64.h                                      310            0x10b04e
elf64.h                                      310            0x10b058
elf64.h                                      310            0x10b05e
elf64.h                                      310            0x10b068
elf64.h                                      310            0x10b06e
elf64.h                                      310            0x10b078
elf64.h                                      310            0x10b07e
elf64.h                                      310            0x10b088
elf64.h                                      310            0x10b08e
elf64.h                                      310            0x10b098
elf64.h                                      310            0x10b09e
elf64.h                                      310            0x10b0a8
elf64.h                                      310            0x10b0ae
elf64.h                                      310            0x10b0b8
elf64.h                                      310            0x10b0be
elf64.h                                      310            0x10b0c8
elf64.h                                      310            0x10b0ce
elf64.h                                      310            0x10b0d8
elf64.h                                      310            0x10b0de
elf64.h                                      310            0x10b0e8
elf64.h                                      310            0x10b0ee
elf64.h                                      310            0x10b0f8
elf64.h                                      310            0x10b0fe
elf64.h                                      310            0x10b108
elf64.h                                      310            0x10b10e
elf64.h                                      310            0x10b118
elf64.h                                      310            0x10b11e
elf64.h                                      310            0x10b128
elf64.h                                      310            0x10b12e
elf64.h                                      310            0x10b138
elf64.h                                      310            0x10b13e
elf64.h                                      310            0x10b148
elf64.h                                      310            0x10b14e
elf64.h                                      310            0x10b158
elf64.h                                      310            0x10b15e
elf64.h                                      310            0x10b168
elf64.h                                      310            0x10b16e
elf64.h                                      310            0x10b178
elf64.h                                      310            0x10b17e
elf64.h                                      310            0x10b188
elf64.h                                      310            0x10b18e
elf64.h                                      310            0x10b198
elf64.h                                      310            0x10b19e
elf64.h                                      310            0x10b1a8
elf64.h                                      310            0x10b1ae
elf64.h                                      310            0x10b1b8
elf64.h                                      310            0x10b1be
elf64.h                                      310            0x10b1c8
elf64.h                                      310            0x10b1ce
elf64.h                                      310            0x10b1d8
elf64.h                                      310            0x10b1de
elf64.h                                      310            0x10b1e8
elf64.h                                      310            0x10b1ee
elf64.h                                      310            0x10b1f8
elf64.h                                      310            0x10b1fe
elf64.h                                      310            0x10b208
elf64.h                                      310            0x10b20e
elf64.h                                      310            0x10b218
elf64.h                                      310            0x10b21e
elf64.h                                      310            0x10b228
elf64.h                                      310            0x10b22e
elf64.h                                      310            0x10b238
elf64.h                                      310            0x10b23e
elf64.h                                      310            0x10b248
elf64.h                                      310            0x10b24e
elf64.h                                      310            0x10b258
elf64.h                                      310            0x10b25e
elf64.h                                      310            0x10b268
elf64.h                                      310            0x10b26e
elf64.h                                      310            0x10b278
elf64.h                                      310            0x10b27e
elf64.h                                      310            0x10b288
elf64.h                                      310            0x10b28e
elf64.h                                      310            0x10b298
elf64.h                                      310            0x10b29e
elf64.h                                      310            0x10b2a8
elf64.h                                      310            0x10b2ae
elf64.h                                      310            0x10b2b8
elf64.h                                      310            0x10b2be
elf64.h                                      310            0x10b2c8
elf64.h                                      310            0x10b2ce
elf64.h                                      310            0x10b2d8
elf64.h                                      310            0x10b2de
elf64.h                                      310            0x10b2e8
elf64.h                                      310            0x10b2ee
elf64.h                                      310            0x10b2f8
elf64.h                                      310            0x10b2fe
elf64.h                                      310            0x10b308
elf64.h                                      310            0x10b30e
elf64.h                                      310            0x10b318
elf64.h                                      310            0x10b31e
elf64.h                                      310            0x10b328
elf64.h                                      310            0x10b32e
elf64.h                                      310            0x10b338
elf64.h                                      310            0x10b33e
elf64.h                                      310            0x10b348
elf64.h                                      310            0x10b34e
elf64.h                                      310            0x10b358
elf64.h                                      310            0x10b35e
elf64.h                                      310            0x10b368
elf64.h                                      310            0x10b36e
elf64.h                                      310            0x10b378
elf64.h                                      310            0x10b37e
elf64.h                                      310            0x10b388
elf64.h                                      310            0x10b38e
elf64.h                                      310            0x10b398
elf64.h                                      310            0x10b39e
elf64.h                                      310            0x10b3a8
elf64.h                                      310            0x10b3ae
elf64.h                                      310            0x10b3b8
elf64.h                                      310            0x10b3be
elf64.h                                      310            0x10b3c8
elf64.h                                      310            0x10b3ce
elf64.h                                      310            0x10b3d8
elf64.h                                      310            0x10b3de
elf64.h                                      310            0x10b3e8
elf64.h                                      310            0x10b3ee
elf64.h                                      310            0x10b3f8
elf64.h                                      310            0x10b3fe
elf64.h                                      310            0x10b408
elf64.h                                      310            0x10b40e
elf64.h                                      310            0x10b418
elf64.h                                      310            0x10b41e
elf64.h                                      310            0x10b428
elf64.h                                      310            0x10b42e
elf64.h                                      310            0x10b438
elf64.h                                      310            0x10b43e
elf64.h                                      310            0x10b448
elf64.h                                      310            0x10b44e
elf64.h                                      310            0x10b458
elf64.h                                      310            0x10b45e
elf64.h                                      310            0x10b468
elf64.h                                      310            0x10b46e
elf64.h                                      310            0x10b478
elf64.h                                      310            0x10b47e
elf64.h                                      310            0x10b488
elf64.h                                      310            0x10b48e
elf64.h                                      310            0x10b498
elf64.h                                      310            0x10b49e
elf64.h                                      310            0x10b4a8
elf64.h                                      310            0x10b4ae
elf64.h                                      310            0x10b4b8
elf64.h                                      310            0x10b4be
elf64.h                                      310            0x10b4c8
elf64.h                                      310            0x10b4ce
elf64.h                                      310            0x10b4d8
elf64.h                                      310            0x10b4de
elf64.h                                      310            0x10b4e8
elf64.h                                      310            0x10b4ee
elf64.h                                      310            0x10b4f8
elf64.h                                      310            0x10b4fe
elf64.h                                      310            0x10b508
elf64.h                                      310            0x10b50e
elf64.h                                      310            0x10b518
elf64.h                                      310            0x10b51e
elf64.h                                      310            0x10b528
elf64.h                                      310            0x10b52e
elf64.h                                      310            0x10b538
elf64.h                                      310            0x10b53e
elf64.h                                      310            0x10b548
elf64.h                                      310            0x10b54e
elf64.h                                      310            0x10b558
elf64.h                                      310            0x10b55e
elf64.h                                      310            0x10b568
elf64.h                                      310            0x10b56e
elf64.h                                      310            0x10b578
elf64.h                                      310            0x10b57e
elf64.h                                      310            0x10b585
elf64.h                                      310            0x10b58b
elf64.h                                      310            0x10b592
elf64.h                                      310            0x10b598
elf64.h                                      310            0x10b59f
elf64.h                                      310            0x10b5a5
elf64.h                                      310            0x10b5ac
elf64.h                                      310            0x10b5b2
elf64.h                                      310            0x10b5b9
elf64.h                                      310            0x10b5bf
elf64.h                                      310            0x10b5c6
elf64.h                                      310            0x10b5cc
elf64.h                                      310            0x10b5d3
elf64.h                                      310            0x10b5dc
elf64.h                                      310            0x10b5e3
elf64.h                                      310            0x10b5ec
elf64.h                                      311            0x10b5f3
elf64.h                                      312            0x10b5f8
elf64.h                                      314            0x10b5fa
elf64.h                                      315            0x10b605
elf64.h                                      315            0x10b60b
elf64.h                                      315            0x10b615
elf64.h                                      315            0x10b61b
elf64.h                                      315            0x10b625
elf64.h                                      315            0x10b62b
elf64.h                                      315            0x10b635
elf64.h                                      315            0x10b63b
elf64.h                                      315            0x10b645
elf64.h                                      315            0x10b64b
elf64.h                                      315            0x10b655
elf64.h                                      315            0x10b65b
elf64.h                                      315            0x10b665
elf64.h                                      315            0x10b66b
elf64.h                                      315            0x10b675
elf64.h                                      315            0x10b67b
elf64.h                                      315            0x10b685
elf64.h                                      315            0x10b68b
elf64.h                                      315            0x10b695
elf64.h                                      315            0x10b69b
elf64.h                                      315            0x10b6a5
elf64.h                                      315            0x10b6ab
elf64.h                                      315            0x10b6b5
elf64.h                                      315            0x10b6bb
elf64.h                                      315            0x10b6c5
elf64.h                                      315            0x10b6cb
elf64.h                                      315            0x10b6d5
elf64.h                                      315            0x10b6db
elf64.h                                      315            0x10b6e5
elf64.h                                      315            0x10b6eb
elf64.h                                      315            0x10b6f5
elf64.h                                      315            0x10b6fb
elf64.h                                      315            0x10b702
elf64.h                                      315            0x10b708
elf64.h                                      315            0x10b70f
elf64.h                                      315            0x10b715
elf64.h                                      315            0x10b71c
elf64.h                                      315            0x10b722
elf64.h                                      315            0x10b729
elf64.h                                      315            0x10b72f
elf64.h                                      315            0x10b736
elf64.h                                      315            0x10b73c
elf64.h                                      315            0x10b743
elf64.h                                      315            0x10b749
elf64.h                                      315            0x10b750
elf64.h                                      315            0x10b756
elf64.h                                      315            0x10b75d
elf64.h                                      315            0x10b763
elf64.h                                      315            0x10b76a
elf64.h                                      315            0x10b770
elf64.h                                      316            0x10b777
elf64.h                                      317            0x10b77c

src/kernel_process.c:
kernel_process.c                              19            0x10b77e
kernel_process.c                              20            0x10b78a
kernel_process.c                              21            0x10b792
kernel_process.c                              22            0x10b79f
kernel_process.c                              23            0x10b7b3
kernel_process.c                              37            0x10b7ba
kernel_process.c                              38            0x10b7c2

src/kernel_debug.c:
kernel_debug.c                                22            0x10b7c4
kernel_debug.c                                23            0x10b7d0
kernel_debug.c                                24            0x10b7dd
kernel_debug.c                                26            0x10b7e4
kernel_debug.c                                28            0x10b802
kernel_debug.c                                29            0x10b81c
kernel_debug.c                                30            0x10b839
kernel_debug.c                                23            0x10b859
kernel_debug.c                                23            0x10b85e
kernel_debug.c                                32            0x10b869
kernel_debug.c                                36            0x10b86c
kernel_debug.c                                37            0x10b878
kernel_debug.c                                38            0x10b886
kernel_debug.c                                39            0x10b898
kernel_debug.c                                40            0x10b8aa
kernel_debug.c                                41            0x10b8bc
kernel_debug.c                                42            0x10b8ce
kernel_debug.c                                43            0x10b8e0
kernel_debug.c                                44            0x10b8f2
kernel_debug.c                                45            0x10b90d
kernel_debug.c                                45            0x10b913
kernel_debug.c                                45            0x10b91a
kernel_debug.c                                45            0x10b91f
kernel_debug.c                                46            0x10b936
kernel_debug.c                                46            0x10b93c
kernel_debug.c                                46            0x10b943
kernel_debug.c                                46            0x10b948
kernel_debug.c                                47            0x10b95f
kernel_debug.c                                47            0x10b965
kernel_debug.c                                47            0x10b96c
kernel_debug.c                                47            0x10b971
kernel_debug.c                                48            0x10b988
kernel_debug.c                                48            0x10b98e
kernel_debug.c                                48            0x10b995
kernel_debug.c                                48            0x10b99a
kernel_debug.c                                49            0x10b9b1
kernel_debug.c                                49            0x10b9b7
kernel_debug.c                                49            0x10b9be
kernel_debug.c                                49            0x10b9c3
kernel_debug.c                                50            0x10b9da
kernel_debug.c                                50            0x10b9e0
kernel_debug.c                                50            0x10b9e7
kernel_debug.c                                50            0x10b9ec
kernel_debug.c                                51            0x10ba03
kernel_debug.c                                54            0x10ba06
kernel_debug.c                                55            0x10ba12
kernel_debug.c                                56            0x10ba23
kernel_debug.c                                57            0x10ba34
kernel_debug.c                                58            0x10ba45
kernel_debug.c                                60            0x10ba52
kernel_debug.c                                61            0x10ba66
kernel_debug.c                                62            0x10ba81
kernel_debug.c                                63            0x10ba9c
kernel_debug.c                                64            0x10bab7
kernel_debug.c                                65            0x10bad2
kernel_debug.c                                67            0x10baed
kernel_debug.c                                68            0x10bb01
kernel_debug.c                                69            0x10bb15
kernel_debug.c                                70            0x10bb29
kernel_debug.c                                71            0x10bb3d
kernel_debug.c                                72            0x10bb51
kernel_debug.c                                73            0x10bb65
kernel_debug.c                                76            0x10bb68
kernel_debug.c                                77            0x10bb70
kernel_debug.c                                78            0x10bb7a
kernel_debug.c                                79            0x10bb92
kernel_debug.c                                80            0x10bba8
kernel_debug.c                                81            0x10bbb4
kernel_debug.c                                77            0x10bbd6
kernel_debug.c                                77            0x10bbdb
kernel_debug.c                                83            0x10bbe9

src/kernel_entry.c:
kernel_entry.c                               248            0x10bbec
kernel_entry.c                               249            0x10bbfc
kernel_entry.c                               250            0x10bc06
kernel_entry.c                               251            0x10bc0b
kernel_entry.c                               252            0x10bc15
kernel_entry.c                               255            0x10bc1f
kernel_entry.c                               258            0x10bc2a
kernel_entry.c                               259            0x10bc34
kernel_entry.c                               260            0x10bc48
kernel_entry.c                               263            0x10bc54
kernel_entry.c                               264            0x10bc60
kernel_entry.c                               265            0x10bc74
kernel_entry.c                               268            0x10bc80
kernel_entry.c                               269            0x10bc88
kernel_entry.c                               270            0x10bc90
kernel_entry.c                               271            0x10bc9c
kernel_entry.c                               272            0x10bc9e
kernel_entry.c                               274            0x10bcb5
kernel_entry.c                               275            0x10bcbd
kernel_entry.c                               276            0x10bcc9
kernel_entry.c                               278            0x10bccb
kernel_entry.c                               279            0x10bcd3
kernel_entry.c                               280            0x10bcdf
kernel_entry.c                               283            0x10bce1
kernel_entry.c                               284            0x10bce9
kernel_entry.c                               307            0x10bcea
kernel_entry.c                               271            0x10bcfd
kernel_entry.c                               311            0x10bd07
kernel_entry.c                               312            0x10bd0e
kernel_entry.c                               315            0x10bd3e
kernel_entry.c                               316            0x10bd4a
kernel_entry.c                               318            0x10bd63
kernel_entry.c                               319            0x10bd6b
kernel_entry.c                               320            0x10bd86
kernel_entry.c                               322            0x10bdae
kernel_entry.c                               323            0x10bdb6
kernel_entry.c                               324            0x10bdc3
kernel_entry.c                               325            0x10bdd1
kernel_entry.c                               326            0x10bddd
kernel_entry.c                               327            0x10bdf1
kernel_entry.c                               328            0x10bdff
kernel_entry.c                               332            0x10be32
kernel_entry.c                               333            0x10be39
kernel_entry.c                               336            0x10be69
kernel_entry.c                               337            0x10be71
kernel_entry.c                               344            0x10be84
kernel_entry.c                               345            0x10be8c
kernel_entry.c                               346            0x10be98
kernel_entry.c                               347            0x10beac
kernel_entry.c                               348            0x10beb7
kernel_entry.c                               349            0x10bec2
kernel_entry.c                               350            0x10bee0
kernel_entry.c                               351            0x10bee8
kernel_entry.c                               352            0x10bf12
kernel_entry.c                               357            0x10bf1c
kernel_entry.c                               358            0x10bf28
kernel_entry.c                               359            0x10bf34
kernel_entry.c                               360            0x10bf4e
kernel_entry.c                               361            0x10bf69
kernel_entry.c                               362            0x10bf93
kernel_entry.c                               363            0x10bfbc
kernel_entry.c                               364            0x10bfcc
kernel_entry.c                               365            0x10bfdc
kernel_entry.c                               402            0x10bff0
kernel_entry.c                               407            0x10c00f

src/interrupt_handler.c:
interrupt_handler.c                           25            0x10c012
interrupt_handler.c                           26            0x10c01e
interrupt_handler.c                           27            0x10c039
interrupt_handler.c                           28            0x10c057
interrupt_handler.c                           29            0x10c059
interrupt_handler.c                           30            0x10c06d
interrupt_handler.c                           31            0x10c06e
interrupt_handler.c                           33            0x10c071
interrupt_handler.c                           34            0x10c081
interrupt_handler.c                           35            0x10c096
interrupt_handler.c                           37            0x10c099
interrupt_handler.c                           39            0x10c09d
interrupt_handler.c                           40            0x10c0a5
interrupt_handler.c                           41            0x10c0ad
interrupt_handler.c                           42            0x10c0b6
interrupt_handler.c                           43            0x10c0c1
interrupt_handler.c                           44            0x10c0c8
interrupt_handler.c                           52            0x10c0cb
interrupt_handler.c                           53            0x10c0cf
interrupt_handler.c                           54            0x10c0f9
interrupt_handler.c                           55            0x10c114
interrupt_handler.c                           56            0x10c12f
interrupt_handler.c                           57            0x10c140
interrupt_handler.c                           59            0x10c170
interrupt_handler.c                           62            0x10c173
interrupt_handler.c                           63            0x10c17b
interrupt_handler.c                           64            0x10c18c
interrupt_handler.c                           66            0x10c1a2
interrupt_handler.c                           67            0x10c1a5
interrupt_handler.c                           68            0x10c1b5
interrupt_handler.c                           70            0x10c1bb
interrupt_handler.c                           71            0x10c1d4
interrupt_handler.c                           98            0x10c1d7
interrupt_handler.c                          101            0x10c1df
interrupt_handler.c                          102            0x10c1f2
interrupt_handler.c                          103            0x10c201
interrupt_handler.c                          104            0x10c214
interrupt_handler.c                          105            0x10c21f
interrupt_handler.c                          110            0x10c239
interrupt_handler.c                          111            0x10c246
interrupt_handler.c                          112            0x10c25a
interrupt_handler.c                          115            0x10c25c
interrupt_handler.c                          116            0x10c262
interrupt_handler.c                          117            0x10c26c
interrupt_handler.c                          119            0x10c27b
interrupt_handler.c                          124            0x10c288
interrupt_handler.c                          126            0x10c2ab
interrupt_handler.c                          129            0x10c2ad
interrupt_handler.c                          130            0x10c2bd
interrupt_handler.c                          131            0x10c2ca
interrupt_handler.c                          133            0x10c2e2
interrupt_handler.c                          134            0x10c2e8
interrupt_handler.c                          135            0x10c2f9
interrupt_handler.c                          136            0x10c2ff
interrupt_handler.c                          137            0x10c310
interrupt_handler.c                          138            0x10c316
interrupt_handler.c                          139            0x10c335
interrupt_handler.c                          143            0x10c34f
interrupt_handler.c                          144            0x10c35c
interrupt_handler.c                          145            0x10c362
interrupt_handler.c                          146            0x10c372
interrupt_handler.c                          147            0x10c38c
interrupt_handler.c                          151            0x10c397
interrupt_handler.c                          152            0x10c39d
interrupt_handler.c                          153            0x10c3a1
interrupt_handler.c                          154            0x10c3ad
interrupt_handler.c                          153            0x10c3b5
interrupt_handler.c                          155            0x10c3b9
interrupt_handler.c                          156            0x10c3cb
interrupt_handler.c                          157            0x10c3db
interrupt_handler.c                          158            0x10c3e1
interrupt_handler.c                          130            0x10c3f3
interrupt_handler.c                          130            0x10c3f8
interrupt_handler.c                          157            0x10c40f
interrupt_handler.c                          161            0x10c410
interrupt_handler.c                          164            0x10c412
interrupt_handler.c                          165            0x10c41a
interrupt_handler.c                          166            0x10c422
interrupt_handler.c                          167            0x10c432
interrupt_handler.c                          168            0x10c443
interrupt_handler.c                          169            0x10c45e
interrupt_handler.c                          170            0x10c476
interrupt_handler.c                          171            0x10c48c
interrupt_handler.c                          172            0x10c4a9
interrupt_handler.c                          175            0x10c4b8
interrupt_handler.c                          176            0x10c4c2

src/kernel_log.c:
kernel_log.c                                  37            0x10c4c5
kernel_log.c                                  38            0x10c4d5
kernel_log.c                                  39            0x10c4e0
kernel_log.c                                  40            0x10c4ea
kernel_log.c                                  41            0x10c4fb
kernel_log.c                                  42            0x10c51e
kernel_log.c                                  39            0x10c537
kernel_log.c                                  39            0x10c53c
kernel_log.c                                  44            0x10c546
kernel_log.c                                  47            0x10c549
kernel_log.c                                  48            0x10c55e
kernel_log.c                                  49            0x10c566
kernel_log.c                                  50            0x10c56d
kernel_log.c                                  51            0x10c574
kernel_log.c                                  55            0x10c57e
kernel_log.c                                  56            0x10c5ae
kernel_log.c                                  53            0x10c5c2
kernel_log.c                                  58            0x10c5c9
kernel_log.c                                  60            0x10c5dc
kernel_log.c                                  61            0x10c5e0
kernel_log.c                                  84            0x10c5e2
kernel_log.c                                  85            0x10c5fa
kernel_log.c                                  86            0x10c602
kernel_log.c                                  87            0x10c60a
kernel_log.c                                  88            0x10c60f
kernel_log.c                                  89            0x10c625
kernel_log.c                                  91            0x10c62a
kernel_log.c                                  92            0x10c640
kernel_log.c                                  93            0x10c645
kernel_log.c                                  94            0x10c65b
kernel_log.c                                  95            0x10c6a5
kernel_log.c                                  95            0x10c6b3
kernel_log.c                                  96            0x10c6bc
kernel_log.c                                  97            0x10c6e0
kernel_log.c                                 102            0x10c6ea
kernel_log.c                                 103            0x10c700
kernel_log.c                                 104            0x10c748
kernel_log.c                                 104            0x10c756
kernel_log.c                                 105            0x10c75f
kernel_log.c                                 106            0x10c781
kernel_log.c                                 110            0x10c78b
kernel_log.c                                 111            0x10c7a1
kernel_log.c                                 112            0x10c7eb
kernel_log.c                                 113            0x10c7fb
kernel_log.c                                 113            0x10c80c
kernel_log.c                                 114            0x10c815
kernel_log.c                                 115            0x10c834
kernel_log.c                                 116            0x10c83c
kernel_log.c                                 119            0x10c846
kernel_log.c                                 120            0x10c85c
kernel_log.c                                 121            0x10c8a6
kernel_log.c                                 121            0x10c8b4
kernel_log.c                                 122            0x10c8bd
kernel_log.c                                 123            0x10c8e1
kernel_log.c                                 126            0x10c8eb
kernel_log.c                                 127            0x10c901
kernel_log.c                                 128            0x10c906
kernel_log.c                                 129            0x10c91c
kernel_log.c                                 130            0x10c921
kernel_log.c                                 131            0x10c937
kernel_log.c                                 132            0x10c93c
kernel_log.c                                 133            0x10c986
kernel_log.c                                 134            0x10c9d0
kernel_log.c                                 134            0x10c9e1
kernel_log.c                                 135            0x10c9ea
kernel_log.c                                 136            0x10ca09
kernel_log.c                                 143            0x10ca16
kernel_log.c                                 144            0x10ca1e
kernel_log.c                                 145            0x10ca20
kernel_log.c                                 144            0x10ca25
kernel_log.c                                 144            0x10ca37
kernel_log.c                                 148            0x10ca49
kernel_log.c                                 149            0x10ca55
kernel_log.c                                 149            0x10ca66
kernel_log.c                                 150            0x10ca6c
kernel_log.c                                 151            0x10ca93
kernel_log.c                                  87            0x10ca9b
kernel_log.c                                 154            0x10cab1
kernel_log.c                                 155            0x10cab5
kernel_log.c                                 157            0x10cab7
kernel_log.c                                 158            0x10cac3
kernel_log.c                                 159            0x10cad5
kernel_log.c                                 160            0x10cae9
kernel_log.c                                 161            0x10cb06
kernel_log.c                                 162            0x10cb20
kernel_log.c                                 163            0x10cb33
kernel_log.c                                 165            0x10cb4d
kernel_log.c                                 166            0x10cb5f
kernel_log.c                                 167            0x10cb63
kernel_log.c                                 169            0x10cb65
kernel_log.c                                 170            0x10cb79
kernel_log.c                                 171            0x10cb83
kernel_log.c                                 172            0x10cb9e
kernel_log.c                                 173            0x10cbbe
kernel_log.c                                 176            0x10cbc3
kernel_log.c                                 177            0x10cbd2
kernel_log.c                                 178            0x10cbe2
kernel_log.c                                 179            0x10cbf9
kernel_log.c                                 181            0x10cc09
kernel_log.c                                 182            0x10cc1b
kernel_log.c                                 183            0x10cc26
kernel_log.c                                 184            0x10cc41
kernel_log.c                                 185            0x10cc50
kernel_log.c                                 176            0x10cc64
kernel_log.c                                 186            0x10cc65
kernel_log.c                                 188            0x10cc67
kernel_log.c                                 189            0x10ccc0
kernel_log.c                                 191            0x10cccf
kernel_log.c                                 192            0x10cce4
kernel_log.c                                 193            0x10ccfe
kernel_log.c                                 194            0x10cd24
kernel_log.c                                 195            0x10cd44
kernel_log.c                                 195            0x10cd5a
kernel_log.c                                 196            0x10cd7a
kernel_log.c                                 199            0x10cd8f
kernel_log.c                                 200            0x10cdbc
kernel_log.c                                 206            0x10cded
kernel_log.c                                 207            0x10ce02
kernel_log.c                                 208            0x10ce10
kernel_log.c                                 209            0x10ce31
kernel_log.c                                 210            0x10ce40
kernel_log.c                                 189            0x10ce57
kernel_log.c                                 211            0x10ce58
kernel_log.c                                 213            0x10ce5a
kernel_log.c                                 214            0x10ce6b
kernel_log.c                                 214            0x10ce75
kernel_log.c                                 215            0x10ce7f
kernel_log.c                                 216            0x10ce91
kernel_log.c                                 217            0x10cea4
kernel_log.c                                 218            0x10ceb6
kernel_log.c                                 220            0x10ceb8
kernel_log.c                                 221            0x10cee1
kernel_log.c                                 222            0x10ceec
kernel_log.c                                 214            0x10cf00
kernel_log.c                                 223            0x10cf01
kernel_log.c                                 225            0x10cf03
kernel_log.c                                 226            0x10cf0f
kernel_log.c                                 227            0x10cf21
kernel_log.c                                 228            0x10cf31
kernel_log.c                                 229            0x10cf48
kernel_log.c                                 231            0x10cf62
kernel_log.c                                 232            0x10cf6d
kernel_log.c                                 233            0x10cf7f
kernel_log.c                                 235            0x10cf82
kernel_log.c                                 236            0x10cf8e
kernel_log.c                                 237            0x10cf9e
kernel_log.c                                 238            0x10cfa9
kernel_log.c                                 239            0x10cfb8
kernel_log.c                                 240            0x10cfc7
kernel_log.c                                 242            0x10cfe1
kernel_log.c                                 246            0x10cfe4
kernel_log.c                                 247            0x10cfe8
kernel_log.c                                 248            0x10cfef
kernel_log.c                                 250            0x10cff2
kernel_log.c                                 251            0x10cff6
kernel_log.c                                 252            0x10cffd

src/kernel_shell.c:
kernel_shell.c                                42            0x10d000
kernel_shell.c                                43            0x10d010
kernel_shell.c                                46            0x10d024
kernel_shell.c                                48            0x10d0a1
kernel_shell.c                                51            0x10d0a4
kernel_shell.c                                52            0x10d0b4
kernel_shell.c                                53            0x10d0d2
kernel_shell.c                                54            0x10d0da
kernel_shell.c                                55            0x10d0e2
kernel_shell.c                                56            0x10d0ea
kernel_shell.c                                57            0x10d0f2
kernel_shell.c                                58            0x10d10a
kernel_shell.c                                59            0x10d122
kernel_shell.c                                60            0x10d138
kernel_shell.c                                61            0x10d14a
kernel_shell.c                                62            0x10d158
kernel_shell.c                                63            0x10d16b
kernel_shell.c                                66            0x10d16e
kernel_shell.c                                67            0x10d17e
kernel_shell.c                                68            0x10d18d
kernel_shell.c                                71            0x10d190
kernel_shell.c                                73            0x10d1a0
kernel_shell.c                                76            0x10d1a3
kernel_shell.c                                77            0x10d1b3
kernel_shell.c                                78            0x10d1ce
kernel_shell.c                                80            0x10d1d1
kernel_shell.c                                86            0x10d1e1
kernel_shell.c                                86            0x10d1fb
kernel_shell.c                                86            0x10d213
kernel_shell.c                                86            0x10d22d
kernel_shell.c                                86            0x10d245
kernel_shell.c                                86            0x10d25f
kernel_shell.c                                86            0x10d274
kernel_shell.c                                86            0x10d28e
kernel_shell.c                                86            0x10d2a3
kernel_shell.c                                86            0x10d2bd
kernel_shell.c                                89            0x10d2d2
kernel_shell.c                                90            0x10d2ed


Disassembly of section .text:

0000000000109000 <__memset>:
  write += LITERAL_STRLEN(literal)

#define memcpy(dest,src,size) __memcpy((uint8_t*)dest, (uint8_t*)src, size)
#define memset(dest,value,size) __memset((uint8_t*)dest, value, size)

void __memset(uint8_t *dest, uint8_t value, size_t size) {
  109000:	55                   	push   rbp
  109001:	48 89 e5             	mov    rbp,rsp
  109004:	48 83 ec 28          	sub    rsp,0x28
  109008:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10900c:	89 f0                	mov    eax,esi
  10900e:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
  109012:	88 45 e4             	mov    BYTE PTR [rbp-0x1c],al
  for (size_t i = 0; i < size; i++) {
  109015:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10901c:	00 
  10901d:	eb 16                	jmp    109035 <__memset+0x35>
		dest[i] = value;
  10901f:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  109023:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109027:	48 01 c2             	add    rdx,rax
  10902a:	0f b6 45 e4          	movzx  eax,BYTE PTR [rbp-0x1c]
  10902e:	88 02                	mov    BYTE PTR [rdx],al
  for (size_t i = 0; i < size; i++) {
  109030:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  109035:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109039:	48 3b 45 d8          	cmp    rax,QWORD PTR [rbp-0x28]
  10903d:	72 e0                	jb     10901f <__memset+0x1f>
	}
}
  10903f:	90                   	nop
  109040:	c9                   	leave  
  109041:	c3                   	ret    

0000000000109042 <__memcpy>:

void __memcpy(uint8_t *dest, uint8_t *src, size_t size) {
  109042:	55                   	push   rbp
  109043:	48 89 e5             	mov    rbp,rsp
  109046:	48 83 ec 28          	sub    rsp,0x28
  10904a:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10904e:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  109052:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
	for (size_t i = 0; i < size; i++) {
  109056:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10905d:	00 
  10905e:	eb 20                	jmp    109080 <__memcpy+0x3e>
		dest[i] = src[i];
  109060:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  109064:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109068:	48 01 c2             	add    rdx,rax
  10906b:	48 8b 4d e0          	mov    rcx,QWORD PTR [rbp-0x20]
  10906f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109073:	48 01 c8             	add    rax,rcx
  109076:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  109079:	88 02                	mov    BYTE PTR [rdx],al
	for (size_t i = 0; i < size; i++) {
  10907b:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  109080:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109084:	48 3b 45 d8          	cmp    rax,QWORD PTR [rbp-0x28]
  109088:	72 d6                	jb     109060 <__memcpy+0x1e>
	}
}
  10908a:	90                   	nop
  10908b:	c9                   	leave  
  10908c:	c3                   	ret    

000000000010908d <strlen>:

static inline
size_t strlen(const char *str) {
  10908d:	55                   	push   rbp
  10908e:	48 89 e5             	mov    rbp,rsp
  109091:	48 83 ec 18          	sub    rsp,0x18
  109095:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
	size_t result = 0;
  109099:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  1090a0:	00 
	while (str[result] != 0)
  1090a1:	eb 05                	jmp    1090a8 <strlen+0x1b>
		result ++;
  1090a3:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
	while (str[result] != 0)
  1090a8:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  1090ac:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  1090b0:	48 01 d0             	add    rax,rdx
  1090b3:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  1090b6:	84 c0                	test   al,al
  1090b8:	75 e9                	jne    1090a3 <strlen+0x16>
	return result;
  1090ba:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
}
  1090be:	c9                   	leave  
  1090bf:	c3                   	ret    

00000000001090c0 <string_equals_string>:


#define string_matches_literal(string, len, lit) strings_match(string,len, lit, LITERAL_STRLEN(lit))

static int 
string_equals_string(const char *stringA, size_t lengthA, const char *stringB, size_t lengthB) {
  1090c0:	55                   	push   rbp
  1090c1:	48 89 e5             	mov    rbp,rsp
  1090c4:	48 83 ec 30          	sub    rsp,0x30
  1090c8:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  1090cc:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  1090d0:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
  1090d4:	48 89 4d d0          	mov    QWORD PTR [rbp-0x30],rcx
	if (lengthA != lengthB) return 0;
  1090d8:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  1090dc:	48 3b 45 d0          	cmp    rax,QWORD PTR [rbp-0x30]
  1090e0:	74 07                	je     1090e9 <string_equals_string+0x29>
  1090e2:	b8 00 00 00 00       	mov    eax,0x0
  1090e7:	eb 45                	jmp    10912e <string_equals_string+0x6e>
	for (size_t i = 0; i < lengthA; i++) {
  1090e9:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  1090f0:	00 
  1090f1:	eb 2c                	jmp    10911f <string_equals_string+0x5f>
		if (stringA[i] != stringB[i]) {
  1090f3:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  1090f7:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  1090fb:	48 01 d0             	add    rax,rdx
  1090fe:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  109101:	48 8b 4d d8          	mov    rcx,QWORD PTR [rbp-0x28]
  109105:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109109:	48 01 c8             	add    rax,rcx
  10910c:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10910f:	38 c2                	cmp    dl,al
  109111:	74 07                	je     10911a <string_equals_string+0x5a>
			return 0;
  109113:	b8 00 00 00 00       	mov    eax,0x0
  109118:	eb 14                	jmp    10912e <string_equals_string+0x6e>
	for (size_t i = 0; i < lengthA; i++) {
  10911a:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10911f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109123:	48 3b 45 e0          	cmp    rax,QWORD PTR [rbp-0x20]
  109127:	72 ca                	jb     1090f3 <string_equals_string+0x33>
		}
	}
	return 1;
  109129:	b8 01 00 00 00       	mov    eax,0x1
}
  10912e:	c9                   	leave  
  10912f:	c3                   	ret    

0000000000109130 <string_matches_string>:

static int
string_matches_string(const char *str0, size_t length, const char *str1){
  109130:	55                   	push   rbp
  109131:	48 89 e5             	mov    rbp,rsp
  109134:	48 83 ec 28          	sub    rsp,0x28
  109138:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10913c:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  109140:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
  for(size_t i = 0; i < length; i++) 
  109144:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10914b:	00 
  10914c:	eb 2c                	jmp    10917a <string_matches_string+0x4a>
    if(str0[i] != str1[i]) return 0;
  10914e:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  109152:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109156:	48 01 d0             	add    rax,rdx
  109159:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  10915c:	48 8b 4d d8          	mov    rcx,QWORD PTR [rbp-0x28]
  109160:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109164:	48 01 c8             	add    rax,rcx
  109167:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10916a:	38 c2                	cmp    dl,al
  10916c:	74 07                	je     109175 <string_matches_string+0x45>
  10916e:	b8 00 00 00 00       	mov    eax,0x0
  109173:	eb 14                	jmp    109189 <string_matches_string+0x59>
  for(size_t i = 0; i < length; i++) 
  109175:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10917a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10917e:	48 3b 45 e0          	cmp    rax,QWORD PTR [rbp-0x20]
  109182:	72 ca                	jb     10914e <string_matches_string+0x1e>
  return 1;
  109184:	b8 01 00 00 00       	mov    eax,0x1
}
  109189:	c9                   	leave  
  10918a:	c3                   	ret    

000000000010918b <is_char_alpha>:


int is_char_alpha(char c) {
  10918b:	55                   	push   rbp
  10918c:	48 89 e5             	mov    rbp,rsp
  10918f:	48 83 ec 08          	sub    rsp,0x8
  109193:	89 f8                	mov    eax,edi
  109195:	88 45 fc             	mov    BYTE PTR [rbp-0x4],al
	if ((c >= 'A' && c <= 'Z') ||
  109198:	80 7d fc 40          	cmp    BYTE PTR [rbp-0x4],0x40
  10919c:	7e 06                	jle    1091a4 <is_char_alpha+0x19>
  10919e:	80 7d fc 5a          	cmp    BYTE PTR [rbp-0x4],0x5a
  1091a2:	7e 0c                	jle    1091b0 <is_char_alpha+0x25>
  1091a4:	80 7d fc 60          	cmp    BYTE PTR [rbp-0x4],0x60
  1091a8:	7e 0d                	jle    1091b7 <is_char_alpha+0x2c>
			(c >= 'a' && c <= 'z')) {
  1091aa:	80 7d fc 7a          	cmp    BYTE PTR [rbp-0x4],0x7a
  1091ae:	7f 07                	jg     1091b7 <is_char_alpha+0x2c>
		return 1;
  1091b0:	b8 01 00 00 00       	mov    eax,0x1
  1091b5:	eb 05                	jmp    1091bc <is_char_alpha+0x31>
	}

	return 0;
  1091b7:	b8 00 00 00 00       	mov    eax,0x0
}
  1091bc:	c9                   	leave  
  1091bd:	c3                   	ret    

00000000001091be <spinlock_aquire>:
typedef struct {
  volatile int lock;
} Spin_Lock;

static inline
void spinlock_aquire(Spin_Lock *lock){
  1091be:	55                   	push   rbp
  1091bf:	48 89 e5             	mov    rbp,rsp
  1091c2:	48 83 ec 08          	sub    rsp,0x8
  1091c6:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  while(!__sync_bool_compare_and_swap(&lock->lock, 0, 1));
  1091ca:	90                   	nop
  1091cb:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  1091cf:	b8 00 00 00 00       	mov    eax,0x0
  1091d4:	b9 01 00 00 00       	mov    ecx,0x1
  1091d9:	f0 0f b1 0a          	lock cmpxchg DWORD PTR [rdx],ecx
  1091dd:	0f 94 c0             	sete   al
  1091e0:	83 f0 01             	xor    eax,0x1
  1091e3:	84 c0                	test   al,al
  1091e5:	75 e4                	jne    1091cb <spinlock_aquire+0xd>
  __sync_synchronize();
  1091e7:	0f ae f0             	mfence 
}
  1091ea:	90                   	nop
  1091eb:	c9                   	leave  
  1091ec:	c3                   	ret    

00000000001091ed <spinlock_release>:

static inline
void spinlock_release(Spin_Lock *lock){
  1091ed:	55                   	push   rbp
  1091ee:	48 89 e5             	mov    rbp,rsp
  1091f1:	48 83 ec 08          	sub    rsp,0x8
  1091f5:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  __sync_synchronize(); 
  1091f9:	0f ae f0             	mfence 
  lock->lock = 0;
  1091fc:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109200:	c7 00 00 00 00 00    	mov    DWORD PTR [rax],0x0
  109206:	90                   	nop
  109207:	c9                   	leave  
  109208:	c3                   	ret    

0000000000109209 <write_port_uint8>:
	asm volatile ("cli"); \
	asm volatile ("hlt")


static inline 
void write_port_uint8(uint16_t port, uint8_t value) {
  109209:	55                   	push   rbp
  10920a:	48 89 e5             	mov    rbp,rsp
  10920d:	48 83 ec 08          	sub    rsp,0x8
  109211:	89 fa                	mov    edx,edi
  109213:	89 f0                	mov    eax,esi
  109215:	66 89 55 fc          	mov    WORD PTR [rbp-0x4],dx
  109219:	88 45 f8             	mov    BYTE PTR [rbp-0x8],al
	asm volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
  10921c:	0f b6 45 f8          	movzx  eax,BYTE PTR [rbp-0x8]
  109220:	0f b7 55 fc          	movzx  edx,WORD PTR [rbp-0x4]
  109224:	ee                   	out    dx,al
}
  109225:	90                   	nop
  109226:	c9                   	leave  
  109227:	c3                   	ret    

0000000000109228 <read_port_uint8>:
  asm volatile ("outl %0, %1" : : "a"(value), "Nd"(port));
}


static inline
uint8_t read_port_uint8(uint16_t port) {
  109228:	55                   	push   rbp
  109229:	48 89 e5             	mov    rbp,rsp
  10922c:	48 83 ec 18          	sub    rsp,0x18
  109230:	89 f8                	mov    eax,edi
  109232:	66 89 45 ec          	mov    WORD PTR [rbp-0x14],ax
	uint8_t result;
	asm volatile ("inb %1, %0" : "=a"(result) : "Nd"(port));
  109236:	0f b7 45 ec          	movzx  eax,WORD PTR [rbp-0x14]
  10923a:	89 c2                	mov    edx,eax
  10923c:	ec                   	in     al,dx
  10923d:	88 45 ff             	mov    BYTE PTR [rbp-0x1],al
	return result;
  109240:	0f b6 45 ff          	movzx  eax,BYTE PTR [rbp-0x1]
}
  109244:	c9                   	leave  
  109245:	c3                   	ret    

0000000000109246 <kernel_reboot>:
	return result;
}

//TODO(Torin) Proper rebooting with ACPI
static void
kernel_reboot() {
  109246:	55                   	push   rbp
  109247:	48 89 e5             	mov    rbp,rsp
  10924a:	48 83 ec 10          	sub    rsp,0x10
	struct {
			uint16_t size;
			uintptr_t address;
	} __attribute__((packed)) idtr = { 0, 0 };
  10924e:	66 c7 45 f0 00 00    	mov    WORD PTR [rbp-0x10],0x0
  109254:	48 c7 45 f2 00 00 00 	mov    QWORD PTR [rbp-0xe],0x0
  10925b:	00 
	asm volatile ("lidt %0" : : "m"(idtr));
  10925c:	0f 01 5d f0          	lidt   [rbp-0x10]
	asm volatile ("int $0x3");
  109260:	cc                   	int3   
}
  109261:	90                   	nop
  109262:	c9                   	leave  
  109263:	c3                   	ret    

0000000000109264 <kgfx_draw_character>:
    }
  }
}

#else
void kgfx_draw_character(char c, size_t x_orign, size_t y_origin, Framebuffer *fb) {
  109264:	55                   	push   rbp
  109265:	48 89 e5             	mov    rbp,rsp
  109268:	48 83 ec 50          	sub    rsp,0x50
  10926c:	89 f8                	mov    eax,edi
  10926e:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  109272:	48 89 55 b8          	mov    QWORD PTR [rbp-0x48],rdx
  109276:	48 89 4d b0          	mov    QWORD PTR [rbp-0x50],rcx
  10927a:	88 45 cc             	mov    BYTE PTR [rbp-0x34],al
  const uint8_t *character_data = &INCONSOLATA16[(c - ' ') * 256];
  10927d:	0f be 45 cc          	movsx  eax,BYTE PTR [rbp-0x34]
  109281:	83 e8 20             	sub    eax,0x20
  109284:	c1 e0 08             	shl    eax,0x8
  109287:	48 98                	cdqe   
  109289:	48 05 40 00 10 00    	add    rax,0x100040
  10928f:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
  for(size_t i = 0; i < 16; i++){
  109293:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10929a:	00 
  10929b:	e9 d2 00 00 00       	jmp    109372 <kgfx_draw_character+0x10e>
    for(size_t j = 0; j < 16; j++){
  1092a0:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
  1092a7:	00 
  1092a8:	e9 b5 00 00 00       	jmp    109362 <kgfx_draw_character+0xfe>
      size_t char_index = j + i*16; 
  1092ad:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  1092b1:	48 c1 e0 04          	shl    rax,0x4
  1092b5:	48 89 c2             	mov    rdx,rax
  1092b8:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  1092bc:	48 01 d0             	add    rax,rdx
  1092bf:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
      if(character_data[char_index] > 0){
  1092c3:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  1092c7:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  1092cb:	48 01 d0             	add    rax,rdx
  1092ce:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  1092d1:	84 c0                	test   al,al
  1092d3:	0f 84 84 00 00 00    	je     10935d <kgfx_draw_character+0xf9>
        size_t fb_index = ((j+x_orign)*fb->depth) + ((i+y_origin)*fb->pitch);
  1092d9:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  1092dd:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  1092e1:	48 01 c2             	add    rdx,rax
  1092e4:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  1092e8:	0f b6 40 0c          	movzx  eax,BYTE PTR [rax+0xc]
  1092ec:	0f b6 c0             	movzx  eax,al
  1092ef:	48 0f af d0          	imul   rdx,rax
  1092f3:	48 8b 4d f8          	mov    rcx,QWORD PTR [rbp-0x8]
  1092f7:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  1092fb:	48 01 c1             	add    rcx,rax
  1092fe:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  109302:	8b 40 08             	mov    eax,DWORD PTR [rax+0x8]
  109305:	89 c0                	mov    eax,eax
  109307:	48 0f af c1          	imul   rax,rcx
  10930b:	48 01 d0             	add    rax,rdx
  10930e:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
        fb->buffer[fb_index + 0] = 0x00;
  109312:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  109316:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10931a:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10931e:	48 01 d0             	add    rax,rdx
  109321:	c6 00 00             	mov    BYTE PTR [rax],0x0
        fb->buffer[fb_index + 1] = character_data[char_index];
  109324:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  109328:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  10932c:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
  109330:	48 83 c2 01          	add    rdx,0x1
  109334:	48 01 c2             	add    rdx,rax
  109337:	48 8b 4d e8          	mov    rcx,QWORD PTR [rbp-0x18]
  10933b:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10933f:	48 01 c8             	add    rax,rcx
  109342:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  109345:	88 02                	mov    BYTE PTR [rdx],al
        fb->buffer[fb_index + 2] = 0x00;
  109347:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  10934b:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  10934f:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
  109353:	48 83 c2 02          	add    rdx,0x2
  109357:	48 01 d0             	add    rax,rdx
  10935a:	c6 00 00             	mov    BYTE PTR [rax],0x0
    for(size_t j = 0; j < 16; j++){
  10935d:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  109362:	48 83 7d f0 0f       	cmp    QWORD PTR [rbp-0x10],0xf
  109367:	0f 86 40 ff ff ff    	jbe    1092ad <kgfx_draw_character+0x49>
  for(size_t i = 0; i < 16; i++){
  10936d:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  109372:	48 83 7d f8 0f       	cmp    QWORD PTR [rbp-0x8],0xf
  109377:	0f 86 23 ff ff ff    	jbe    1092a0 <kgfx_draw_character+0x3c>
      }
    }
  }
}
  10937d:	90                   	nop
  10937e:	c9                   	leave  
  10937f:	c3                   	ret    

0000000000109380 <kgfx_clear_framebuffer>:
#endif

void kgfx_clear_framebuffer(Framebuffer *fb){
  109380:	55                   	push   rbp
  109381:	48 89 e5             	mov    rbp,rsp
  109384:	48 83 ec 60          	sub    rsp,0x60
  109388:	48 89 7d a8          	mov    QWORD PTR [rbp-0x58],rdi
  size_t step_count = (fb->width * fb->height * fb->depth) / 16;
  10938c:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  109390:	8b 10                	mov    edx,DWORD PTR [rax]
  109392:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  109396:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
  109399:	0f af d0             	imul   edx,eax
  10939c:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1093a0:	0f b6 40 0c          	movzx  eax,BYTE PTR [rax+0xc]
  1093a4:	0f b6 c0             	movzx  eax,al
  1093a7:	0f af c2             	imul   eax,edx
  1093aa:	c1 e8 04             	shr    eax,0x4
  1093ad:	89 c0                	mov    eax,eax
  1093af:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
  __m128i *write_ptr = (__m128i *)fb->buffer; 
  1093b3:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1093b7:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  1093bb:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

/* Create a vector of zeros.  */
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_si128 (void)
{
  return __extension__ (__m128i)(__v4si){ 0, 0, 0, 0 };
  1093bf:	66 0f ef c0          	pxor   xmm0,xmm0
  __m128i clear_value = _mm_setzero_si128();
  1093c3:	0f 29 45 d0          	movaps XMMWORD PTR [rbp-0x30],xmm0
  for(size_t i = 0; i < step_count; i++){
  1093c7:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
  1093ce:	00 
  1093cf:	eb 2e                	jmp    1093ff <kgfx_clear_framebuffer+0x7f>
  1093d1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  1093d5:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
  1093d9:	66 0f 6f 45 d0       	movdqa xmm0,XMMWORD PTR [rbp-0x30]
  1093de:	0f 29 45 b0          	movaps XMMWORD PTR [rbp-0x50],xmm0
  *__P = __B;
  1093e2:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  1093e6:	66 0f 6f 45 b0       	movdqa xmm0,XMMWORD PTR [rbp-0x50]
  1093eb:	0f 29 00             	movaps XMMWORD PTR [rax],xmm0
    _mm_store_si128(write_ptr, clear_value);
    write_ptr = (__m128i *)((uintptr_t)write_ptr + 16);
  1093ee:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  1093f2:	48 83 c0 10          	add    rax,0x10
  1093f6:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  for(size_t i = 0; i < step_count; i++){
  1093fa:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  1093ff:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109403:	48 3b 45 e8          	cmp    rax,QWORD PTR [rbp-0x18]
  109407:	72 c8                	jb     1093d1 <kgfx_clear_framebuffer+0x51>
  }
}
  109409:	90                   	nop
  10940a:	c9                   	leave  
  10940b:	c3                   	ret    

000000000010940c <vga_set_char>:
  }
}
#endif

static inline
void vga_set_char(char c, uint8_t color, int x, int y){
  10940c:	55                   	push   rbp
  10940d:	48 89 e5             	mov    rbp,rsp
  109410:	48 83 ec 20          	sub    rsp,0x20
  109414:	89 f0                	mov    eax,esi
  109416:	89 55 e4             	mov    DWORD PTR [rbp-0x1c],edx
  109419:	89 4d e0             	mov    DWORD PTR [rbp-0x20],ecx
  10941c:	40 88 7d ec          	mov    BYTE PTR [rbp-0x14],dil
  109420:	88 45 e8             	mov    BYTE PTR [rbp-0x18],al
  static const uint8_t VGA_TEXT_COLUMN_COUNT = 80;
	static const uint8_t VGA_TEXT_ROW_COUNT = 25;
	static uint8_t *VGA_TEXT_BUFFER = (uint8_t*)(0xB8000);
  size_t vga_index = ((y * VGA_TEXT_COLUMN_COUNT) + x) * 2;
  109423:	0f b6 05 08 ed ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffed08]        # 108132 <VGA_TEXT_COLUMN_COUNT.4123>
  10942a:	0f b6 c0             	movzx  eax,al
  10942d:	0f af 45 e0          	imul   eax,DWORD PTR [rbp-0x20]
  109431:	89 c2                	mov    edx,eax
  109433:	8b 45 e4             	mov    eax,DWORD PTR [rbp-0x1c]
  109436:	01 d0                	add    eax,edx
  109438:	01 c0                	add    eax,eax
  10943a:	48 98                	cdqe   
  10943c:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  VGA_TEXT_BUFFER[vga_index+0] = c;
  109440:	48 8b 15 09 44 00 00 	mov    rdx,QWORD PTR [rip+0x4409]        # 10d850 <VGA_TEXT_BUFFER.4125>
  109447:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10944b:	48 01 c2             	add    rdx,rax
  10944e:	0f b6 45 ec          	movzx  eax,BYTE PTR [rbp-0x14]
  109452:	88 02                	mov    BYTE PTR [rdx],al
  VGA_TEXT_BUFFER[vga_index+1] = color;
  109454:	48 8b 05 f5 43 00 00 	mov    rax,QWORD PTR [rip+0x43f5]        # 10d850 <VGA_TEXT_BUFFER.4125>
  10945b:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10945f:	48 83 c2 01          	add    rdx,0x1
  109463:	48 01 c2             	add    rdx,rax
  109466:	0f b6 45 e8          	movzx  eax,BYTE PTR [rbp-0x18]
  10946a:	88 02                	mov    BYTE PTR [rdx],al
}
  10946c:	90                   	nop
  10946d:	c9                   	leave  
  10946e:	c3                   	ret    

000000000010946f <draw_vga_text_terminal>:

static inline
void draw_vga_text_terminal(Circular_Log *log){
  10946f:	55                   	push   rbp
  109470:	48 89 e5             	mov    rbp,rsp
  109473:	48 83 ec 58          	sub    rsp,0x58
  109477:	48 89 7d a8          	mov    QWORD PTR [rbp-0x58],rdi
  static const uint8_t VGA_TEXT_COLUMN_COUNT = 80;
	static const uint8_t VGA_TEXT_ROW_COUNT = 25;
	static uint8_t *VGA_TEXT_BUFFER = (uint8_t*)(0xB8000);
  memset(VGA_TEXT_BUFFER, 0x00, VGA_TEXT_COLUMN_COUNT*VGA_TEXT_ROW_COUNT*2);
  10947b:	0f b6 05 ae ec ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffecae]        # 108130 <VGA_TEXT_COLUMN_COUNT.4130>
  109482:	0f b6 d0             	movzx  edx,al
  109485:	0f b6 05 a5 ec ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffeca5]        # 108131 <VGA_TEXT_ROW_COUNT.4131>
  10948c:	0f b6 c0             	movzx  eax,al
  10948f:	0f af c2             	imul   eax,edx
  109492:	01 c0                	add    eax,eax
  109494:	48 63 d0             	movsxd rdx,eax
  109497:	48 8b 05 aa 43 00 00 	mov    rax,QWORD PTR [rip+0x43aa]        # 10d848 <VGA_TEXT_BUFFER.4132>
  10949e:	be 00 00 00 00       	mov    esi,0x0
  1094a3:	48 89 c7             	mov    rdi,rax
  1094a6:	e8 55 fb ff ff       	call   109000 <__memset>

  size_t entries_to_draw = min((uint32_t)(VGA_TEXT_ROW_COUNT - 1), (uint32_t)log->current_entry_count);
  1094ab:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1094af:	48 8b 80 08 04 01 00 	mov    rax,QWORD PTR [rax+0x10408]
  1094b6:	89 c2                	mov    edx,eax
  1094b8:	0f b6 05 72 ec ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffec72]        # 108131 <VGA_TEXT_ROW_COUNT.4131>
  1094bf:	0f b6 c0             	movzx  eax,al
  1094c2:	83 e8 01             	sub    eax,0x1
  1094c5:	39 c2                	cmp    edx,eax
  1094c7:	0f 46 c2             	cmovbe eax,edx
  1094ca:	89 c0                	mov    eax,eax
  1094cc:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
  for(size_t i = 0; i < entries_to_draw; i++){
  1094d0:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  1094d7:	00 
  1094d8:	e9 bd 00 00 00       	jmp    10959a <draw_vga_text_terminal+0x12b>
    size_t entry_offset = entries_to_draw - i; 
  1094dd:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  1094e1:	48 2b 45 f8          	sub    rax,QWORD PTR [rbp-0x8]
  1094e5:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
    size_t entry_index = (log->entry_write_position - entry_offset - log->scroll_offset) % CIRCULAR_LOG_ENTRY_COUNT;
  1094e9:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1094ed:	48 8b 80 00 04 01 00 	mov    rax,QWORD PTR [rax+0x10400]
  1094f4:	48 2b 45 d8          	sub    rax,QWORD PTR [rbp-0x28]
  1094f8:	48 89 c2             	mov    rdx,rax
  1094fb:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1094ff:	48 8b 80 10 04 01 00 	mov    rax,QWORD PTR [rax+0x10410]
  109506:	48 29 c2             	sub    rdx,rax
  109509:	48 89 d0             	mov    rax,rdx
  10950c:	25 ff 00 00 00       	and    eax,0xff
  109511:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
    Circular_Log_Entry *entry = &log->entries[entry_index];  
  109515:	48 8b 55 d0          	mov    rdx,QWORD PTR [rbp-0x30]
  109519:	48 89 d0             	mov    rax,rdx
  10951c:	48 c1 e0 06          	shl    rax,0x6
  109520:	48 01 d0             	add    rax,rdx
  109523:	48 c1 e0 02          	shl    rax,0x2
  109527:	48 8b 55 a8          	mov    rdx,QWORD PTR [rbp-0x58]
  10952b:	48 01 d0             	add    rax,rdx
  10952e:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
    size_t chars_to_write = min(entry->length, VGA_TEXT_COLUMN_COUNT);
  109532:	0f b6 05 f7 eb ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffebf7]        # 108130 <VGA_TEXT_COLUMN_COUNT.4130>
  109539:	0f b6 d0             	movzx  edx,al
  10953c:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  109540:	8b 80 00 01 00 00    	mov    eax,DWORD PTR [rax+0x100]
  109546:	39 c2                	cmp    edx,eax
  109548:	0f 46 c2             	cmovbe eax,edx
  10954b:	89 c0                	mov    eax,eax
  10954d:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
    for(size_t j = 0; j < chars_to_write; j++){
  109551:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
  109558:	00 
  109559:	eb 30                	jmp    10958b <draw_vga_text_terminal+0x11c>
      vga_set_char(entry->message[j], VGAColor_GREEN, j, i);
  10955b:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10955f:	89 c1                	mov    ecx,eax
  109561:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109565:	89 c6                	mov    esi,eax
  109567:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  10956b:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10956f:	48 01 d0             	add    rax,rdx
  109572:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  109575:	0f be c0             	movsx  eax,al
  109578:	89 f2                	mov    edx,esi
  10957a:	be 02 00 00 00       	mov    esi,0x2
  10957f:	89 c7                	mov    edi,eax
  109581:	e8 86 fe ff ff       	call   10940c <vga_set_char>
    for(size_t j = 0; j < chars_to_write; j++){
  109586:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  10958b:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10958f:	48 3b 45 c0          	cmp    rax,QWORD PTR [rbp-0x40]
  109593:	72 c6                	jb     10955b <draw_vga_text_terminal+0xec>
  for(size_t i = 0; i < entries_to_draw; i++){
  109595:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10959a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10959e:	48 3b 45 e0          	cmp    rax,QWORD PTR [rbp-0x20]
  1095a2:	0f 82 35 ff ff ff    	jb     1094dd <draw_vga_text_terminal+0x6e>
    }
  }

  size_t input_buffer_to_write = min(VGA_TEXT_COLUMN_COUNT, log->input_buffer_count);
  1095a8:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1095ac:	48 8b 90 18 05 01 00 	mov    rdx,QWORD PTR [rax+0x10518]
  1095b3:	0f b6 05 76 eb ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffeb76]        # 108130 <VGA_TEXT_COLUMN_COUNT.4130>
  1095ba:	0f b6 c0             	movzx  eax,al
  1095bd:	48 39 c2             	cmp    rdx,rax
  1095c0:	48 0f 46 c2          	cmovbe rax,rdx
  1095c4:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  for(size_t i = 0; i < input_buffer_to_write; i++){
  1095c8:	48 c7 45 e8 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0
  1095cf:	00 
  1095d0:	eb 3f                	jmp    109611 <draw_vga_text_terminal+0x1a2>
    vga_set_char(log->input_buffer[i], VGAColor_RED, i, VGA_TEXT_ROW_COUNT - 1); 
  1095d2:	0f b6 05 58 eb ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffeb58]        # 108131 <VGA_TEXT_ROW_COUNT.4131>
  1095d9:	0f b6 c0             	movzx  eax,al
  1095dc:	8d 50 ff             	lea    edx,[rax-0x1]
  1095df:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  1095e3:	89 c6                	mov    esi,eax
  1095e5:	48 8b 4d a8          	mov    rcx,QWORD PTR [rbp-0x58]
  1095e9:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  1095ed:	48 01 c8             	add    rax,rcx
  1095f0:	48 05 18 04 01 00    	add    rax,0x10418
  1095f6:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  1095f9:	0f be c0             	movsx  eax,al
  1095fc:	89 d1                	mov    ecx,edx
  1095fe:	89 f2                	mov    edx,esi
  109600:	be 04 00 00 00       	mov    esi,0x4
  109605:	89 c7                	mov    edi,eax
  109607:	e8 00 fe ff ff       	call   10940c <vga_set_char>
  for(size_t i = 0; i < input_buffer_to_write; i++){
  10960c:	48 83 45 e8 01       	add    QWORD PTR [rbp-0x18],0x1
  109611:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  109615:	48 3b 45 b8          	cmp    rax,QWORD PTR [rbp-0x48]
  109619:	72 b7                	jb     1095d2 <draw_vga_text_terminal+0x163>
  } 
}
  10961b:	90                   	nop
  10961c:	c9                   	leave  
  10961d:	c3                   	ret    

000000000010961e <kgfx_draw_log_if_dirty>:
    VGA_TEXT_BUFFER[vga_index+1] = 0x00; 
  }
}
#endif

void kgfx_draw_log_if_dirty(Circular_Log *log){
  10961e:	55                   	push   rbp
  10961f:	48 89 e5             	mov    rbp,rsp
  109622:	48 83 ec 70          	sub    rsp,0x70
  109626:	48 89 7d 98          	mov    QWORD PTR [rbp-0x68],rdi
  if(log->is_dirty == false) return;
  10962a:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  10962e:	0f b6 80 24 05 01 00 	movzx  eax,BYTE PTR [rax+0x10524]
  109635:	83 f0 01             	xor    eax,0x1
  109638:	84 c0                	test   al,al
  10963a:	0f 85 fd 01 00 00    	jne    10983d <kgfx_draw_log_if_dirty+0x21f>
  log->is_dirty = false;
  109640:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  109644:	c6 80 24 05 01 00 00 	mov    BYTE PTR [rax+0x10524],0x0

  if(globals.framebuffer.buffer != 0){
  10964b:	48 8b 05 06 51 01 00 	mov    rax,QWORD PTR [rip+0x15106]        # 11e758 <globals+0x10758>
  109652:	48 85 c0             	test   rax,rax
  109655:	0f 84 d4 01 00 00    	je     10982f <kgfx_draw_log_if_dirty+0x211>
    static const uint32_t FONT_SIZE = 16;
    static const uint32_t ROW_SPACING = 0;
    static const uint32_t CHARACTER_SPACING = 10;
    Framebuffer *fb = &globals.framebuffer;
  10965b:	48 c7 45 e0 48 e7 11 	mov    QWORD PTR [rbp-0x20],0x11e748
  109662:	00 
    kgfx_clear_framebuffer(fb);
  109663:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  109667:	48 89 c7             	mov    rdi,rax
  10966a:	e8 11 fd ff ff       	call   109380 <kgfx_clear_framebuffer>
    const uint32_t total_column_count = fb->width / CHARACTER_SPACING;
  10966f:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  109673:	8b 00                	mov    eax,DWORD PTR [rax]
  109675:	8b 35 a9 ea ff ff    	mov    esi,DWORD PTR [rip+0xffffffffffffeaa9]        # 108124 <CHARACTER_SPACING.4156>
  10967b:	ba 00 00 00 00       	mov    edx,0x0
  109680:	f7 f6                	div    esi
  109682:	89 45 dc             	mov    DWORD PTR [rbp-0x24],eax
    const uint32_t max_row_count = fb->height / (FONT_SIZE + ROW_SPACING);
  109685:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  109689:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
  10968c:	8b 0d 96 ea ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffffea96]        # 108128 <FONT_SIZE.4154>
  109692:	8b 15 94 ea ff ff    	mov    edx,DWORD PTR [rip+0xffffffffffffea94]        # 10812c <ROW_SPACING.4155>
  109698:	8d 3c 0a             	lea    edi,[rdx+rcx*1]
  10969b:	ba 00 00 00 00       	mov    edx,0x0
  1096a0:	f7 f7                	div    edi
  1096a2:	89 45 d8             	mov    DWORD PTR [rbp-0x28],eax
    const uint32_t total_lines_to_draw = min(log->current_entry_count, max_row_count - 1); 
  1096a5:	8b 45 d8             	mov    eax,DWORD PTR [rbp-0x28]
  1096a8:	83 e8 01             	sub    eax,0x1
  1096ab:	89 c2                	mov    edx,eax
  1096ad:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  1096b1:	48 8b 80 08 04 01 00 	mov    rax,QWORD PTR [rax+0x10408]
  1096b8:	48 39 c2             	cmp    rdx,rax
  1096bb:	48 0f 46 c2          	cmovbe rax,rdx
  1096bf:	89 45 d4             	mov    DWORD PTR [rbp-0x2c],eax
    for(size_t i = 0; i < total_lines_to_draw; i++){
  1096c2:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  1096c9:	00 
  1096ca:	e9 ce 00 00 00       	jmp    10979d <kgfx_draw_log_if_dirty+0x17f>
      size_t entry_offset = total_lines_to_draw - i; 
  1096cf:	8b 45 d4             	mov    eax,DWORD PTR [rbp-0x2c]
  1096d2:	48 2b 45 f8          	sub    rax,QWORD PTR [rbp-0x8]
  1096d6:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
      size_t entry_index = (log->entry_write_position - entry_offset - log->scroll_offset) % CIRCULAR_LOG_ENTRY_COUNT;
  1096da:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  1096de:	48 8b 80 00 04 01 00 	mov    rax,QWORD PTR [rax+0x10400]
  1096e5:	48 2b 45 c8          	sub    rax,QWORD PTR [rbp-0x38]
  1096e9:	48 89 c2             	mov    rdx,rax
  1096ec:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  1096f0:	48 8b 80 10 04 01 00 	mov    rax,QWORD PTR [rax+0x10410]
  1096f7:	48 29 c2             	sub    rdx,rax
  1096fa:	48 89 d0             	mov    rax,rdx
  1096fd:	25 ff 00 00 00       	and    eax,0xff
  109702:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
      Circular_Log_Entry *entry = &log->entries[entry_index];  
  109706:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  10970a:	48 89 d0             	mov    rax,rdx
  10970d:	48 c1 e0 06          	shl    rax,0x6
  109711:	48 01 d0             	add    rax,rdx
  109714:	48 c1 e0 02          	shl    rax,0x2
  109718:	48 8b 55 98          	mov    rdx,QWORD PTR [rbp-0x68]
  10971c:	48 01 d0             	add    rax,rdx
  10971f:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
      size_t chars_to_write = min(entry->length, total_column_count);
  109723:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  109727:	8b 90 00 01 00 00    	mov    edx,DWORD PTR [rax+0x100]
  10972d:	8b 45 dc             	mov    eax,DWORD PTR [rbp-0x24]
  109730:	39 c2                	cmp    edx,eax
  109732:	0f 46 c2             	cmovbe eax,edx
  109735:	89 c0                	mov    eax,eax
  109737:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
      for(size_t j = 0; j < chars_to_write; j++){
  10973b:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
  109742:	00 
  109743:	eb 49                	jmp    10978e <kgfx_draw_log_if_dirty+0x170>
        kgfx_draw_character(entry->message[j], j*CHARACTER_SPACING, i*(FONT_SIZE + ROW_SPACING), fb);
  109745:	8b 15 dd e9 ff ff    	mov    edx,DWORD PTR [rip+0xffffffffffffe9dd]        # 108128 <FONT_SIZE.4154>
  10974b:	8b 05 db e9 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe9db]        # 10812c <ROW_SPACING.4155>
  109751:	01 d0                	add    eax,edx
  109753:	89 c0                	mov    eax,eax
  109755:	48 0f af 45 f8       	imul   rax,QWORD PTR [rbp-0x8]
  10975a:	48 89 c2             	mov    rdx,rax
  10975d:	8b 05 c1 e9 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe9c1]        # 108124 <CHARACTER_SPACING.4156>
  109763:	89 c0                	mov    eax,eax
  109765:	48 0f af 45 f0       	imul   rax,QWORD PTR [rbp-0x10]
  10976a:	48 89 c6             	mov    rsi,rax
  10976d:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  109771:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109775:	48 01 c8             	add    rax,rcx
  109778:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10977b:	0f be c0             	movsx  eax,al
  10977e:	48 8b 4d e0          	mov    rcx,QWORD PTR [rbp-0x20]
  109782:	89 c7                	mov    edi,eax
  109784:	e8 db fa ff ff       	call   109264 <kgfx_draw_character>
      for(size_t j = 0; j < chars_to_write; j++){
  109789:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  10978e:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109792:	48 3b 45 b0          	cmp    rax,QWORD PTR [rbp-0x50]
  109796:	72 ad                	jb     109745 <kgfx_draw_log_if_dirty+0x127>
    for(size_t i = 0; i < total_lines_to_draw; i++){
  109798:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10979d:	8b 45 d4             	mov    eax,DWORD PTR [rbp-0x2c]
  1097a0:	48 3b 45 f8          	cmp    rax,QWORD PTR [rbp-0x8]
  1097a4:	0f 87 25 ff ff ff    	ja     1096cf <kgfx_draw_log_if_dirty+0xb1>
      }
    }

    size_t input_buffer_to_write = min(total_column_count, log->input_buffer_count);
  1097aa:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  1097ae:	48 8b 90 18 05 01 00 	mov    rdx,QWORD PTR [rax+0x10518]
  1097b5:	8b 45 dc             	mov    eax,DWORD PTR [rbp-0x24]
  1097b8:	48 39 c2             	cmp    rdx,rax
  1097bb:	48 0f 46 c2          	cmovbe rax,rdx
  1097bf:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
    for(size_t i = 0; i < input_buffer_to_write; i++){
  1097c3:	48 c7 45 e8 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0
  1097ca:	00 
  1097cb:	eb 56                	jmp    109823 <kgfx_draw_log_if_dirty+0x205>
      kgfx_draw_character(log->input_buffer[i], i*CHARACTER_SPACING, (FONT_SIZE+ROW_SPACING)*(max_row_count - 1), fb); 
  1097cd:	8b 15 55 e9 ff ff    	mov    edx,DWORD PTR [rip+0xffffffffffffe955]        # 108128 <FONT_SIZE.4154>
  1097d3:	8b 05 53 e9 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe953]        # 10812c <ROW_SPACING.4155>
  1097d9:	01 c2                	add    edx,eax
  1097db:	8b 45 d8             	mov    eax,DWORD PTR [rbp-0x28]
  1097de:	83 e8 01             	sub    eax,0x1
  1097e1:	0f af c2             	imul   eax,edx
  1097e4:	89 c7                	mov    edi,eax
  1097e6:	8b 05 38 e9 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe938]        # 108124 <CHARACTER_SPACING.4156>
  1097ec:	89 c0                	mov    eax,eax
  1097ee:	48 0f af 45 e8       	imul   rax,QWORD PTR [rbp-0x18]
  1097f3:	48 89 c6             	mov    rsi,rax
  1097f6:	48 8b 55 98          	mov    rdx,QWORD PTR [rbp-0x68]
  1097fa:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  1097fe:	48 01 d0             	add    rax,rdx
  109801:	48 05 18 04 01 00    	add    rax,0x10418
  109807:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10980a:	0f be c0             	movsx  eax,al
  10980d:	48 8b 55 e0          	mov    rdx,QWORD PTR [rbp-0x20]
  109811:	48 89 d1             	mov    rcx,rdx
  109814:	48 89 fa             	mov    rdx,rdi
  109817:	89 c7                	mov    edi,eax
  109819:	e8 46 fa ff ff       	call   109264 <kgfx_draw_character>
    for(size_t i = 0; i < input_buffer_to_write; i++){
  10981e:	48 83 45 e8 01       	add    QWORD PTR [rbp-0x18],0x1
  109823:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  109827:	48 3b 45 a8          	cmp    rax,QWORD PTR [rbp-0x58]
  10982b:	72 a0                	jb     1097cd <kgfx_draw_log_if_dirty+0x1af>
  10982d:	eb 0f                	jmp    10983e <kgfx_draw_log_if_dirty+0x220>
    }

  } else {
    draw_vga_text_terminal(log);
  10982f:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  109833:	48 89 c7             	mov    rdi,rax
  109836:	e8 34 fc ff ff       	call   10946f <draw_vga_text_terminal>
  10983b:	eb 01                	jmp    10983e <kgfx_draw_log_if_dirty+0x220>
  if(log->is_dirty == false) return;
  10983d:	90                   	nop
  }
  10983e:	c9                   	leave  
  10983f:	c3                   	ret    

0000000000109840 <parse_root_system_descriptor>:
//=======================================

static inline
void acpi_parse_rsdt(ACPI_SDT_Header *rsdt, System_Info *info);

void parse_root_system_descriptor(const RSDP_Descriptor_1 *rsdp, System_Info *sys) {
  109840:	55                   	push   rbp
  109841:	48 89 e5             	mov    rbp,rsp
  109844:	48 81 ec 90 00 00 00 	sub    rsp,0x90
  10984b:	48 89 bd 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],rdi
  109852:	48 89 b5 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],rsi
	if((rsdp->signature[0] == 'R' && rsdp->signature[1] == 'S' &&
  109859:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  109860:	0f b6 00             	movzx  eax,BYTE PTR [rax]
      rsdp->signature[2] == 'D' && rsdp->signature[3] == ' ' &&
      rsdp->signature[4] == 'P' && rsdp->signature[5] == 'T' &&
      rsdp->signature[6] == 'R' && rsdp->signature[7] == ' ') == 0) {
  109863:	3c 52                	cmp    al,0x52
  109865:	75 70                	jne    1098d7 <parse_root_system_descriptor+0x97>
	if((rsdp->signature[0] == 'R' && rsdp->signature[1] == 'S' &&
  109867:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  10986e:	0f b6 40 01          	movzx  eax,BYTE PTR [rax+0x1]
  109872:	3c 53                	cmp    al,0x53
  109874:	75 61                	jne    1098d7 <parse_root_system_descriptor+0x97>
      rsdp->signature[2] == 'D' && rsdp->signature[3] == ' ' &&
  109876:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  10987d:	0f b6 40 02          	movzx  eax,BYTE PTR [rax+0x2]
	if((rsdp->signature[0] == 'R' && rsdp->signature[1] == 'S' &&
  109881:	3c 44                	cmp    al,0x44
  109883:	75 52                	jne    1098d7 <parse_root_system_descriptor+0x97>
      rsdp->signature[2] == 'D' && rsdp->signature[3] == ' ' &&
  109885:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  10988c:	0f b6 40 03          	movzx  eax,BYTE PTR [rax+0x3]
  109890:	3c 20                	cmp    al,0x20
  109892:	75 43                	jne    1098d7 <parse_root_system_descriptor+0x97>
      rsdp->signature[4] == 'P' && rsdp->signature[5] == 'T' &&
  109894:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  10989b:	0f b6 40 04          	movzx  eax,BYTE PTR [rax+0x4]
      rsdp->signature[2] == 'D' && rsdp->signature[3] == ' ' &&
  10989f:	3c 50                	cmp    al,0x50
  1098a1:	75 34                	jne    1098d7 <parse_root_system_descriptor+0x97>
      rsdp->signature[4] == 'P' && rsdp->signature[5] == 'T' &&
  1098a3:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  1098aa:	0f b6 40 05          	movzx  eax,BYTE PTR [rax+0x5]
  1098ae:	3c 54                	cmp    al,0x54
  1098b0:	75 25                	jne    1098d7 <parse_root_system_descriptor+0x97>
      rsdp->signature[6] == 'R' && rsdp->signature[7] == ' ') == 0) {
  1098b2:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  1098b9:	0f b6 40 06          	movzx  eax,BYTE PTR [rax+0x6]
      rsdp->signature[4] == 'P' && rsdp->signature[5] == 'T' &&
  1098bd:	3c 52                	cmp    al,0x52
  1098bf:	75 16                	jne    1098d7 <parse_root_system_descriptor+0x97>
      rsdp->signature[6] == 'R' && rsdp->signature[7] == ' ') == 0) {
  1098c1:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  1098c8:	0f b6 40 07          	movzx  eax,BYTE PTR [rax+0x7]
  1098cc:	3c 20                	cmp    al,0x20
  1098ce:	75 07                	jne    1098d7 <parse_root_system_descriptor+0x97>
  1098d0:	b8 01 00 00 00       	mov    eax,0x1
  1098d5:	eb 05                	jmp    1098dc <parse_root_system_descriptor+0x9c>
  1098d7:	b8 00 00 00 00       	mov    eax,0x0
	if((rsdp->signature[0] == 'R' && rsdp->signature[1] == 'S' &&
  1098dc:	85 c0                	test   eax,eax
  1098de:	75 19                	jne    1098f9 <parse_root_system_descriptor+0xb9>
    klog_error("RSDP is invalid!");
  1098e0:	be 40 60 10 00       	mov    esi,0x106040
  1098e5:	bf 00 e0 10 00       	mov    edi,0x10e000
  1098ea:	b8 00 00 00 00       	mov    eax,0x0
  1098ef:	e8 73 33 00 00       	call   10cc67 <klog_write_fmt>
    return;
  1098f4:	e9 51 02 00 00       	jmp    109b4a <parse_root_system_descriptor+0x30a>
  } 

  //TODO(Torin) This should be a temporary page!
  uintptr_t virtual_address = 0x0C600000;
  1098f9:	48 c7 45 e8 00 00 60 	mov    QWORD PTR [rbp-0x18],0xc600000
  109900:	0c 
  uintptr_t page_offset = kmem_map_unaligned_physical_to_aligned_virtual_2MB(rsdp->rsdt_address, virtual_address); 
  109901:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  109908:	8b 40 10             	mov    eax,DWORD PTR [rax+0x10]
  10990b:	89 c2                	mov    edx,eax
  10990d:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  109911:	48 89 c6             	mov    rsi,rax
  109914:	48 89 d7             	mov    rdi,rdx
  109917:	e8 a9 12 00 00       	call   10abc5 <kmem_map_unaligned_physical_to_aligned_virtual_2MB>
  10991c:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
  ACPI_SDT_Header *rsdt = (ACPI_SDT_Header *)(virtual_address + page_offset);
  109920:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  109924:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  109928:	48 01 d0             	add    rax,rdx
  10992b:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
  uint32_t entry_count = (rsdt->length - sizeof(ACPI_SDT_Header)) / 4;
  10992f:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109933:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
  109936:	89 c0                	mov    eax,eax
  109938:	48 83 e8 24          	sub    rax,0x24
  10993c:	48 c1 e8 02          	shr    rax,0x2
  109940:	89 45 d4             	mov    DWORD PTR [rbp-0x2c],eax
  uint32_t *entries = (uint32_t *)(rsdt + 1);
  109943:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109947:	48 83 c0 24          	add    rax,0x24
  10994b:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
  for(size_t i = 0; i < entry_count; i++){
  10994f:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  109956:	00 
  109957:	e9 e1 01 00 00       	jmp    109b3d <parse_root_system_descriptor+0x2fd>
    uintptr_t header_physical_addr = (uintptr_t)entries[i];
  10995c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109960:	48 8d 14 85 00 00 00 	lea    rdx,[rax*4+0x0]
  109967:	00 
  109968:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  10996c:	48 01 d0             	add    rax,rdx
  10996f:	8b 00                	mov    eax,DWORD PTR [rax]
  109971:	89 c0                	mov    eax,eax
  109973:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
    int64_t physical_offset = header_physical_addr - rsdp->rsdt_address;
  109977:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  10997e:	8b 40 10             	mov    eax,DWORD PTR [rax+0x10]
  109981:	89 c2                	mov    edx,eax
  109983:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  109987:	48 29 d0             	sub    rax,rdx
  10998a:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
    uintptr_t entry_address = virtual_address + page_offset + physical_offset;
  10998e:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  109992:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  109996:	48 01 c2             	add    rdx,rax
  109999:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10999d:	48 01 d0             	add    rax,rdx
  1099a0:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
    ACPI_SDT_Header *header = (ACPI_SDT_Header *)entry_address;
  1099a4:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  1099a8:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax

    static const uint32_t ACPI_MADT_SIGNATURE = ('C' << 24) | ('I' << 16) | ('P' << 8) | ('A');
    static const uint32_t ACPI_MCFG_SIGNATURE = ('G' << 24) | ('F' << 16) | ('C' << 8) | ('M');
    
    if(header->signature == ACPI_MADT_SIGNATURE) {
  1099ac:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1099b0:	8b 10                	mov    edx,DWORD PTR [rax]
  1099b2:	8b 05 7c e7 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe77c]        # 108134 <ACPI_MADT_SIGNATURE.4220>
  1099b8:	39 c2                	cmp    edx,eax
  1099ba:	0f 85 54 01 00 00    	jne    109b14 <parse_root_system_descriptor+0x2d4>
      typedef struct {
        ACPI_SDT_Header header;
        uint32_t local_controler_address;
        uint32_t flags;
      } __attribute__((packed)) MADT;
      MADT *madt = (MADT *)header;
  1099c0:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1099c4:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
      typedef struct {
        uint8_t entry_type;
        uint8_t entry_length;
      } MADT_Entry_Header;

      sys->lapic_physical_address = madt->local_controler_address;
  1099c8:	48 8b 45 a0          	mov    rax,QWORD PTR [rbp-0x60]
  1099cc:	8b 40 24             	mov    eax,DWORD PTR [rax+0x24]
  1099cf:	89 c2                	mov    edx,eax
  1099d1:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  1099d8:	48 89 10             	mov    QWORD PTR [rax],rdx

      MADT_Entry_Header *madt_entry = (MADT_Entry_Header *)(madt + 1);
  1099db:	48 8b 45 a0          	mov    rax,QWORD PTR [rbp-0x60]
  1099df:	48 83 c0 2c          	add    rax,0x2c
  1099e3:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
      while(((uintptr_t)madt_entry - (uintptr_t)madt) < madt->header.length) 
  1099e7:	e9 09 01 00 00       	jmp    109af5 <parse_root_system_descriptor+0x2b5>
          PROCESSOR_LOCAL_APIC = 0,
          IO_APIC = 1,
          INTERRUPT_SOURCE_OVERRIDE = 2,
        };
        
        switch(madt_entry->entry_type){
  1099ec:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  1099f0:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  1099f3:	0f b6 c0             	movzx  eax,al
  1099f6:	83 f8 01             	cmp    eax,0x1
  1099f9:	0f 84 9b 00 00 00    	je     109a9a <parse_root_system_descriptor+0x25a>
  1099ff:	83 f8 02             	cmp    eax,0x2
  109a02:	0f 84 d6 00 00 00    	je     109ade <parse_root_system_descriptor+0x29e>
  109a08:	85 c0                	test   eax,eax
  109a0a:	0f 85 cf 00 00 00    	jne    109adf <parse_root_system_descriptor+0x29f>
          case PROCESSOR_LOCAL_APIC: {
            MADT_Entry_Processor_Local_APIC * local_apic = (MADT_Entry_Processor_Local_APIC *)madt_entry; 
  109a10:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109a14:	48 89 45 98          	mov    QWORD PTR [rbp-0x68],rax
            bool is_apic_enabled = local_apic->flags & 0b1;
  109a18:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  109a1c:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
  109a1f:	83 e0 01             	and    eax,0x1
  109a22:	85 c0                	test   eax,eax
  109a24:	0f 95 c0             	setne  al
  109a27:	88 45 97             	mov    BYTE PTR [rbp-0x69],al
            //klog_debug("[acpi] lapic: processor_id: %u apic_id: %u is %s", local_apic->processor_id, local_apic->apic_id, is_apic_enabled ? "enabled" : "disabled");

            if(sys->cpu_count < ARRAY_COUNT(sys->cpu_lapic_ids)){
  109a2a:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  109a31:	8b 80 a8 00 00 00    	mov    eax,DWORD PTR [rax+0xa8]
  109a37:	83 f8 1f             	cmp    eax,0x1f
  109a3a:	77 48                	ja     109a84 <parse_root_system_descriptor+0x244>
              sys->cpu_lapic_ids[sys->cpu_count] = local_apic->apic_id;
  109a3c:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  109a43:	8b 88 a8 00 00 00    	mov    ecx,DWORD PTR [rax+0xa8]
  109a49:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  109a4d:	0f b6 40 03          	movzx  eax,BYTE PTR [rax+0x3]
  109a51:	0f b6 d0             	movzx  edx,al
  109a54:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  109a5b:	89 c9                	mov    ecx,ecx
  109a5d:	48 83 c1 08          	add    rcx,0x8
  109a61:	89 54 88 08          	mov    DWORD PTR [rax+rcx*4+0x8],edx
              sys->cpu_count++;
  109a65:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  109a6c:	8b 80 a8 00 00 00    	mov    eax,DWORD PTR [rax+0xa8]
  109a72:	8d 50 01             	lea    edx,[rax+0x1]
  109a75:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  109a7c:	89 90 a8 00 00 00    	mov    DWORD PTR [rax+0xa8],edx
            } else {
              klog_warning("only 32 cpus are currently supported!");
            }
          } break;
  109a82:	eb 5b                	jmp    109adf <parse_root_system_descriptor+0x29f>
              klog_warning("only 32 cpus are currently supported!");
  109a84:	be 58 60 10 00       	mov    esi,0x106058
  109a89:	bf 00 e0 10 00       	mov    edi,0x10e000
  109a8e:	b8 00 00 00 00       	mov    eax,0x0
  109a93:	e8 cf 31 00 00       	call   10cc67 <klog_write_fmt>
          } break;
  109a98:	eb 45                	jmp    109adf <parse_root_system_descriptor+0x29f>
              uint32_t io_apic_address;
              uint32_t global_system_interrupt_base;
            } MADT_Entry_IO_APIC;

            
            MADT_Entry_IO_APIC *ioapic = (MADT_Entry_IO_APIC *)madt_entry;
  109a9a:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109a9e:	48 89 45 88          	mov    QWORD PTR [rbp-0x78],rax
            //klog_info("[acpi] ioapic id: %u", (uint32_t)ioapic->io_apic_id);
            //klog_info("[acpi] ioapic physical address: %u", ioapic->io_apic_address);

            if(sys->ioapic_physical_address != 0){
  109aa2:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  109aa9:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  109aad:	48 85 c0             	test   rax,rax
  109ab0:	74 16                	je     109ac8 <parse_root_system_descriptor+0x288>
              klog_warning("[acpi] system contains multiple ioapics");
  109ab2:	be 80 60 10 00       	mov    esi,0x106080
  109ab7:	bf 00 e0 10 00       	mov    edi,0x10e000
  109abc:	b8 00 00 00 00       	mov    eax,0x0
  109ac1:	e8 a1 31 00 00       	call   10cc67 <klog_write_fmt>
            } else {
              sys->ioapic_physical_address = ioapic->io_apic_address;
            }


          }break;
  109ac6:	eb 17                	jmp    109adf <parse_root_system_descriptor+0x29f>
              sys->ioapic_physical_address = ioapic->io_apic_address;
  109ac8:	48 8b 45 88          	mov    rax,QWORD PTR [rbp-0x78]
  109acc:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
  109acf:	89 c2                	mov    edx,eax
  109ad1:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  109ad8:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
          }break;
  109adc:	eb 01                	jmp    109adf <parse_root_system_descriptor+0x29f>
          case INTERRUPT_SOURCE_OVERRIDE:{
          }break;
  109ade:	90                   	nop
        }

        madt_entry = (MADT_Entry_Header *)((uintptr_t)madt_entry + madt_entry->entry_length); 
  109adf:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109ae3:	0f b6 40 01          	movzx  eax,BYTE PTR [rax+0x1]
  109ae7:	0f b6 d0             	movzx  edx,al
  109aea:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109aee:	48 01 d0             	add    rax,rdx
  109af1:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
      while(((uintptr_t)madt_entry - (uintptr_t)madt) < madt->header.length) 
  109af5:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  109af9:	48 8b 45 a0          	mov    rax,QWORD PTR [rbp-0x60]
  109afd:	48 29 c2             	sub    rdx,rax
  109b00:	48 8b 45 a0          	mov    rax,QWORD PTR [rbp-0x60]
  109b04:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
  109b07:	89 c0                	mov    eax,eax
  109b09:	48 39 c2             	cmp    rdx,rax
  109b0c:	0f 82 da fe ff ff    	jb     1099ec <parse_root_system_descriptor+0x1ac>
  109b12:	eb 24                	jmp    109b38 <parse_root_system_descriptor+0x2f8>
      }
    } 

    else if (header->signature == ACPI_MCFG_SIGNATURE){
  109b14:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  109b18:	8b 10                	mov    edx,DWORD PTR [rax]
  109b1a:	8b 05 18 e6 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe618]        # 108138 <ACPI_MCFG_SIGNATURE.4221>
  109b20:	39 c2                	cmp    edx,eax
  109b22:	75 14                	jne    109b38 <parse_root_system_descriptor+0x2f8>
      klog_debug("found MCFG ACPI table");
  109b24:	be a8 60 10 00       	mov    esi,0x1060a8
  109b29:	bf 00 e0 10 00       	mov    edi,0x10e000
  109b2e:	b8 00 00 00 00       	mov    eax,0x0
  109b33:	e8 2f 31 00 00       	call   10cc67 <klog_write_fmt>
  for(size_t i = 0; i < entry_count; i++){
  109b38:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  109b3d:	8b 45 d4             	mov    eax,DWORD PTR [rbp-0x2c]
  109b40:	48 3b 45 f8          	cmp    rax,QWORD PTR [rbp-0x8]
  109b44:	0f 87 12 fe ff ff    	ja     10995c <parse_root_system_descriptor+0x11c>
    }


  }  
}
  109b4a:	c9                   	leave  
  109b4b:	c3                   	ret    

0000000000109b4c <ioapic_write_register>:
typedef struct IOAPIC_IRQR_LOW_STRUCT IOAPIC_IRQR_LOW;
typedef struct IOAPIC_IRQR_HIGH_STRUCT IOAPIC_IRQR_HIGH;


static inline
void ioapic_write_register(const uintptr_t ioapic_base, const uint8_t offset, const uint32_t value){
  109b4c:	55                   	push   rbp
  109b4d:	48 89 e5             	mov    rbp,rsp
  109b50:	48 83 ec 20          	sub    rsp,0x20
  109b54:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  109b58:	89 f0                	mov    eax,esi
  109b5a:	89 55 e0             	mov    DWORD PTR [rbp-0x20],edx
  109b5d:	88 45 e4             	mov    BYTE PTR [rbp-0x1c],al
  uint32_t volatile *ioapic = (uint32_t volatile *)ioapic_base;
  109b60:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  109b64:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  ioapic[0] = offset;
  109b68:	0f b6 55 e4          	movzx  edx,BYTE PTR [rbp-0x1c]
  109b6c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109b70:	89 10                	mov    DWORD PTR [rax],edx
  ioapic[4] = value;
  109b72:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109b76:	48 8d 50 10          	lea    rdx,[rax+0x10]
  109b7a:	8b 45 e0             	mov    eax,DWORD PTR [rbp-0x20]
  109b7d:	89 02                	mov    DWORD PTR [rdx],eax
}
  109b7f:	90                   	nop
  109b80:	c9                   	leave  
  109b81:	c3                   	ret    

0000000000109b82 <ioapic_read_register>:

static inline
uint32_t ioapic_read_register(const uintptr_t ioapic_base, const uint8_t offset){
  109b82:	55                   	push   rbp
  109b83:	48 89 e5             	mov    rbp,rsp
  109b86:	48 83 ec 20          	sub    rsp,0x20
  109b8a:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  109b8e:	89 f0                	mov    eax,esi
  109b90:	88 45 e4             	mov    BYTE PTR [rbp-0x1c],al
  uint32_t volatile *ioapic = (uint32_t volatile*)ioapic_base;
  109b93:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  109b97:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  ioapic[0] = offset;
  109b9b:	0f b6 55 e4          	movzx  edx,BYTE PTR [rbp-0x1c]
  109b9f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109ba3:	89 10                	mov    DWORD PTR [rax],edx
  return ioapic[4];
  109ba5:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109ba9:	48 83 c0 10          	add    rax,0x10
  109bad:	8b 00                	mov    eax,DWORD PTR [rax]
}
  109baf:	c9                   	leave  
  109bb0:	c3                   	ret    

0000000000109bb1 <lapic_write_register>:

static inline
void lapic_write_register(uintptr_t lapic_base, uintptr_t register_offset, uint32_t value){
  109bb1:	55                   	push   rbp
  109bb2:	48 89 e5             	mov    rbp,rsp
  109bb5:	48 83 ec 28          	sub    rsp,0x28
  109bb9:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  109bbd:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  109bc1:	89 55 dc             	mov    DWORD PTR [rbp-0x24],edx
  uint32_t volatile *lapic = (uint32_t volatile *)(lapic_base + register_offset);
  109bc4:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  109bc8:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  109bcc:	48 01 d0             	add    rax,rdx
  109bcf:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  lapic[0] = value;
  109bd3:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109bd7:	8b 55 dc             	mov    edx,DWORD PTR [rbp-0x24]
  109bda:	89 10                	mov    DWORD PTR [rax],edx
}
  109bdc:	90                   	nop
  109bdd:	c9                   	leave  
  109bde:	c3                   	ret    

0000000000109bdf <ioapic_initalize>:

static void
ioapic_initalize(uintptr_t ioapic_register_base) {
  109bdf:	55                   	push   rbp
  109be0:	48 89 e5             	mov    rbp,rsp
  109be3:	48 83 ec 28          	sub    rsp,0x28
  109be7:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  asm volatile("cli");
  109beb:	fa                   	cli    
  static const uint8_t DELIVERY_MODE_FIXED = 0x00;
  //NOTE(Torin) Keyboard
  IOAPIC_IRQR_LOW low = {};
  109bec:	c7 45 f0 00 00 00 00 	mov    DWORD PTR [rbp-0x10],0x0
  IOAPIC_IRQR_HIGH high = {};
  109bf3:	c7 45 e0 00 00 00 00 	mov    DWORD PTR [rbp-0x20],0x0
  low.vector = 0x21;
  109bfa:	c6 45 f0 21          	mov    BYTE PTR [rbp-0x10],0x21
  ioapic_write_register(ioapic_register_base, 0x12, low.packed);
  109bfe:	8b 55 f0             	mov    edx,DWORD PTR [rbp-0x10]
  109c01:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109c05:	be 12 00 00 00       	mov    esi,0x12
  109c0a:	48 89 c7             	mov    rdi,rax
  109c0d:	e8 3a ff ff ff       	call   109b4c <ioapic_write_register>
  ioapic_write_register(ioapic_register_base, 0x13, high.packed);
  109c12:	8b 55 e0             	mov    edx,DWORD PTR [rbp-0x20]
  109c15:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109c19:	be 13 00 00 00       	mov    esi,0x13
  109c1e:	48 89 c7             	mov    rdi,rax
  109c21:	e8 26 ff ff ff       	call   109b4c <ioapic_write_register>
  asm volatile("sti");
  109c26:	fb                   	sti    
}
  109c27:	90                   	nop
  109c28:	c9                   	leave  
  109c29:	c3                   	ret    

0000000000109c2a <lapic_initalize>:

static void
lapic_initalize(uintptr_t apic_register_base) {
  109c2a:	55                   	push   rbp
  109c2b:	48 89 e5             	mov    rbp,rsp
  109c2e:	48 83 ec 08          	sub    rsp,0x8
  109c32:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
	asm volatile ("cli");
  109c36:	fa                   	cli    
  //enable it fully using the other legacy routine.  Should simplify code
  //and keep everything nice an compact since we will never support a cpu
  //that does not have an APIC
  static const uint8_t PIC1_DATA_PORT = 0x21;
  static const uint8_t PIC2_DATA_PORT = 0xA1;
  write_port_uint8(PIC1_DATA_PORT, 0b11111111);
  109c37:	0f b6 05 ff e4 ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffe4ff]        # 10813d <PIC1_DATA_PORT.4334>
  109c3e:	0f b6 c0             	movzx  eax,al
  109c41:	be ff 00 00 00       	mov    esi,0xff
  109c46:	89 c7                	mov    edi,eax
  109c48:	e8 bc f5 ff ff       	call   109209 <write_port_uint8>
  write_port_uint8(PIC2_DATA_PORT, 0b11111111);
  109c4d:	0f b6 05 ea e4 ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffe4ea]        # 10813e <PIC2_DATA_PORT.4335>
  109c54:	0f b6 c0             	movzx  eax,al
  109c57:	be ff 00 00 00       	mov    esi,0xff
  109c5c:	89 c7                	mov    edi,eax
  109c5e:	e8 a6 f5 ff ff       	call   109209 <write_port_uint8>
  //NOTE(Torin) Configure lapic spuritous interput vector
  //TODO(Torin) I dont think that this is configured correctly
  static const uint64_t APIC_SIVR_OFFSET = 0xF0;
  static const uint32_t SIVR_ENABLE = 1 << 8;
  static const uint32_t SIVR_FOCUS_CHECKING = 1 << 9;
  lapic_write_register(apic_register_base, APIC_SIVR_OFFSET, 0x31 | SIVR_ENABLE);
  109c63:	8b 05 d7 e4 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe4d7]        # 108140 <SIVR_ENABLE.4337>
  109c69:	83 c8 31             	or     eax,0x31
  109c6c:	89 c2                	mov    edx,eax
  109c6e:	48 8b 0d d3 e4 ff ff 	mov    rcx,QWORD PTR [rip+0xffffffffffffe4d3]        # 108148 <APIC_SIVR_OFFSET.4336>
  109c75:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109c79:	48 89 ce             	mov    rsi,rcx
  109c7c:	48 89 c7             	mov    rdi,rax
  109c7f:	e8 2d ff ff ff       	call   109bb1 <lapic_write_register>
	asm volatile("sti");
  109c84:	fb                   	sti    
}
  109c85:	90                   	nop
  109c86:	c9                   	leave  
  109c87:	c3                   	ret    

0000000000109c88 <lapic_configure_timer>:

static void
lapic_configure_timer(uintptr_t lapic_virtual_address, uint32_t inital_count, uint32_t irq_number, uint32_t mode){
  109c88:	55                   	push   rbp
  109c89:	48 89 e5             	mov    rbp,rsp
  109c8c:	48 83 ec 28          	sub    rsp,0x28
  109c90:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  109c94:	89 75 e4             	mov    DWORD PTR [rbp-0x1c],esi
  109c97:	89 55 e0             	mov    DWORD PTR [rbp-0x20],edx
  109c9a:	89 4d dc             	mov    DWORD PTR [rbp-0x24],ecx
  static const uint32_t TIMER_DIVIDE_BY_8 = 0b10;
  static const uint32_t TIMER_DIVIDE_BY_16 = 0b11;

  static const uint32_t TIMER_ONE_SHOT_MODE = 0x00000;
  static const uint32_t TIMER_PERIODIC_MODE = 0x20000;
  const uint32_t mode_mask = mode ? TIMER_PERIODIC_MODE : TIMER_ONE_SHOT_MODE;
  109c9d:	83 7d dc 00          	cmp    DWORD PTR [rbp-0x24],0x0
  109ca1:	74 08                	je     109cab <lapic_configure_timer+0x23>
  109ca3:	8b 05 ab e4 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe4ab]        # 108154 <TIMER_PERIODIC_MODE.4354>
  109ca9:	eb 06                	jmp    109cb1 <lapic_configure_timer+0x29>
  109cab:	8b 05 a7 e4 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe4a7]        # 108158 <TIMER_ONE_SHOT_MODE.4353>
  109cb1:	89 45 fc             	mov    DWORD PTR [rbp-0x4],eax

  lapic_write_register(lapic_virtual_address, TIMER_INITAL_COUNT_REGISTER, inital_count);
  109cb4:	8b 05 a2 e4 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe4a2]        # 10815c <TIMER_INITAL_COUNT_REGISTER.4346>
  109cba:	89 c1                	mov    ecx,eax
  109cbc:	8b 55 e4             	mov    edx,DWORD PTR [rbp-0x1c]
  109cbf:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  109cc3:	48 89 ce             	mov    rsi,rcx
  109cc6:	48 89 c7             	mov    rdi,rax
  109cc9:	e8 e3 fe ff ff       	call   109bb1 <lapic_write_register>
  lapic_write_register(lapic_virtual_address, TIMER_DIVIDE_CONFIG_REGISTER, TIMER_DIVIDE_BY_16);
  109cce:	8b 15 8c e4 ff ff    	mov    edx,DWORD PTR [rip+0xffffffffffffe48c]        # 108160 <TIMER_DIVIDE_BY_16.4352>
  109cd4:	8b 05 8a e4 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe48a]        # 108164 <TIMER_DIVIDE_CONFIG_REGISTER.4348>
  109cda:	89 c1                	mov    ecx,eax
  109cdc:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  109ce0:	48 89 ce             	mov    rsi,rcx
  109ce3:	48 89 c7             	mov    rdi,rax
  109ce6:	e8 c6 fe ff ff       	call   109bb1 <lapic_write_register>
  lapic_write_register(lapic_virtual_address, TIMER_IRQ_REGISTER, irq_number | mode_mask);
  109ceb:	8b 45 e0             	mov    eax,DWORD PTR [rbp-0x20]
  109cee:	0b 45 fc             	or     eax,DWORD PTR [rbp-0x4]
  109cf1:	89 c2                	mov    edx,eax
  109cf3:	8b 05 6f e4 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe46f]        # 108168 <TIMER_IRQ_REGISTER.4345>
  109cf9:	89 c1                	mov    ecx,eax
  109cfb:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  109cff:	48 89 ce             	mov    rsi,rcx
  109d02:	48 89 c7             	mov    rdi,rax
  109d05:	e8 a7 fe ff ff       	call   109bb1 <lapic_write_register>
}
  109d0a:	90                   	nop
  109d0b:	c9                   	leave  
  109d0c:	c3                   	ret    

0000000000109d0d <lapic_startup_ap>:

//NOTE(Torin) Called from the bootstrap processor to send A SIPI signal to the target application processor 
static void 
lapic_startup_ap(uintptr_t apic_register_base, uint8_t target_apic_id, uint8_t target_page_number){
  109d0d:	55                   	push   rbp
  109d0e:	48 89 e5             	mov    rbp,rsp
  109d11:	48 83 ec 40          	sub    rsp,0x40
  109d15:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  109d19:	89 f1                	mov    ecx,esi
  109d1b:	89 d0                	mov    eax,edx
  109d1d:	88 4d c4             	mov    BYTE PTR [rbp-0x3c],cl
  109d20:	88 45 c0             	mov    BYTE PTR [rbp-0x40],al
  } __attribute((packed));

  typedef struct ICR1_STRUCT ICR1_Register;
  typedef struct ICR2_STRUCT ICR2_Register;

  ICR1_Register icr1 = {};
  109d23:	c7 45 e0 00 00 00 00 	mov    DWORD PTR [rbp-0x20],0x0
  icr1.delivery_mode = DELIVERY_MODE_INIT;
  109d2a:	0f b6 05 4b e4 ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffe44b]        # 10817c <DELIVERY_MODE_INIT.4367>
  109d31:	83 e0 07             	and    eax,0x7
  109d34:	83 e0 07             	and    eax,0x7
  109d37:	89 c2                	mov    edx,eax
  109d39:	0f b6 45 e1          	movzx  eax,BYTE PTR [rbp-0x1f]
  109d3d:	83 e0 f8             	and    eax,0xfffffff8
  109d40:	09 d0                	or     eax,edx
  109d42:	88 45 e1             	mov    BYTE PTR [rbp-0x1f],al
  ICR2_Register icr2 = {};
  109d45:	c7 45 d0 00 00 00 00 	mov    DWORD PTR [rbp-0x30],0x0
  icr2.destination_field = target_apic_id;
  109d4c:	0f b6 45 c4          	movzx  eax,BYTE PTR [rbp-0x3c]
  109d50:	88 45 d3             	mov    BYTE PTR [rbp-0x2d],al

  //NOTE(Torin) Writing to the ICR1 causues a IPI to be generated automaticly so ICR2 is written first
  //Send INIT IPI To set processor to wait for SIPI

  uint32_t icr2_value = *(uint32_t *)&icr2;
  109d53:	48 8d 45 d0          	lea    rax,[rbp-0x30]
  109d57:	8b 00                	mov    eax,DWORD PTR [rax]
  109d59:	89 45 ec             	mov    DWORD PTR [rbp-0x14],eax
  uint32_t icr1_value = *(uint32_t *)&icr1;
  109d5c:	48 8d 45 e0          	lea    rax,[rbp-0x20]
  109d60:	8b 00                	mov    eax,DWORD PTR [rax]
  109d62:	89 45 e8             	mov    DWORD PTR [rbp-0x18],eax
  klog_debug("icr2_value: %u", icr2_value);
  109d65:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
  109d68:	89 c2                	mov    edx,eax
  109d6a:	be be 60 10 00       	mov    esi,0x1060be
  109d6f:	bf 00 e0 10 00       	mov    edi,0x10e000
  109d74:	b8 00 00 00 00       	mov    eax,0x0
  109d79:	e8 e9 2e 00 00       	call   10cc67 <klog_write_fmt>
  klog_debug("icr1_value: %u", icr1_value);
  109d7e:	8b 45 e8             	mov    eax,DWORD PTR [rbp-0x18]
  109d81:	89 c2                	mov    edx,eax
  109d83:	be cd 60 10 00       	mov    esi,0x1060cd
  109d88:	bf 00 e0 10 00       	mov    edi,0x10e000
  109d8d:	b8 00 00 00 00       	mov    eax,0x0
  109d92:	e8 d0 2e 00 00       	call   10cc67 <klog_write_fmt>

  lapic_write_register(apic_register_base, APIC_ICR2_OFFSET, *(uint32_t *)&icr2);
  109d97:	48 8d 45 d0          	lea    rax,[rbp-0x30]
  109d9b:	8b 10                	mov    edx,DWORD PTR [rax]
  109d9d:	48 8b 0d dc e3 ff ff 	mov    rcx,QWORD PTR [rip+0xffffffffffffe3dc]        # 108180 <APIC_ICR2_OFFSET.4362>
  109da4:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  109da8:	48 89 ce             	mov    rsi,rcx
  109dab:	48 89 c7             	mov    rdi,rax
  109dae:	e8 fe fd ff ff       	call   109bb1 <lapic_write_register>
  lapic_write_register(apic_register_base, APIC_ICR1_OFFSET, *(uint32_t *)&icr1);
  109db3:	48 8d 45 e0          	lea    rax,[rbp-0x20]
  109db7:	8b 10                	mov    edx,DWORD PTR [rax]
  109db9:	48 8b 0d c8 e3 ff ff 	mov    rcx,QWORD PTR [rip+0xffffffffffffe3c8]        # 108188 <APIC_ICR1_OFFSET.4361>
  109dc0:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  109dc4:	48 89 ce             	mov    rsi,rcx
  109dc7:	48 89 c7             	mov    rdi,rax
  109dca:	e8 e2 fd ff ff       	call   109bb1 <lapic_write_register>
  while(icr1.delivery_status == 1){
  109dcf:	eb 14                	jmp    109de5 <lapic_startup_ap+0xd8>
    klog_debug("waiting for icr1 to get delivered!");
  109dd1:	be e0 60 10 00       	mov    esi,0x1060e0
  109dd6:	bf 00 e0 10 00       	mov    edi,0x10e000
  109ddb:	b8 00 00 00 00       	mov    eax,0x0
  109de0:	e8 82 2e 00 00       	call   10cc67 <klog_write_fmt>
  while(icr1.delivery_status == 1){
  109de5:	0f b6 45 e1          	movzx  eax,BYTE PTR [rbp-0x1f]
  109de9:	83 e0 10             	and    eax,0x10
  109dec:	84 c0                	test   al,al
  109dee:	75 e1                	jne    109dd1 <lapic_startup_ap+0xc4>
  }

  for(size_t i = 0; i < 0xFFFFF; i++) { asm volatile ( "nop" ); }
  109df0:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  109df7:	00 
  109df8:	eb 06                	jmp    109e00 <lapic_startup_ap+0xf3>
  109dfa:	90                   	nop
  109dfb:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  109e00:	48 81 7d f8 fe ff 0f 	cmp    QWORD PTR [rbp-0x8],0xffffe
  109e07:	00 
  109e08:	76 f0                	jbe    109dfa <lapic_startup_ap+0xed>

  //Setup and send SIPI
  icr1.vector = target_page_number; 
  109e0a:	0f b6 45 c0          	movzx  eax,BYTE PTR [rbp-0x40]
  109e0e:	88 45 e0             	mov    BYTE PTR [rbp-0x20],al
  icr1.delivery_mode = DELIVERY_MODE_SIPI;
  109e11:	0f b6 05 78 e3 ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffe378]        # 108190 <DELIVERY_MODE_SIPI.4368>
  109e18:	83 e0 07             	and    eax,0x7
  109e1b:	83 e0 07             	and    eax,0x7
  109e1e:	89 c2                	mov    edx,eax
  109e20:	0f b6 45 e1          	movzx  eax,BYTE PTR [rbp-0x1f]
  109e24:	83 e0 f8             	and    eax,0xfffffff8
  109e27:	09 d0                	or     eax,edx
  109e29:	88 45 e1             	mov    BYTE PTR [rbp-0x1f],al
  lapic_write_register(apic_register_base, APIC_ICR2_OFFSET, *(uint32_t *)&icr2);
  109e2c:	48 8d 45 d0          	lea    rax,[rbp-0x30]
  109e30:	8b 10                	mov    edx,DWORD PTR [rax]
  109e32:	48 8b 0d 47 e3 ff ff 	mov    rcx,QWORD PTR [rip+0xffffffffffffe347]        # 108180 <APIC_ICR2_OFFSET.4362>
  109e39:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  109e3d:	48 89 ce             	mov    rsi,rcx
  109e40:	48 89 c7             	mov    rdi,rax
  109e43:	e8 69 fd ff ff       	call   109bb1 <lapic_write_register>
  lapic_write_register(apic_register_base, APIC_ICR1_OFFSET, *(uint32_t *)&icr1);
  109e48:	48 8d 45 e0          	lea    rax,[rbp-0x20]
  109e4c:	8b 10                	mov    edx,DWORD PTR [rax]
  109e4e:	48 8b 0d 33 e3 ff ff 	mov    rcx,QWORD PTR [rip+0xffffffffffffe333]        # 108188 <APIC_ICR1_OFFSET.4361>
  109e55:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  109e59:	48 89 ce             	mov    rsi,rcx
  109e5c:	48 89 c7             	mov    rdi,rax
  109e5f:	e8 4d fd ff ff       	call   109bb1 <lapic_write_register>
  for(size_t i = 0; i < 0xFFFFF; i++) { asm volatile ( "nop" ); }
  109e64:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
  109e6b:	00 
  109e6c:	eb 06                	jmp    109e74 <lapic_startup_ap+0x167>
  109e6e:	90                   	nop
  109e6f:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  109e74:	48 81 7d f0 fe ff 0f 	cmp    QWORD PTR [rbp-0x10],0xffffe
  109e7b:	00 
  109e7c:	76 f0                	jbe    109e6e <lapic_startup_ap+0x161>
  lapic_write_register(apic_register_base, APIC_ICR2_OFFSET, *(uint32_t *)&icr2);
  109e7e:	48 8d 45 d0          	lea    rax,[rbp-0x30]
  109e82:	8b 10                	mov    edx,DWORD PTR [rax]
  109e84:	48 8b 0d f5 e2 ff ff 	mov    rcx,QWORD PTR [rip+0xffffffffffffe2f5]        # 108180 <APIC_ICR2_OFFSET.4362>
  109e8b:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  109e8f:	48 89 ce             	mov    rsi,rcx
  109e92:	48 89 c7             	mov    rdi,rax
  109e95:	e8 17 fd ff ff       	call   109bb1 <lapic_write_register>
  lapic_write_register(apic_register_base, APIC_ICR1_OFFSET, *(uint32_t *)&icr1);
  109e9a:	48 8d 45 e0          	lea    rax,[rbp-0x20]
  109e9e:	8b 10                	mov    edx,DWORD PTR [rax]
  109ea0:	48 8b 0d e1 e2 ff ff 	mov    rcx,QWORD PTR [rip+0xffffffffffffe2e1]        # 108188 <APIC_ICR1_OFFSET.4361>
  109ea7:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  109eab:	48 89 ce             	mov    rsi,rcx
  109eae:	48 89 c7             	mov    rdi,rax
  109eb1:	e8 fb fc ff ff       	call   109bb1 <lapic_write_register>
  109eb6:	90                   	nop
  109eb7:	c9                   	leave  
  109eb8:	c3                   	ret    

0000000000109eb9 <gdt_encode_system_descriptor>:

#define GDT_DESCRIPTOR_TYPE_LDT (0b0010)
#define GDT_DESCRIPTOR_TYPE_TSS (0b1001)

static inline
void gdt_encode_system_descriptor(uintptr_t base_address, uint32_t segment_limit, uint8_t type, uint8_t privlege_level, uintptr_t out){
  109eb9:	55                   	push   rbp
  109eba:	48 89 e5             	mov    rbp,rsp
  109ebd:	48 83 ec 40          	sub    rsp,0x40
  109ec1:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  109ec5:	89 75 d4             	mov    DWORD PTR [rbp-0x2c],esi
  109ec8:	89 c8                	mov    eax,ecx
  109eca:	4c 89 45 c0          	mov    QWORD PTR [rbp-0x40],r8
  109ece:	88 55 d0             	mov    BYTE PTR [rbp-0x30],dl
  109ed1:	88 45 cc             	mov    BYTE PTR [rbp-0x34],al
  kassert(segment_limit < (1 << 19));
  109ed4:	81 7d d4 ff ff 07 00 	cmp    DWORD PTR [rbp-0x2c],0x7ffff
  109edb:	76 30                	jbe    109f0d <gdt_encode_system_descriptor+0x54>
  109edd:	41 b8 03 61 10 00    	mov    r8d,0x106103
  109ee3:	b9 3c 00 00 00       	mov    ecx,0x3c
  109ee8:	ba 1b 61 10 00       	mov    edx,0x10611b
  109eed:	be 38 61 10 00       	mov    esi,0x106138
  109ef2:	bf 00 e0 10 00       	mov    edi,0x10e000
  109ef7:	b8 00 00 00 00       	mov    eax,0x0
  109efc:	e8 66 2d 00 00       	call   10cc67 <klog_write_fmt>
  109f01:	bf 00 e0 10 00       	mov    edi,0x10e000
  109f06:	e8 13 f7 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  109f0b:	fa                   	cli    
  109f0c:	f4                   	hlt    
  kassert(type < (1 << 4));
  109f0d:	80 7d d0 0f          	cmp    BYTE PTR [rbp-0x30],0xf
  109f11:	76 30                	jbe    109f43 <gdt_encode_system_descriptor+0x8a>
  109f13:	41 b8 03 61 10 00    	mov    r8d,0x106103
  109f19:	b9 3d 00 00 00       	mov    ecx,0x3d
  109f1e:	ba 63 61 10 00       	mov    edx,0x106163
  109f23:	be 38 61 10 00       	mov    esi,0x106138
  109f28:	bf 00 e0 10 00       	mov    edi,0x10e000
  109f2d:	b8 00 00 00 00       	mov    eax,0x0
  109f32:	e8 30 2d 00 00       	call   10cc67 <klog_write_fmt>
  109f37:	bf 00 e0 10 00       	mov    edi,0x10e000
  109f3c:	e8 dd f6 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  109f41:	fa                   	cli    
  109f42:	f4                   	hlt    
  kassert(privlege_level < (1 << 2));
  109f43:	80 7d cc 03          	cmp    BYTE PTR [rbp-0x34],0x3
  109f47:	76 30                	jbe    109f79 <gdt_encode_system_descriptor+0xc0>
  109f49:	41 b8 03 61 10 00    	mov    r8d,0x106103
  109f4f:	b9 3e 00 00 00       	mov    ecx,0x3e
  109f54:	ba 73 61 10 00       	mov    edx,0x106173
  109f59:	be 38 61 10 00       	mov    esi,0x106138
  109f5e:	bf 00 e0 10 00       	mov    edi,0x10e000
  109f63:	b8 00 00 00 00       	mov    eax,0x0
  109f68:	e8 fa 2c 00 00       	call   10cc67 <klog_write_fmt>
  109f6d:	bf 00 e0 10 00       	mov    edi,0x10e000
  109f72:	e8 a7 f6 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  109f77:	fa                   	cli    
  109f78:	f4                   	hlt    
    uint16_t base_address_24_31;
    uint32_t base_address_32_63;
    uint32_t reserved1;
  } __attribute__((packed));

  struct GDT_System_Descriptor descriptor = {};
  109f79:	48 c7 45 e0 00 00 00 	mov    QWORD PTR [rbp-0x20],0x0
  109f80:	00 
  109f81:	48 c7 45 e8 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0
  109f88:	00 
  109f89:	c6 45 f0 00          	mov    BYTE PTR [rbp-0x10],0x0
  descriptor.base_address_0_15  = (base_address >> 0) & 0xFFFF;
  109f8d:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109f91:	66 89 45 e2          	mov    WORD PTR [rbp-0x1e],ax
  descriptor.base_address_16_23 = (base_address >> 16) & 0xFF;
  109f95:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109f99:	48 c1 e8 10          	shr    rax,0x10
  109f9d:	88 45 e4             	mov    BYTE PTR [rbp-0x1c],al
  descriptor.base_address_24_31 = (base_address >> 24) & 0xFF;
  109fa0:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109fa4:	48 c1 e8 18          	shr    rax,0x18
  109fa8:	0f b6 c0             	movzx  eax,al
  109fab:	66 89 45 e7          	mov    WORD PTR [rbp-0x19],ax
  descriptor.base_address_32_63 = (base_address >> 32) & 0xFFFFFFFF;
  109faf:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109fb3:	48 c1 e8 20          	shr    rax,0x20
  109fb7:	89 45 e9             	mov    DWORD PTR [rbp-0x17],eax

  descriptor.segment_limit_0_15 = (segment_limit >> 0) & 0xFFFF;
  109fba:	8b 45 d4             	mov    eax,DWORD PTR [rbp-0x2c]
  109fbd:	66 89 45 e0          	mov    WORD PTR [rbp-0x20],ax
  descriptor.segment_limit_16_19 = (segment_limit >> 16) & 0b1111;
  109fc1:	8b 45 d4             	mov    eax,DWORD PTR [rbp-0x2c]
  109fc4:	c1 e8 10             	shr    eax,0x10
  109fc7:	83 e0 0f             	and    eax,0xf
  109fca:	83 e0 0f             	and    eax,0xf
  109fcd:	89 c2                	mov    edx,eax
  109fcf:	0f b6 45 e6          	movzx  eax,BYTE PTR [rbp-0x1a]
  109fd3:	83 e0 f0             	and    eax,0xfffffff0
  109fd6:	09 d0                	or     eax,edx
  109fd8:	88 45 e6             	mov    BYTE PTR [rbp-0x1a],al

  descriptor.present = 1;
  109fdb:	0f b6 45 e5          	movzx  eax,BYTE PTR [rbp-0x1b]
  109fdf:	83 c8 80             	or     eax,0xffffff80
  109fe2:	88 45 e5             	mov    BYTE PTR [rbp-0x1b],al
  descriptor.available = 1;
  109fe5:	0f b6 45 e6          	movzx  eax,BYTE PTR [rbp-0x1a]
  109fe9:	83 c8 10             	or     eax,0x10
  109fec:	88 45 e6             	mov    BYTE PTR [rbp-0x1a],al
  descriptor.type = type;
  109fef:	0f b6 45 d0          	movzx  eax,BYTE PTR [rbp-0x30]
  109ff3:	83 e0 0f             	and    eax,0xf
  109ff6:	83 e0 0f             	and    eax,0xf
  109ff9:	89 c2                	mov    edx,eax
  109ffb:	0f b6 45 e5          	movzx  eax,BYTE PTR [rbp-0x1b]
  109fff:	83 e0 f0             	and    eax,0xfffffff0
  10a002:	09 d0                	or     eax,edx
  10a004:	88 45 e5             	mov    BYTE PTR [rbp-0x1b],al
  descriptor.privlege_level = privlege_level;
  10a007:	0f b6 45 cc          	movzx  eax,BYTE PTR [rbp-0x34]
  10a00b:	83 e0 03             	and    eax,0x3
  10a00e:	83 e0 03             	and    eax,0x3
  10a011:	c1 e0 05             	shl    eax,0x5
  10a014:	89 c2                	mov    edx,eax
  10a016:	0f b6 45 e5          	movzx  eax,BYTE PTR [rbp-0x1b]
  10a01a:	83 e0 9f             	and    eax,0xffffff9f
  10a01d:	09 d0                	or     eax,edx
  10a01f:	88 45 e5             	mov    BYTE PTR [rbp-0x1b],al
  memcpy(out, &descriptor, sizeof(struct GDT_System_Descriptor));
  10a022:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10a026:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  10a02a:	ba 11 00 00 00       	mov    edx,0x11
  10a02f:	48 89 ce             	mov    rsi,rcx
  10a032:	48 89 c7             	mov    rdi,rax
  10a035:	e8 08 f0 ff ff       	call   109042 <__memcpy>

  klog_debug("tss base address: 0x%X", base_address);
  10a03a:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10a03e:	48 89 c2             	mov    rdx,rax
  10a041:	be 8d 61 10 00       	mov    esi,0x10618d
  10a046:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a04b:	b8 00 00 00 00       	mov    eax,0x0
  10a050:	e8 12 2c 00 00       	call   10cc67 <klog_write_fmt>
  klog_debug("tss limit: 0x%X", segment_limit);
  10a055:	8b 45 d4             	mov    eax,DWORD PTR [rbp-0x2c]
  10a058:	89 c2                	mov    edx,eax
  10a05a:	be a4 61 10 00       	mov    esi,0x1061a4
  10a05f:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a064:	b8 00 00 00 00       	mov    eax,0x0
  10a069:	e8 f9 2b 00 00       	call   10cc67 <klog_write_fmt>
}
  10a06e:	90                   	nop
  10a06f:	c9                   	leave  
  10a070:	c3                   	ret    

000000000010a071 <idt_encode_entry>:

static void
idt_encode_entry(const uintptr_t entry_addr, const uintptr_t handler_addr, const bool is_user_accessible){
  10a071:	55                   	push   rbp
  10a072:	48 89 e5             	mov    rbp,rsp
  10a075:	48 83 ec 28          	sub    rsp,0x28
  10a079:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10a07d:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  10a081:	89 d0                	mov    eax,edx
  10a083:	88 45 dc             	mov    BYTE PTR [rbp-0x24],al
	
	static const uint64_t TYPE_TASK_GATE_64 = 0x5;
	static const uint64_t TYPE_INTERRUPT_GATE_64 = 0xE;
	static const uint64_t TYPE_TRAP_GATE_64 = 0xF;

  IDT_Entry *entry = (IDT_Entry *)entry_addr;
  10a086:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10a08a:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
	entry->offset_0_15 = (uint16_t)(handler_addr & 0xFFFF);
  10a08e:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10a092:	89 c2                	mov    edx,eax
  10a094:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a098:	66 89 10             	mov    WORD PTR [rax],dx
	entry->offset_16_31 = (uint16_t)((handler_addr >> 16) & 0xFFFF);
  10a09b:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10a09f:	48 c1 e8 10          	shr    rax,0x10
  10a0a3:	89 c2                	mov    edx,eax
  10a0a5:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a0a9:	66 89 50 06          	mov    WORD PTR [rax+0x6],dx
	entry->offset_32_63 = (uint32_t)((handler_addr >> 32) & 0xFFFFFFFF);
  10a0ad:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10a0b1:	48 c1 e8 20          	shr    rax,0x20
  10a0b5:	89 c2                	mov    edx,eax
  10a0b7:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a0bb:	89 50 08             	mov    DWORD PTR [rax+0x8],edx
	entry->type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | (is_user_accessible ?  PRIVILEGE_LEVEL_3 : PRIVILEGE_LEVEL_0); 
  10a0be:	48 8b 05 db e0 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffe0db]        # 1081a0 <PRESENT_BIT.4464>
  10a0c5:	89 c2                	mov    edx,eax
  10a0c7:	48 8b 05 da e0 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffe0da]        # 1081a8 <TYPE_INTERRUPT_GATE_64.4466>
  10a0ce:	09 c2                	or     edx,eax
  10a0d0:	80 7d dc 00          	cmp    BYTE PTR [rbp-0x24],0x0
  10a0d4:	74 09                	je     10a0df <idt_encode_entry+0x6e>
  10a0d6:	48 8b 05 d3 e0 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffe0d3]        # 1081b0 <PRIVILEGE_LEVEL_3.4463>
  10a0dd:	eb 07                	jmp    10a0e6 <idt_encode_entry+0x75>
  10a0df:	48 8b 05 d2 e0 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffe0d2]        # 1081b8 <PRIVILEGE_LEVEL_0.4462>
  10a0e6:	09 c2                	or     edx,eax
  10a0e8:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a0ec:	88 50 05             	mov    BYTE PTR [rax+0x5],dl
	entry->code_segment_selector = GDT_RING0_CODE;
  10a0ef:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a0f3:	66 c7 40 02 18 00    	mov    WORD PTR [rax+0x2],0x18
	entry->ist = 0;
  10a0f9:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a0fd:	c6 40 04 00          	mov    BYTE PTR [rax+0x4],0x0
}
  10a101:	90                   	nop
  10a102:	c9                   	leave  
  10a103:	c3                   	ret    

000000000010a104 <tss_ldr>:
void gdt_gdtr(uintptr_t base_address, size_t size){

}

static inline
void tss_ldr(const uint16_t selector_index){
  10a104:	55                   	push   rbp
  10a105:	48 89 e5             	mov    rbp,rsp
  10a108:	48 83 ec 20          	sub    rsp,0x20
  10a10c:	89 f8                	mov    eax,edi
  10a10e:	66 89 45 ec          	mov    WORD PTR [rbp-0x14],ax
  asm volatile("cli");
  10a112:	fa                   	cli    
  } task_register;
  
  //@Research
  //TODO(Torin: 2016-08-24) AMD64 system manual has the task_register with the above structure
  //It appears that is incorrect and its just a flat selector_index.  Make sure this is the case!
  uint16_t value = selector_index | 0b00; //This is probably what was ment?
  10a113:	0f b7 45 ec          	movzx  eax,WORD PTR [rbp-0x14]
  10a117:	66 89 45 fe          	mov    WORD PTR [rbp-0x2],ax
  klog_debug("task_register selector_index: 0x%X", (uint32_t)value);
  10a11b:	0f b7 45 fe          	movzx  eax,WORD PTR [rbp-0x2]
  10a11f:	89 c2                	mov    edx,eax
  10a121:	be b8 61 10 00       	mov    esi,0x1061b8
  10a126:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a12b:	b8 00 00 00 00       	mov    eax,0x0
  10a130:	e8 32 2b 00 00       	call   10cc67 <klog_write_fmt>
  //asm volatile ("ltr %0" : : "a"(task_register.packed));
  asm volatile ("ltr %0" : : "a"(value));
  10a135:	0f b7 45 fe          	movzx  eax,WORD PTR [rbp-0x2]
  10a139:	0f 00 d8             	ltr    ax
  asm volatile("sti");
  10a13c:	fb                   	sti    
}
  10a13d:	90                   	nop
  10a13e:	c9                   	leave  
  10a13f:	c3                   	ret    

000000000010a140 <isr_handler_general_protection_fault>:
  "Reserved",                     //31 0x1F
};


static void
isr_handler_general_protection_fault(Interrupt_Stack_Frame stack_frame) {
  10a140:	55                   	push   rbp
  10a141:	48 89 e5             	mov    rbp,rsp
  10a144:	48 83 ec 10          	sub    rsp,0x10
    "IDT",
    "LDT",
    "IDT",
  };

  error_code.packed = stack_frame.error_code;
  10a148:	48 8b 45 30          	mov    rax,QWORD PTR [rbp+0x30]
  10a14c:	89 45 f0             	mov    DWORD PTR [rbp-0x10],eax
  if(error_code.packed != 0){
  10a14f:	8b 45 f0             	mov    eax,DWORD PTR [rbp-0x10]
  10a152:	85 c0                	test   eax,eax
  10a154:	0f 84 9e 00 00 00    	je     10a1f8 <isr_handler_general_protection_fault+0xb8>
    klog_error("GPF caused by segment error: ");
  10a15a:	be 68 63 10 00       	mov    esi,0x106368
  10a15f:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a164:	b8 00 00 00 00       	mov    eax,0x0
  10a169:	e8 f9 2a 00 00       	call   10cc67 <klog_write_fmt>
    klog_error(" external_to_cpu: %s", error_code.is_external_to_cpu ? "true" : "false");
  10a16e:	0f b6 45 f0          	movzx  eax,BYTE PTR [rbp-0x10]
  10a172:	83 e0 01             	and    eax,0x1
  10a175:	84 c0                	test   al,al
  10a177:	74 07                	je     10a180 <isr_handler_general_protection_fault+0x40>
  10a179:	b8 86 63 10 00       	mov    eax,0x106386
  10a17e:	eb 05                	jmp    10a185 <isr_handler_general_protection_fault+0x45>
  10a180:	b8 8b 63 10 00       	mov    eax,0x10638b
  10a185:	48 89 c2             	mov    rdx,rax
  10a188:	be 91 63 10 00       	mov    esi,0x106391
  10a18d:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a192:	b8 00 00 00 00       	mov    eax,0x0
  10a197:	e8 cb 2a 00 00       	call   10cc67 <klog_write_fmt>
    klog_error(" table_name: %s", TABLE_NAMES[error_code.table_index]);
  10a19c:	0f b6 45 f0          	movzx  eax,BYTE PTR [rbp-0x10]
  10a1a0:	d0 e8                	shr    al,1
  10a1a2:	83 e0 03             	and    eax,0x3
  10a1a5:	0f b6 c0             	movzx  eax,al
  10a1a8:	48 98                	cdqe   
  10a1aa:	48 8b 04 c5 60 d8 10 	mov    rax,QWORD PTR [rax*8+0x10d860]
  10a1b1:	00 
  10a1b2:	48 89 c2             	mov    rdx,rax
  10a1b5:	be a6 63 10 00       	mov    esi,0x1063a6
  10a1ba:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a1bf:	b8 00 00 00 00       	mov    eax,0x0
  10a1c4:	e8 9e 2a 00 00       	call   10cc67 <klog_write_fmt>
    klog_error(" selector_index: 0x%X", error_code.selector_index);
  10a1c9:	0f b7 45 f0          	movzx  eax,WORD PTR [rbp-0x10]
  10a1cd:	66 c1 e8 03          	shr    ax,0x3
  10a1d1:	0f b7 c0             	movzx  eax,ax
  10a1d4:	89 c2                	mov    edx,eax
  10a1d6:	be b6 63 10 00       	mov    esi,0x1063b6
  10a1db:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a1e0:	b8 00 00 00 00       	mov    eax,0x0
  10a1e5:	e8 7d 2a 00 00       	call   10cc67 <klog_write_fmt>
    kpanic();
  10a1ea:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a1ef:	e8 2a f4 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10a1f4:	fa                   	cli    
  10a1f5:	f4                   	hlt    
    //TODO(Torin: 2016-08-24) Need to determine if the exception was caused in usermode or kernelmode
    //And then attempt to recover from the error.  This can happen if usermode code attemps
    //to execute a privleged instruction!
    kpanic();
  }
}
  10a1f6:	eb 0c                	jmp    10a204 <isr_handler_general_protection_fault+0xc4>
    kpanic();
  10a1f8:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a1fd:	e8 1c f4 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10a202:	fa                   	cli    
  10a203:	f4                   	hlt    
}
  10a204:	90                   	nop
  10a205:	c9                   	leave  
  10a206:	c3                   	ret    

000000000010a207 <isr_handler_page_fault>:

static void 
isr_handler_page_fault(Interrupt_Stack_Frame stack_frame) {
  10a207:	55                   	push   rbp
  10a208:	48 89 e5             	mov    rbp,rsp
  10a20b:	48 83 ec 30          	sub    rsp,0x30
	static const uint64_t CAUSE_USER_OR_KERNEL = (1 << 2);
	static const uint64_t CAUSE_RESERVED_BIT_SET = (1 << 3);
	static const uint64_t CAUSE_INSTRUCTION_FETCH = (1 << 4);

	uintptr_t faulting_address;
	asm volatile ("movq %%cr2, %0" : "=r"(faulting_address));
  10a20f:	0f 20 d0             	mov    rax,cr2
  10a212:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
	uint64_t is_protection_voloation_else_not_present = stack_frame.error_code & CAUSE_PROTECTION_VIOLATION_OR_NOT_PRESENT;
  10a216:	48 8b 55 30          	mov    rdx,QWORD PTR [rbp+0x30]
  10a21a:	48 8b 05 bf df ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffdfbf]        # 1081e0 <CAUSE_PROTECTION_VIOLATION_OR_NOT_PRESENT.4508>
  10a221:	48 21 d0             	and    rax,rdx
  10a224:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
	uint64_t is_write_else_read = stack_frame.error_code & CAUSE_WRITE_OR_READ;
  10a228:	48 8b 55 30          	mov    rdx,QWORD PTR [rbp+0x30]
  10a22c:	48 8b 05 b5 df ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffdfb5]        # 1081e8 <CAUSE_WRITE_OR_READ.4509>
  10a233:	48 21 d0             	and    rax,rdx
  10a236:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
	uint64_t is_usermode_else_kernel = stack_frame.error_code & CAUSE_USER_OR_KERNEL;
  10a23a:	48 8b 55 30          	mov    rdx,QWORD PTR [rbp+0x30]
  10a23e:	48 8b 05 ab df ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffdfab]        # 1081f0 <CAUSE_USER_OR_KERNEL.4510>
  10a245:	48 21 d0             	and    rax,rdx
  10a248:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
	uint64_t is_reserved_bit_overwritten = stack_frame.error_code & CAUSE_RESERVED_BIT_SET;
  10a24c:	48 8b 55 30          	mov    rdx,QWORD PTR [rbp+0x30]
  10a250:	48 8b 05 a1 df ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffdfa1]        # 1081f8 <CAUSE_RESERVED_BIT_SET.4511>
  10a257:	48 21 d0             	and    rax,rdx
  10a25a:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
	uint64_t is_instruction_else_data = stack_frame.error_code & CAUSE_INSTRUCTION_FETCH;
  10a25e:	48 8b 55 30          	mov    rdx,QWORD PTR [rbp+0x30]
  10a262:	48 8b 05 97 df ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffdf97]        # 108200 <CAUSE_INSTRUCTION_FETCH.4512>
  10a269:	48 21 d0             	and    rax,rdx
  10a26c:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
	
	klog_error("Page Fault (%s%s%s%s%s, faulting_address: 0x%X)", 
  10a270:	48 83 7d d0 00       	cmp    QWORD PTR [rbp-0x30],0x0
  10a275:	74 07                	je     10a27e <isr_handler_page_fault+0x77>
  10a277:	b9 cc 63 10 00       	mov    ecx,0x1063cc
  10a27c:	eb 05                	jmp    10a283 <isr_handler_page_fault+0x7c>
  10a27e:	b9 e8 63 10 00       	mov    ecx,0x1063e8
  10a283:	48 83 7d d8 00       	cmp    QWORD PTR [rbp-0x28],0x0
  10a288:	74 07                	je     10a291 <isr_handler_page_fault+0x8a>
  10a28a:	bf 00 64 10 00       	mov    edi,0x106400
  10a28f:	eb 05                	jmp    10a296 <isr_handler_page_fault+0x8f>
  10a291:	bf 21 64 10 00       	mov    edi,0x106421
  10a296:	48 83 7d e0 00       	cmp    QWORD PTR [rbp-0x20],0x0
  10a29b:	74 07                	je     10a2a4 <isr_handler_page_fault+0x9d>
  10a29d:	be 3a 64 10 00       	mov    esi,0x10643a
  10a2a2:	eb 05                	jmp    10a2a9 <isr_handler_page_fault+0xa2>
  10a2a4:	be 52 64 10 00       	mov    esi,0x106452
  10a2a9:	48 83 7d e8 00       	cmp    QWORD PTR [rbp-0x18],0x0
  10a2ae:	74 07                	je     10a2b7 <isr_handler_page_fault+0xb0>
  10a2b0:	ba 6c 64 10 00       	mov    edx,0x10646c
  10a2b5:	eb 05                	jmp    10a2bc <isr_handler_page_fault+0xb5>
  10a2b7:	ba 82 64 10 00       	mov    edx,0x106482
  10a2bc:	48 83 7d f0 00       	cmp    QWORD PTR [rbp-0x10],0x0
  10a2c1:	74 07                	je     10a2ca <isr_handler_page_fault+0xc3>
  10a2c3:	b8 98 64 10 00       	mov    eax,0x106498
  10a2c8:	eb 05                	jmp    10a2cf <isr_handler_page_fault+0xc8>
  10a2ca:	b8 b9 64 10 00       	mov    eax,0x1064b9
  10a2cf:	ff 75 f8             	push   QWORD PTR [rbp-0x8]
  10a2d2:	51                   	push   rcx
  10a2d3:	49 89 f9             	mov    r9,rdi
  10a2d6:	49 89 f0             	mov    r8,rsi
  10a2d9:	48 89 d1             	mov    rcx,rdx
  10a2dc:	48 89 c2             	mov    rdx,rax
  10a2df:	be d0 64 10 00       	mov    esi,0x1064d0
  10a2e4:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a2e9:	b8 00 00 00 00       	mov    eax,0x0
  10a2ee:	e8 74 29 00 00       	call   10cc67 <klog_write_fmt>
  10a2f3:	48 83 c4 10          	add    rsp,0x10
    (is_write_else_read ? "cause by page write, " : "caused by page read, "),
    (is_usermode_else_kernel ? "happened in user-mode, " : "happened in kernel-mode, "),
    (is_reserved_bit_overwritten ? "a reserved bit was overrwriten, " : "reserved bits are fine, "),
    (is_instruction_else_data ? "caused by instruction fetch" : "caused by data access"),
    (faulting_address));
  kdebug_log_virtual_address_info_2MB(faulting_address);
  10a2f7:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a2fb:	48 89 c7             	mov    rdi,rax
  10a2fe:	e8 03 17 00 00       	call   10ba06 <kdebug_log_virtual_address_info_2MB>

	if (is_usermode_else_kernel == false) {
  10a303:	48 83 7d e0 00       	cmp    QWORD PTR [rbp-0x20],0x0
  10a308:	75 18                	jne    10a322 <isr_handler_page_fault+0x11b>
		//This is a serious bug there should never be a page-fault in the kernel
		//TODO(Torin) Need better painic mechanisim that handles this sort of thing manualy
		//and mabye drops back into real mode to go back to old-school vga text buffer and
		//does a blue-screen of death type of deal to insure that the error is reported properly

    kdebug_log_page_info();
  10a30a:	b8 00 00 00 00       	mov    eax,0x0
  10a30f:	e8 54 18 00 00       	call   10bb68 <kdebug_log_page_info>
    kpanic();
  10a314:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a319:	e8 00 f3 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10a31e:	fa                   	cli    
  10a31f:	f4                   	hlt    
	} else {
		//TODO(TORIN) This was the userspace application lets kill it
    klog_error("UNHANDLED USERSPACE VIOLATION!!!");
    kpanic();
	}
  10a320:	eb 20                	jmp    10a342 <isr_handler_page_fault+0x13b>
    klog_error("UNHANDLED USERSPACE VIOLATION!!!");
  10a322:	be 00 65 10 00       	mov    esi,0x106500
  10a327:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a32c:	b8 00 00 00 00       	mov    eax,0x0
  10a331:	e8 31 29 00 00       	call   10cc67 <klog_write_fmt>
    kpanic();
  10a336:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a33b:	e8 de f2 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10a340:	fa                   	cli    
  10a341:	f4                   	hlt    
  10a342:	90                   	nop
  10a343:	c9                   	leave  
  10a344:	c3                   	ret    

000000000010a345 <legacy_pic8259_initalize>:
static const uint8_t TEST_PROGRAM_ELF[] = {
#include "test_program.txt" 
};

static void
legacy_pic8259_initalize(void) {
  10a345:	55                   	push   rbp
  10a346:	48 89 e5             	mov    rbp,rsp
	static const uint8_t ICW3_PIC1_IRQ_LINE_2 = 0x4;
	static const uint8_t ICW3_PIC2_IRQ_LINE_2 = 0x2;
	static const uint8_t ICW4_8068 = 0x01;

	//ICW1 Tells PIC to wait for 3 more words
	write_port_uint8(PIC1_COMMAND_PORT, ICW1_INIT_CASCADED);
  10a349:	0f b6 05 b8 de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdeb8]        # 108208 <ICW1_INIT_CASCADED.4530>
  10a350:	0f b6 d0             	movzx  edx,al
  10a353:	0f b6 05 af de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdeaf]        # 108209 <PIC1_COMMAND_PORT.4526>
  10a35a:	0f b6 c0             	movzx  eax,al
  10a35d:	89 d6                	mov    esi,edx
  10a35f:	89 c7                	mov    edi,eax
  10a361:	e8 a3 ee ff ff       	call   109209 <write_port_uint8>
	write_port_uint8(PIC2_COMMAND_PORT, ICW1_INIT_CASCADED);
  10a366:	0f b6 05 9b de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffde9b]        # 108208 <ICW1_INIT_CASCADED.4530>
  10a36d:	0f b6 d0             	movzx  edx,al
  10a370:	0f b6 05 93 de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffde93]        # 10820a <PIC2_COMMAND_PORT.4527>
  10a377:	0f b6 c0             	movzx  eax,al
  10a37a:	89 d6                	mov    esi,edx
  10a37c:	89 c7                	mov    edi,eax
  10a37e:	e8 86 ee ff ff       	call   109209 <write_port_uint8>
	//ICW2 Set PIC Offset Values
	write_port_uint8(PIC1_DATA_PORT, ICW2_PIC1_IRQ_NUMBER_BEGIN);
  10a383:	0f b6 05 81 de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffde81]        # 10820b <ICW2_PIC1_IRQ_NUMBER_BEGIN.4531>
  10a38a:	0f b6 d0             	movzx  edx,al
  10a38d:	0f b6 05 78 de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffde78]        # 10820c <PIC1_DATA_PORT.4528>
  10a394:	0f b6 c0             	movzx  eax,al
  10a397:	89 d6                	mov    esi,edx
  10a399:	89 c7                	mov    edi,eax
  10a39b:	e8 69 ee ff ff       	call   109209 <write_port_uint8>
	write_port_uint8(PIC2_DATA_PORT, ICW2_PIC2_IRQ_NUMBER_BEGIN);
  10a3a0:	0f b6 05 66 de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffde66]        # 10820d <ICW2_PIC2_IRQ_NUMBER_BEGIN.4532>
  10a3a7:	0f b6 d0             	movzx  edx,al
  10a3aa:	0f b6 05 5d de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffde5d]        # 10820e <PIC2_DATA_PORT.4529>
  10a3b1:	0f b6 c0             	movzx  eax,al
  10a3b4:	89 d6                	mov    esi,edx
  10a3b6:	89 c7                	mov    edi,eax
  10a3b8:	e8 4c ee ff ff       	call   109209 <write_port_uint8>
	//ICW3 PIC Cascading Info
	write_port_uint8(PIC1_DATA_PORT, ICW3_PIC1_IRQ_LINE_2);
  10a3bd:	0f b6 05 4b de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffde4b]        # 10820f <ICW3_PIC1_IRQ_LINE_2.4533>
  10a3c4:	0f b6 d0             	movzx  edx,al
  10a3c7:	0f b6 05 3e de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffde3e]        # 10820c <PIC1_DATA_PORT.4528>
  10a3ce:	0f b6 c0             	movzx  eax,al
  10a3d1:	89 d6                	mov    esi,edx
  10a3d3:	89 c7                	mov    edi,eax
  10a3d5:	e8 2f ee ff ff       	call   109209 <write_port_uint8>
	write_port_uint8(PIC2_DATA_PORT, ICW3_PIC2_IRQ_LINE_2);
  10a3da:	0f b6 05 2f de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffde2f]        # 108210 <ICW3_PIC2_IRQ_LINE_2.4534>
  10a3e1:	0f b6 d0             	movzx  edx,al
  10a3e4:	0f b6 05 23 de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffde23]        # 10820e <PIC2_DATA_PORT.4529>
  10a3eb:	0f b6 c0             	movzx  eax,al
  10a3ee:	89 d6                	mov    esi,edx
  10a3f0:	89 c7                	mov    edi,eax
  10a3f2:	e8 12 ee ff ff       	call   109209 <write_port_uint8>
	//ICW4 Additional Enviroment Info
	//NOTE(Torin) Currently set to 80x86
	write_port_uint8(PIC1_DATA_PORT, ICW4_8068);
  10a3f7:	0f b6 05 13 de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffde13]        # 108211 <ICW4_8068.4535>
  10a3fe:	0f b6 d0             	movzx  edx,al
  10a401:	0f b6 05 04 de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffde04]        # 10820c <PIC1_DATA_PORT.4528>
  10a408:	0f b6 c0             	movzx  eax,al
  10a40b:	89 d6                	mov    esi,edx
  10a40d:	89 c7                	mov    edi,eax
  10a40f:	e8 f5 ed ff ff       	call   109209 <write_port_uint8>
	write_port_uint8(PIC2_DATA_PORT, ICW4_8068);
  10a414:	0f b6 05 f6 dd ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffddf6]        # 108211 <ICW4_8068.4535>
  10a41b:	0f b6 d0             	movzx  edx,al
  10a41e:	0f b6 05 e9 dd ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdde9]        # 10820e <PIC2_DATA_PORT.4529>
  10a425:	0f b6 c0             	movzx  eax,al
  10a428:	89 d6                	mov    esi,edx
  10a42a:	89 c7                	mov    edi,eax
  10a42c:	e8 d8 ed ff ff       	call   109209 <write_port_uint8>

  //Write EndOfInterupt and set interrupt enabled mask 
	write_port_uint8(PIC1_DATA_PORT, 0x20);
  10a431:	0f b6 05 d4 dd ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffddd4]        # 10820c <PIC1_DATA_PORT.4528>
  10a438:	0f b6 c0             	movzx  eax,al
  10a43b:	be 20 00 00 00       	mov    esi,0x20
  10a440:	89 c7                	mov    edi,eax
  10a442:	e8 c2 ed ff ff       	call   109209 <write_port_uint8>
	write_port_uint8(PIC2_DATA_PORT, 0x20);
  10a447:	0f b6 05 c0 dd ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffddc0]        # 10820e <PIC2_DATA_PORT.4529>
  10a44e:	0f b6 c0             	movzx  eax,al
  10a451:	be 20 00 00 00       	mov    esi,0x20
  10a456:	89 c7                	mov    edi,eax
  10a458:	e8 ac ed ff ff       	call   109209 <write_port_uint8>
	write_port_uint8(PIC1_DATA_PORT, 0b11111101);
  10a45d:	0f b6 05 a8 dd ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdda8]        # 10820c <PIC1_DATA_PORT.4528>
  10a464:	0f b6 c0             	movzx  eax,al
  10a467:	be fd 00 00 00       	mov    esi,0xfd
  10a46c:	89 c7                	mov    edi,eax
  10a46e:	e8 96 ed ff ff       	call   109209 <write_port_uint8>
	write_port_uint8(PIC2_DATA_PORT, 0b11111111);
  10a473:	0f b6 05 94 dd ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdd94]        # 10820e <PIC2_DATA_PORT.4529>
  10a47a:	0f b6 c0             	movzx  eax,al
  10a47d:	be ff 00 00 00       	mov    esi,0xff
  10a482:	89 c7                	mov    edi,eax
  10a484:	e8 80 ed ff ff       	call   109209 <write_port_uint8>
	klog_info("PIC8259 Initialized");
  10a489:	be d8 6a 10 00       	mov    esi,0x106ad8
  10a48e:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a493:	b8 00 00 00 00       	mov    eax,0x0
  10a498:	e8 ca 27 00 00       	call   10cc67 <klog_write_fmt>
}
  10a49d:	90                   	nop
  10a49e:	5d                   	pop    rbp
  10a49f:	c3                   	ret    

000000000010a4a0 <idt_install_interrupt>:
}
#endif

//TODO(Torin) Remove IDT Global variable
static void
idt_install_interrupt(const uint32_t irq_number, const uint64_t irq_handler_addr) {
  10a4a0:	55                   	push   rbp
  10a4a1:	48 89 e5             	mov    rbp,rsp
  10a4a4:	48 83 ec 10          	sub    rsp,0x10
  10a4a8:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
  10a4ab:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
	
	static const uint64_t TYPE_TASK_GATE_64 = 0x5;
	static const uint64_t TYPE_INTERRUPT_GATE_64 = 0xE;
	static const uint64_t TYPE_TRAP_GATE_64 = 0xF;

	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10a4af:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10a4b3:	89 c2                	mov    edx,eax
  10a4b5:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a4b8:	48 c1 e0 04          	shl    rax,0x4
  10a4bc:	48 05 00 e8 11 00    	add    rax,0x11e800
  10a4c2:	66 89 10             	mov    WORD PTR [rax],dx
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10a4c5:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10a4c9:	48 c1 e8 10          	shr    rax,0x10
  10a4cd:	89 c2                	mov    edx,eax
  10a4cf:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a4d2:	48 c1 e0 04          	shl    rax,0x4
  10a4d6:	48 05 06 e8 11 00    	add    rax,0x11e806
  10a4dc:	66 89 10             	mov    WORD PTR [rax],dx
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10a4df:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10a4e3:	48 c1 e8 20          	shr    rax,0x20
  10a4e7:	89 c2                	mov    edx,eax
  10a4e9:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a4ec:	48 c1 e0 04          	shl    rax,0x4
  10a4f0:	48 05 08 e8 11 00    	add    rax,0x11e808
  10a4f6:	89 10                	mov    DWORD PTR [rax],edx
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10a4f8:	48 8b 05 19 dd ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffdd19]        # 108218 <PRESENT_BIT.4542>
  10a4ff:	89 c2                	mov    edx,eax
  10a501:	48 8b 05 18 dd ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffdd18]        # 108220 <TYPE_INTERRUPT_GATE_64.4544>
  10a508:	09 c2                	or     edx,eax
  10a50a:	48 8b 05 17 dd ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffdd17]        # 108228 <PRIVILEGE_LEVEL_0.4540>
  10a511:	09 c2                	or     edx,eax
  10a513:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a516:	48 c1 e0 04          	shl    rax,0x4
  10a51a:	48 05 05 e8 11 00    	add    rax,0x11e805
  10a520:	88 10                	mov    BYTE PTR [rax],dl
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10a522:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a525:	48 c1 e0 04          	shl    rax,0x4
  10a529:	48 05 02 e8 11 00    	add    rax,0x11e802
  10a52f:	66 c7 00 18 00       	mov    WORD PTR [rax],0x18
	_idt[irq_number].ist = 0;
  10a534:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a537:	48 c1 e0 04          	shl    rax,0x4
  10a53b:	48 05 04 e8 11 00    	add    rax,0x11e804
  10a541:	c6 00 00             	mov    BYTE PTR [rax],0x0
}
  10a544:	90                   	nop
  10a545:	c9                   	leave  
  10a546:	c3                   	ret    

000000000010a547 <x86_64_idt_initalize>:

static void
x86_64_idt_initalize(){
  10a547:	55                   	push   rbp
  10a548:	48 89 e5             	mov    rbp,rsp
  10a54b:	48 83 ec 10          	sub    rsp,0x10
  extern void asm_double_fault_handler();
  extern void asm_debug_handler();
  
	for (uint32_t i = 0; i < 256; i++) {
  10a54f:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
  10a556:	eb 25                	jmp    10a57d <x86_64_idt_initalize+0x36>
		idt_install_interrupt(i, (uintptr_t)asm_debug_handler);
  10a558:	ba 15 d3 10 00       	mov    edx,0x10d315
  10a55d:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a560:	48 89 d6             	mov    rsi,rdx
  10a563:	89 c7                	mov    edi,eax
  10a565:	e8 36 ff ff ff       	call   10a4a0 <idt_install_interrupt>
		_interrupt_handlers[i] = 0x00;
  10a56a:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a56d:	48 c7 04 c5 00 f8 11 	mov    QWORD PTR [rax*8+0x11f800],0x0
  10a574:	00 00 00 00 00 
	for (uint32_t i = 0; i < 256; i++) {
  10a579:	83 45 fc 01          	add    DWORD PTR [rbp-0x4],0x1
  10a57d:	81 7d fc ff 00 00 00 	cmp    DWORD PTR [rbp-0x4],0xff
  10a584:	76 d2                	jbe    10a558 <x86_64_idt_initalize+0x11>
		extern void asm_isr28(void);
		extern void asm_isr29(void);
		extern void asm_isr30(void);
		extern void asm_isr31(void);

		idt_install_interrupt(0, (uintptr_t)asm_isr0);
  10a586:	b8 6c d3 10 00       	mov    eax,0x10d36c
  10a58b:	48 89 c6             	mov    rsi,rax
  10a58e:	bf 00 00 00 00       	mov    edi,0x0
  10a593:	e8 08 ff ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(1, (uintptr_t)asm_isr1);
  10a598:	b8 73 d3 10 00       	mov    eax,0x10d373
  10a59d:	48 89 c6             	mov    rsi,rax
  10a5a0:	bf 01 00 00 00       	mov    edi,0x1
  10a5a5:	e8 f6 fe ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(2, (uintptr_t)asm_isr2);
  10a5aa:	b8 7a d3 10 00       	mov    eax,0x10d37a
  10a5af:	48 89 c6             	mov    rsi,rax
  10a5b2:	bf 02 00 00 00       	mov    edi,0x2
  10a5b7:	e8 e4 fe ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(3, (uintptr_t)asm_isr3);
  10a5bc:	b8 81 d3 10 00       	mov    eax,0x10d381
  10a5c1:	48 89 c6             	mov    rsi,rax
  10a5c4:	bf 03 00 00 00       	mov    edi,0x3
  10a5c9:	e8 d2 fe ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(4, (uintptr_t)asm_isr4);
  10a5ce:	b8 88 d3 10 00       	mov    eax,0x10d388
  10a5d3:	48 89 c6             	mov    rsi,rax
  10a5d6:	bf 04 00 00 00       	mov    edi,0x4
  10a5db:	e8 c0 fe ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(5, (uintptr_t)asm_isr5);
  10a5e0:	b8 8f d3 10 00       	mov    eax,0x10d38f
  10a5e5:	48 89 c6             	mov    rsi,rax
  10a5e8:	bf 05 00 00 00       	mov    edi,0x5
  10a5ed:	e8 ae fe ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(6, (uintptr_t)asm_isr6);
  10a5f2:	b8 96 d3 10 00       	mov    eax,0x10d396
  10a5f7:	48 89 c6             	mov    rsi,rax
  10a5fa:	bf 06 00 00 00       	mov    edi,0x6
  10a5ff:	e8 9c fe ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(7, (uintptr_t)asm_isr7);
  10a604:	b8 9d d3 10 00       	mov    eax,0x10d39d
  10a609:	48 89 c6             	mov    rsi,rax
  10a60c:	bf 07 00 00 00       	mov    edi,0x7
  10a611:	e8 8a fe ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(8, (uintptr_t)asm_double_fault_handler);
  10a616:	b8 f0 d2 10 00       	mov    eax,0x10d2f0
  10a61b:	48 89 c6             	mov    rsi,rax
  10a61e:	bf 08 00 00 00       	mov    edi,0x8
  10a623:	e8 78 fe ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(9, (uintptr_t)asm_isr9);
  10a628:	b8 a9 d3 10 00       	mov    eax,0x10d3a9
  10a62d:	48 89 c6             	mov    rsi,rax
  10a630:	bf 09 00 00 00       	mov    edi,0x9
  10a635:	e8 66 fe ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(10, (uintptr_t)asm_isr10);
  10a63a:	b8 b0 d3 10 00       	mov    eax,0x10d3b0
  10a63f:	48 89 c6             	mov    rsi,rax
  10a642:	bf 0a 00 00 00       	mov    edi,0xa
  10a647:	e8 54 fe ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(11, (uintptr_t)asm_isr11);
  10a64c:	b8 b5 d3 10 00       	mov    eax,0x10d3b5
  10a651:	48 89 c6             	mov    rsi,rax
  10a654:	bf 0b 00 00 00       	mov    edi,0xb
  10a659:	e8 42 fe ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(12, (uintptr_t)asm_isr12);
  10a65e:	b8 ba d3 10 00       	mov    eax,0x10d3ba
  10a663:	48 89 c6             	mov    rsi,rax
  10a666:	bf 0c 00 00 00       	mov    edi,0xc
  10a66b:	e8 30 fe ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(13, (uintptr_t)asm_isr13);
  10a670:	b8 bf d3 10 00       	mov    eax,0x10d3bf
  10a675:	48 89 c6             	mov    rsi,rax
  10a678:	bf 0d 00 00 00       	mov    edi,0xd
  10a67d:	e8 1e fe ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(14, (uintptr_t)asm_isr14);
  10a682:	b8 c4 d3 10 00       	mov    eax,0x10d3c4
  10a687:	48 89 c6             	mov    rsi,rax
  10a68a:	bf 0e 00 00 00       	mov    edi,0xe
  10a68f:	e8 0c fe ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(15, (uintptr_t)asm_isr15);
  10a694:	b8 c9 d3 10 00       	mov    eax,0x10d3c9
  10a699:	48 89 c6             	mov    rsi,rax
  10a69c:	bf 0f 00 00 00       	mov    edi,0xf
  10a6a1:	e8 fa fd ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(16, (uintptr_t)asm_isr16);
  10a6a6:	b8 d3 d3 10 00       	mov    eax,0x10d3d3
  10a6ab:	48 89 c6             	mov    rsi,rax
  10a6ae:	bf 10 00 00 00       	mov    edi,0x10
  10a6b3:	e8 e8 fd ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(17, (uintptr_t)asm_isr17);
  10a6b8:	b8 dd d3 10 00       	mov    eax,0x10d3dd
  10a6bd:	48 89 c6             	mov    rsi,rax
  10a6c0:	bf 11 00 00 00       	mov    edi,0x11
  10a6c5:	e8 d6 fd ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(18, (uintptr_t)asm_isr18);
  10a6ca:	b8 e5 d3 10 00       	mov    eax,0x10d3e5
  10a6cf:	48 89 c6             	mov    rsi,rax
  10a6d2:	bf 12 00 00 00       	mov    edi,0x12
  10a6d7:	e8 c4 fd ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(19, (uintptr_t)asm_isr19);
  10a6dc:	b8 ef d3 10 00       	mov    eax,0x10d3ef
  10a6e1:	48 89 c6             	mov    rsi,rax
  10a6e4:	bf 13 00 00 00       	mov    edi,0x13
  10a6e9:	e8 b2 fd ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(20, (uintptr_t)asm_isr20);
  10a6ee:	b8 f9 d3 10 00       	mov    eax,0x10d3f9
  10a6f3:	48 89 c6             	mov    rsi,rax
  10a6f6:	bf 14 00 00 00       	mov    edi,0x14
  10a6fb:	e8 a0 fd ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(21, (uintptr_t)asm_isr21);
  10a700:	b8 03 d4 10 00       	mov    eax,0x10d403
  10a705:	48 89 c6             	mov    rsi,rax
  10a708:	bf 15 00 00 00       	mov    edi,0x15
  10a70d:	e8 8e fd ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(22, (uintptr_t)asm_isr22);
  10a712:	b8 0d d4 10 00       	mov    eax,0x10d40d
  10a717:	48 89 c6             	mov    rsi,rax
  10a71a:	bf 16 00 00 00       	mov    edi,0x16
  10a71f:	e8 7c fd ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(23, (uintptr_t)asm_isr23);
  10a724:	b8 17 d4 10 00       	mov    eax,0x10d417
  10a729:	48 89 c6             	mov    rsi,rax
  10a72c:	bf 17 00 00 00       	mov    edi,0x17
  10a731:	e8 6a fd ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(24, (uintptr_t)asm_isr24);
  10a736:	b8 21 d4 10 00       	mov    eax,0x10d421
  10a73b:	48 89 c6             	mov    rsi,rax
  10a73e:	bf 18 00 00 00       	mov    edi,0x18
  10a743:	e8 58 fd ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(25, (uintptr_t)asm_isr25);
  10a748:	b8 2b d4 10 00       	mov    eax,0x10d42b
  10a74d:	48 89 c6             	mov    rsi,rax
  10a750:	bf 19 00 00 00       	mov    edi,0x19
  10a755:	e8 46 fd ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(26, (uintptr_t)asm_isr26);
  10a75a:	b8 35 d4 10 00       	mov    eax,0x10d435
  10a75f:	48 89 c6             	mov    rsi,rax
  10a762:	bf 1a 00 00 00       	mov    edi,0x1a
  10a767:	e8 34 fd ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(27, (uintptr_t)asm_isr27);
  10a76c:	b8 3f d4 10 00       	mov    eax,0x10d43f
  10a771:	48 89 c6             	mov    rsi,rax
  10a774:	bf 1b 00 00 00       	mov    edi,0x1b
  10a779:	e8 22 fd ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(28, (uintptr_t)asm_isr28);
  10a77e:	b8 49 d4 10 00       	mov    eax,0x10d449
  10a783:	48 89 c6             	mov    rsi,rax
  10a786:	bf 1c 00 00 00       	mov    edi,0x1c
  10a78b:	e8 10 fd ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(29, (uintptr_t)asm_isr29);
  10a790:	b8 53 d4 10 00       	mov    eax,0x10d453
  10a795:	48 89 c6             	mov    rsi,rax
  10a798:	bf 1d 00 00 00       	mov    edi,0x1d
  10a79d:	e8 fe fc ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(30, (uintptr_t)asm_isr30);
  10a7a2:	b8 5d d4 10 00       	mov    eax,0x10d45d
  10a7a7:	48 89 c6             	mov    rsi,rax
  10a7aa:	bf 1e 00 00 00       	mov    edi,0x1e
  10a7af:	e8 ec fc ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(31, (uintptr_t)asm_isr31);
  10a7b4:	b8 67 d4 10 00       	mov    eax,0x10d467
  10a7b9:	48 89 c6             	mov    rsi,rax
  10a7bc:	bf 1f 00 00 00       	mov    edi,0x1f
  10a7c1:	e8 da fc ff ff       	call   10a4a0 <idt_install_interrupt>
    extern void asm_irq128(void);

    extern void asm_syscall_handler(void);
    extern void asm_spurious_interrupt_handler(void);

		_interrupt_handlers[0] = (uintptr_t)irq_handler_pit;
  10a7c6:	b8 12 c4 10 00       	mov    eax,0x10c412
  10a7cb:	48 89 05 2e 50 01 00 	mov    QWORD PTR [rip+0x1502e],rax        # 11f800 <_interrupt_handlers>
		_interrupt_handlers[1] = (uintptr_t)irq_handler_keyboard;
  10a7d2:	b8 d7 c1 10 00       	mov    eax,0x10c1d7
  10a7d7:	48 89 05 2a 50 01 00 	mov    QWORD PTR [rip+0x1502a],rax        # 11f808 <_interrupt_handlers+0x8>
		idt_install_interrupt(IRQ_PIT, (uintptr_t)asm_irq0);
  10a7de:	ba 71 d4 10 00       	mov    edx,0x10d471
  10a7e3:	8b 05 5f da ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffda5f]        # 108248 <IRQ_PIT.4647>
  10a7e9:	48 89 d6             	mov    rsi,rdx
  10a7ec:	89 c7                	mov    edi,eax
  10a7ee:	e8 ad fc ff ff       	call   10a4a0 <idt_install_interrupt>
		idt_install_interrupt(IRQ_KEYBOARD, (uintptr_t)asm_irq1);
  10a7f3:	ba 79 d4 10 00       	mov    edx,0x10d479
  10a7f8:	8b 05 4e da ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffda4e]        # 10824c <IRQ_KEYBOARD.4648>
  10a7fe:	48 89 d6             	mov    rsi,rdx
  10a801:	89 c7                	mov    edi,eax
  10a803:	e8 98 fc ff ff       	call   10a4a0 <idt_install_interrupt>
    idt_encode_entry((uintptr_t)&_idt[0x80], (uintptr_t)asm_syscall_handler, true);
  10a808:	b9 5e d3 10 00       	mov    ecx,0x10d35e
  10a80d:	b8 00 f0 11 00       	mov    eax,0x11f000
  10a812:	ba 01 00 00 00       	mov    edx,0x1
  10a817:	48 89 ce             	mov    rsi,rcx
  10a81a:	48 89 c7             	mov    rdi,rax
  10a81d:	e8 4f f8 ff ff       	call   10a071 <idt_encode_entry>
    idt_encode_entry((uintptr_t)&_idt[0x31], (uintptr_t)asm_spurious_interrupt_handler, true);
  10a822:	b9 3a d3 10 00       	mov    ecx,0x10d33a
  10a827:	b8 10 eb 11 00       	mov    eax,0x11eb10
  10a82c:	ba 01 00 00 00       	mov    edx,0x1
  10a831:	48 89 ce             	mov    rsi,rcx
  10a834:	48 89 c7             	mov    rdi,rax
  10a837:	e8 35 f8 ff ff       	call   10a071 <idt_encode_entry>
#endif

	struct {
			uint16_t limit;
			uintptr_t address;
	} __attribute__((packed)) idtr = { sizeof(_idt) - 1, (uintptr_t)_idt };
  10a83c:	66 c7 45 f0 ff 0f    	mov    WORD PTR [rbp-0x10],0xfff
  10a842:	b8 00 e8 11 00       	mov    eax,0x11e800
  10a847:	48 89 45 f2          	mov    QWORD PTR [rbp-0xe],rax
	asm volatile ("lidt %0" : : "m"(idtr));
  10a84b:	0f 01 5d f0          	lidt   [rbp-0x10]
	asm volatile ("sti");
  10a84f:	fb                   	sti    
  klog_info("IDT initialized");
  10a850:	be ec 6a 10 00       	mov    esi,0x106aec
  10a855:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a85a:	b8 00 00 00 00       	mov    eax,0x0
  10a85f:	e8 03 24 00 00       	call   10cc67 <klog_write_fmt>
}
  10a864:	90                   	nop
  10a865:	c9                   	leave  
  10a866:	c3                   	ret    

000000000010a867 <serial_debug_init>:

#define HW_SERIAL_DIVISOR_LATCH_ACCESS_BIT (1 << 7)

#define PORT 0x3F8
void serial_debug_init() 
{
  10a867:	55                   	push   rbp
  10a868:	48 89 e5             	mov    rbp,rsp
   write_port_uint8(PORT + 1, 0x00);    // Disable all interrupts
  10a86b:	be 00 00 00 00       	mov    esi,0x0
  10a870:	bf f9 03 00 00       	mov    edi,0x3f9
  10a875:	e8 8f e9 ff ff       	call   109209 <write_port_uint8>
   write_port_uint8(PORT + 3, 0x80);    // Enable DLAB (set baud rate divisor)
  10a87a:	be 80 00 00 00       	mov    esi,0x80
  10a87f:	bf fb 03 00 00       	mov    edi,0x3fb
  10a884:	e8 80 e9 ff ff       	call   109209 <write_port_uint8>
   write_port_uint8(PORT + 0, 0x01);    // Set divisor to 3 (lo byte) 38400 baud
  10a889:	be 01 00 00 00       	mov    esi,0x1
  10a88e:	bf f8 03 00 00       	mov    edi,0x3f8
  10a893:	e8 71 e9 ff ff       	call   109209 <write_port_uint8>
   write_port_uint8(PORT + 1, 0x00);    //                  (hi byte)
  10a898:	be 00 00 00 00       	mov    esi,0x0
  10a89d:	bf f9 03 00 00       	mov    edi,0x3f9
  10a8a2:	e8 62 e9 ff ff       	call   109209 <write_port_uint8>
   write_port_uint8(PORT + 3, 0x03);    // 8 bits, no parity, one stop bit
  10a8a7:	be 03 00 00 00       	mov    esi,0x3
  10a8ac:	bf fb 03 00 00       	mov    edi,0x3fb
  10a8b1:	e8 53 e9 ff ff       	call   109209 <write_port_uint8>
   write_port_uint8(PORT + 2, 0xC7);    // Enable FIFO, clear them, with 14-byte threshold
  10a8b6:	be c7 00 00 00       	mov    esi,0xc7
  10a8bb:	bf fa 03 00 00       	mov    edi,0x3fa
  10a8c0:	e8 44 e9 ff ff       	call   109209 <write_port_uint8>
   write_port_uint8(PORT + 4, 0x0B);    // IRQs enabled, RTS/DSR set
  10a8c5:	be 0b 00 00 00       	mov    esi,0xb
  10a8ca:	bf fc 03 00 00       	mov    edi,0x3fc
  10a8cf:	e8 35 e9 ff ff       	call   109209 <write_port_uint8>
}
  10a8d4:	90                   	nop
  10a8d5:	5d                   	pop    rbp
  10a8d6:	c3                   	ret    

000000000010a8d7 <is_transmit_empty>:

int is_transmit_empty() {
  10a8d7:	55                   	push   rbp
  10a8d8:	48 89 e5             	mov    rbp,rsp
   return read_port_uint8(PORT + 5) & 0x20;
  10a8db:	bf fd 03 00 00       	mov    edi,0x3fd
  10a8e0:	e8 43 e9 ff ff       	call   109228 <read_port_uint8>
  10a8e5:	0f b6 c0             	movzx  eax,al
  10a8e8:	83 e0 20             	and    eax,0x20
}
  10a8eb:	5d                   	pop    rbp
  10a8ec:	c3                   	ret    

000000000010a8ed <write_serial>:
   while (is_transmit_empty() == 0);
   write_port(PORT,a);
}
#endif

void write_serial(const char *src, size_t length){
  10a8ed:	55                   	push   rbp
  10a8ee:	48 89 e5             	mov    rbp,rsp
  10a8f1:	48 83 ec 20          	sub    rsp,0x20
  10a8f5:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10a8f9:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  for(size_t i = 0; i < length; i++){
  10a8fd:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10a904:	00 
  10a905:	eb 31                	jmp    10a938 <write_serial+0x4b>
    while(is_transmit_empty() == 0) {}
  10a907:	90                   	nop
  10a908:	b8 00 00 00 00       	mov    eax,0x0
  10a90d:	e8 c5 ff ff ff       	call   10a8d7 <is_transmit_empty>
  10a912:	85 c0                	test   eax,eax
  10a914:	74 f2                	je     10a908 <write_serial+0x1b>
    write_port_uint8(PORT, src[i]);
  10a916:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  10a91a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a91e:	48 01 d0             	add    rax,rdx
  10a921:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10a924:	0f b6 c0             	movzx  eax,al
  10a927:	89 c6                	mov    esi,eax
  10a929:	bf f8 03 00 00       	mov    edi,0x3f8
  10a92e:	e8 d6 e8 ff ff       	call   109209 <write_port_uint8>
  for(size_t i = 0; i < length; i++){
  10a933:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10a938:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a93c:	48 3b 45 e0          	cmp    rax,QWORD PTR [rbp-0x20]
  10a940:	72 c5                	jb     10a907 <write_serial+0x1a>
  }
}
  10a942:	90                   	nop
  10a943:	c9                   	leave  
  10a944:	c3                   	ret    

000000000010a945 <kmem_map_physical_to_virtual_2MB_ext>:
static const uint64_t PAGE_GLOBAL_BIT             = 1L << 8;
static const uint64_t PAGE_NO_EXECUTE_BIT         = 1L << 63;

//=============================================================================================

void kmem_map_physical_to_virtual_2MB_ext(uintptr_t physical_address, uintptr_t virtual_address, uint64_t flags){
  10a945:	55                   	push   rbp
  10a946:	48 89 e5             	mov    rbp,rsp
  10a949:	48 83 ec 50          	sub    rsp,0x50
  10a94d:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  10a951:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  10a955:	48 89 55 b8          	mov    QWORD PTR [rbp-0x48],rdx
  kassert((virtual_address & 0x1FFFFF) == 0);
  10a959:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10a95d:	25 ff ff 1f 00       	and    eax,0x1fffff
  10a962:	48 85 c0             	test   rax,rax
  10a965:	74 30                	je     10a997 <kmem_map_physical_to_virtual_2MB_ext+0x52>
  10a967:	41 b8 50 6b 10 00    	mov    r8d,0x106b50
  10a96d:	b9 26 00 00 00       	mov    ecx,0x26
  10a972:	ba 68 6b 10 00       	mov    edx,0x106b68
  10a977:	be 38 61 10 00       	mov    esi,0x106138
  10a97c:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a981:	b8 00 00 00 00       	mov    eax,0x0
  10a986:	e8 dc 22 00 00       	call   10cc67 <klog_write_fmt>
  10a98b:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a990:	e8 89 ec ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10a995:	fa                   	cli    
  10a996:	f4                   	hlt    
  kassert((physical_address & 0x1FFFFF) == 0);
  10a997:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  10a99b:	25 ff ff 1f 00       	and    eax,0x1fffff
  10a9a0:	48 85 c0             	test   rax,rax
  10a9a3:	74 30                	je     10a9d5 <kmem_map_physical_to_virtual_2MB_ext+0x90>
  10a9a5:	41 b8 50 6b 10 00    	mov    r8d,0x106b50
  10a9ab:	b9 27 00 00 00       	mov    ecx,0x27
  10a9b0:	ba 90 6b 10 00       	mov    edx,0x106b90
  10a9b5:	be 38 61 10 00       	mov    esi,0x106138
  10a9ba:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a9bf:	b8 00 00 00 00       	mov    eax,0x0
  10a9c4:	e8 9e 22 00 00       	call   10cc67 <klog_write_fmt>
  10a9c9:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a9ce:	e8 4b ec ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10a9d3:	fa                   	cli    
  10a9d4:	f4                   	hlt    
  uintptr_t p4_index = (virtual_address >> 39) & 0x1FF;
  10a9d5:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10a9d9:	48 c1 e8 27          	shr    rax,0x27
  10a9dd:	25 ff 01 00 00       	and    eax,0x1ff
  10a9e2:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  uintptr_t p3_index = (virtual_address >> 30) & 0x1FF;
  10a9e6:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10a9ea:	48 c1 e8 1e          	shr    rax,0x1e
  10a9ee:	25 ff 01 00 00       	and    eax,0x1ff
  10a9f3:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
  uintptr_t p2_index = (virtual_address >> 21) & 0x1FF;
  10a9f7:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10a9fb:	48 c1 e8 15          	shr    rax,0x15
  10a9ff:	25 ff 01 00 00       	and    eax,0x1ff
  10aa04:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
  PageTable *p4_table = (PageTable *)&g_p4_table;
  10aa08:	48 c7 45 e0 00 20 12 	mov    QWORD PTR [rbp-0x20],0x122000
  10aa0f:	00 
  PageTable *p3_table = (PageTable *)p4_table->entries[p4_index]; 
  10aa10:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10aa14:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10aa18:	48 8b 04 d0          	mov    rax,QWORD PTR [rax+rdx*8]
  10aa1c:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
  PageTable *p2_table = (PageTable *)p3_table->entries[p3_index];
  10aa20:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10aa24:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  10aa28:	48 8b 04 d0          	mov    rax,QWORD PTR [rax+rdx*8]
  10aa2c:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
  g_p2_table.entries[p2_index] = physical_address | PAGE_PRESENT_BIT | PAGE_HUGE_BIT | PAGE_WRITEABLE_BIT | flags;
  10aa30:	b8 01 00 00 00       	mov    eax,0x1
  10aa35:	48 0b 45 c8          	or     rax,QWORD PTR [rbp-0x38]
  10aa39:	ba 80 00 00 00       	mov    edx,0x80
  10aa3e:	48 09 d0             	or     rax,rdx
  10aa41:	ba 02 00 00 00       	mov    edx,0x2
  10aa46:	48 09 d0             	or     rax,rdx
  10aa49:	48 0b 45 b8          	or     rax,QWORD PTR [rbp-0x48]
  10aa4d:	48 89 c2             	mov    rdx,rax
  10aa50:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10aa54:	48 89 14 c5 00 40 12 	mov    QWORD PTR [rax*8+0x124000],rdx
  10aa5b:	00 
}
  10aa5c:	90                   	nop
  10aa5d:	c9                   	leave  
  10aa5e:	c3                   	ret    

000000000010aa5f <kmem_map_physical_to_virtual_2MB>:

void kmem_map_physical_to_virtual_2MB(uintptr_t physical_address, uintptr_t virtual_address){
  10aa5f:	55                   	push   rbp
  10aa60:	48 89 e5             	mov    rbp,rsp
  10aa63:	48 83 ec 30          	sub    rsp,0x30
  10aa67:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  10aa6b:	48 89 75 d0          	mov    QWORD PTR [rbp-0x30],rsi
  kassert((virtual_address & 0x1FFFFF) == 0);
  10aa6f:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10aa73:	25 ff ff 1f 00       	and    eax,0x1fffff
  10aa78:	48 85 c0             	test   rax,rax
  10aa7b:	74 30                	je     10aaad <kmem_map_physical_to_virtual_2MB+0x4e>
  10aa7d:	41 b8 50 6b 10 00    	mov    r8d,0x106b50
  10aa83:	b9 32 00 00 00       	mov    ecx,0x32
  10aa88:	ba 68 6b 10 00       	mov    edx,0x106b68
  10aa8d:	be 38 61 10 00       	mov    esi,0x106138
  10aa92:	bf 00 e0 10 00       	mov    edi,0x10e000
  10aa97:	b8 00 00 00 00       	mov    eax,0x0
  10aa9c:	e8 c6 21 00 00       	call   10cc67 <klog_write_fmt>
  10aaa1:	bf 00 e0 10 00       	mov    edi,0x10e000
  10aaa6:	e8 73 eb ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10aaab:	fa                   	cli    
  10aaac:	f4                   	hlt    
  kassert((physical_address & 0x1FFFFF) == 0);
  10aaad:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10aab1:	25 ff ff 1f 00       	and    eax,0x1fffff
  10aab6:	48 85 c0             	test   rax,rax
  10aab9:	74 30                	je     10aaeb <kmem_map_physical_to_virtual_2MB+0x8c>
  10aabb:	41 b8 50 6b 10 00    	mov    r8d,0x106b50
  10aac1:	b9 33 00 00 00       	mov    ecx,0x33
  10aac6:	ba 90 6b 10 00       	mov    edx,0x106b90
  10aacb:	be 38 61 10 00       	mov    esi,0x106138
  10aad0:	bf 00 e0 10 00       	mov    edi,0x10e000
  10aad5:	b8 00 00 00 00       	mov    eax,0x0
  10aada:	e8 88 21 00 00       	call   10cc67 <klog_write_fmt>
  10aadf:	bf 00 e0 10 00       	mov    edi,0x10e000
  10aae4:	e8 35 eb ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10aae9:	fa                   	cli    
  10aaea:	f4                   	hlt    
  uintptr_t p4_index = (virtual_address >> 39) & 0x1FF;
  10aaeb:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10aaef:	48 c1 e8 27          	shr    rax,0x27
  10aaf3:	25 ff 01 00 00       	and    eax,0x1ff
  10aaf8:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  uintptr_t p3_index = (virtual_address >> 30) & 0x1FF;
  10aafc:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10ab00:	48 c1 e8 1e          	shr    rax,0x1e
  10ab04:	25 ff 01 00 00       	and    eax,0x1ff
  10ab09:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
  uintptr_t p2_index = (virtual_address >> 21) & 0x1FF;
  10ab0d:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10ab11:	48 c1 e8 15          	shr    rax,0x15
  10ab15:	25 ff 01 00 00       	and    eax,0x1ff
  10ab1a:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
  kassert(p4_index == 0 && p3_index == 0);
  10ab1e:	48 83 7d f8 00       	cmp    QWORD PTR [rbp-0x8],0x0
  10ab23:	75 07                	jne    10ab2c <kmem_map_physical_to_virtual_2MB+0xcd>
  10ab25:	48 83 7d f0 00       	cmp    QWORD PTR [rbp-0x10],0x0
  10ab2a:	74 30                	je     10ab5c <kmem_map_physical_to_virtual_2MB+0xfd>
  10ab2c:	41 b8 50 6b 10 00    	mov    r8d,0x106b50
  10ab32:	b9 37 00 00 00       	mov    ecx,0x37
  10ab37:	ba b8 6b 10 00       	mov    edx,0x106bb8
  10ab3c:	be 38 61 10 00       	mov    esi,0x106138
  10ab41:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ab46:	b8 00 00 00 00       	mov    eax,0x0
  10ab4b:	e8 17 21 00 00       	call   10cc67 <klog_write_fmt>
  10ab50:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ab55:	e8 c4 ea ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10ab5a:	fa                   	cli    
  10ab5b:	f4                   	hlt    
  kassert(g_p2_table.entries[p2_index] == 0);
  10ab5c:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10ab60:	48 8b 04 c5 00 40 12 	mov    rax,QWORD PTR [rax*8+0x124000]
  10ab67:	00 
  10ab68:	48 85 c0             	test   rax,rax
  10ab6b:	74 30                	je     10ab9d <kmem_map_physical_to_virtual_2MB+0x13e>
  10ab6d:	41 b8 50 6b 10 00    	mov    r8d,0x106b50
  10ab73:	b9 38 00 00 00       	mov    ecx,0x38
  10ab78:	ba d8 6b 10 00       	mov    edx,0x106bd8
  10ab7d:	be 38 61 10 00       	mov    esi,0x106138
  10ab82:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ab87:	b8 00 00 00 00       	mov    eax,0x0
  10ab8c:	e8 d6 20 00 00       	call   10cc67 <klog_write_fmt>
  10ab91:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ab96:	e8 83 ea ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10ab9b:	fa                   	cli    
  10ab9c:	f4                   	hlt    
  g_p2_table.entries[p2_index] = physical_address | PAGE_PRESENT_BIT | PAGE_HUGE_BIT | PAGE_WRITEABLE_BIT;
  10ab9d:	b8 01 00 00 00       	mov    eax,0x1
  10aba2:	48 0b 45 d8          	or     rax,QWORD PTR [rbp-0x28]
  10aba6:	ba 80 00 00 00       	mov    edx,0x80
  10abab:	48 09 d0             	or     rax,rdx
  10abae:	ba 02 00 00 00       	mov    edx,0x2
  10abb3:	48 09 c2             	or     rdx,rax
  10abb6:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10abba:	48 89 14 c5 00 40 12 	mov    QWORD PTR [rax*8+0x124000],rdx
  10abc1:	00 
}
  10abc2:	90                   	nop
  10abc3:	c9                   	leave  
  10abc4:	c3                   	ret    

000000000010abc5 <kmem_map_unaligned_physical_to_aligned_virtual_2MB>:

uintptr_t kmem_map_unaligned_physical_to_aligned_virtual_2MB(uintptr_t requested_physical_address, uintptr_t virtual_address){
  10abc5:	55                   	push   rbp
  10abc6:	48 89 e5             	mov    rbp,rsp
  10abc9:	48 83 ec 20          	sub    rsp,0x20
  10abcd:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10abd1:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  uint64_t physical_address_to_map = requested_physical_address;
  10abd5:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10abd9:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
	uint64_t displacement_from_page_boundray = requested_physical_address & 0x1FFFFF;
  10abdd:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10abe1:	25 ff ff 1f 00       	and    eax,0x1fffff
  10abe6:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
  physical_address_to_map -= displacement_from_page_boundray;
  10abea:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10abee:	48 29 45 f8          	sub    QWORD PTR [rbp-0x8],rax
  kmem_map_physical_to_virtual_2MB(physical_address_to_map, virtual_address);
  10abf2:	48 8b 55 e0          	mov    rdx,QWORD PTR [rbp-0x20]
  10abf6:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10abfa:	48 89 d6             	mov    rsi,rdx
  10abfd:	48 89 c7             	mov    rdi,rax
  10ac00:	e8 5a fe ff ff       	call   10aa5f <kmem_map_physical_to_virtual_2MB>
  return displacement_from_page_boundray;
  10ac05:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
}
  10ac09:	c9                   	leave  
  10ac0a:	c3                   	ret    

000000000010ac0b <kmem_initalize>:

void kmem_initalize(){
  10ac0b:	55                   	push   rbp
  10ac0c:	48 89 e5             	mov    rbp,rsp
  g_p2_table.entries[1] = (uintptr_t)&g_p1_table.entries[0] | PAGE_WRITEABLE_BIT | PAGE_PRESENT_BIT;
  10ac0f:	ba 02 00 00 00       	mov    edx,0x2
  10ac14:	b8 01 00 00 00       	mov    eax,0x1
  10ac19:	48 09 d0             	or     rax,rdx
  10ac1c:	ba 00 10 12 00       	mov    edx,0x121000
  10ac21:	48 09 d0             	or     rax,rdx
  10ac24:	48 89 05 dd 93 01 00 	mov    QWORD PTR [rip+0x193dd],rax        # 124008 <g_p2_table+0x8>
	g_current_page_index = 2;
  10ac2b:	c7 05 cb 53 01 00 02 	mov    DWORD PTR [rip+0x153cb],0x2        # 120000 <g_current_page_index>
  10ac32:	00 00 00 
}
  10ac35:	90                   	nop
  10ac36:	5d                   	pop    rbp
  10ac37:	c3                   	ret    

000000000010ac38 <ap_entry_procedure>:
#include "multiboot2.h"
#include "hardware_serial.c"
#include "kernel_memory.c"

extern void
ap_entry_procedure(void){
  10ac38:	55                   	push   rbp
  10ac39:	48 89 e5             	mov    rbp,rsp
  asm volatile("hlt");
  10ac3c:	f4                   	hlt    
}
  10ac3d:	90                   	nop
  10ac3e:	5d                   	pop    rbp
  10ac3f:	c3                   	ret    

000000000010ac40 <dw_get_tag_string>:
#define _(attrib_name, attrib_value) \
else if (attrib_value == value) { \
  return #attrib_name; \
}

const char *dw_get_tag_string(uint32_t value) {
  10ac40:	55                   	push   rbp
  10ac41:	48 89 e5             	mov    rbp,rsp
  10ac44:	48 83 ec 08          	sub    rsp,0x8
  10ac48:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
  if (0) {} DW_TAG_META_LIST
  10ac4b:	83 7d fc 01          	cmp    DWORD PTR [rbp-0x4],0x1
  10ac4f:	75 0a                	jne    10ac5b <dw_get_tag_string+0x1b>
  10ac51:	b8 d0 6e 10 00       	mov    eax,0x106ed0
  10ac56:	e9 c0 03 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ac5b:	83 7d fc 02          	cmp    DWORD PTR [rbp-0x4],0x2
  10ac5f:	75 0a                	jne    10ac6b <dw_get_tag_string+0x2b>
  10ac61:	b8 e2 6e 10 00       	mov    eax,0x106ee2
  10ac66:	e9 b0 03 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ac6b:	83 7d fc 03          	cmp    DWORD PTR [rbp-0x4],0x3
  10ac6f:	75 0a                	jne    10ac7b <dw_get_tag_string+0x3b>
  10ac71:	b8 f4 6e 10 00       	mov    eax,0x106ef4
  10ac76:	e9 a0 03 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ac7b:	83 7d fc 04          	cmp    DWORD PTR [rbp-0x4],0x4
  10ac7f:	75 0a                	jne    10ac8b <dw_get_tag_string+0x4b>
  10ac81:	b8 07 6f 10 00       	mov    eax,0x106f07
  10ac86:	e9 90 03 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ac8b:	83 7d fc 05          	cmp    DWORD PTR [rbp-0x4],0x5
  10ac8f:	75 0a                	jne    10ac9b <dw_get_tag_string+0x5b>
  10ac91:	b8 1f 6f 10 00       	mov    eax,0x106f1f
  10ac96:	e9 80 03 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ac9b:	83 7d fc 08          	cmp    DWORD PTR [rbp-0x4],0x8
  10ac9f:	75 0a                	jne    10acab <dw_get_tag_string+0x6b>
  10aca1:	b8 37 6f 10 00       	mov    eax,0x106f37
  10aca6:	e9 70 03 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10acab:	83 7d fc 0a          	cmp    DWORD PTR [rbp-0x4],0xa
  10acaf:	75 0a                	jne    10acbb <dw_get_tag_string+0x7b>
  10acb1:	b8 53 6f 10 00       	mov    eax,0x106f53
  10acb6:	e9 60 03 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10acbb:	83 7d fc 0b          	cmp    DWORD PTR [rbp-0x4],0xb
  10acbf:	75 0a                	jne    10accb <dw_get_tag_string+0x8b>
  10acc1:	b8 60 6f 10 00       	mov    eax,0x106f60
  10acc6:	e9 50 03 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10accb:	83 7d fc 0d          	cmp    DWORD PTR [rbp-0x4],0xd
  10accf:	75 0a                	jne    10acdb <dw_get_tag_string+0x9b>
  10acd1:	b8 75 6f 10 00       	mov    eax,0x106f75
  10acd6:	e9 40 03 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10acdb:	83 7d fc 0f          	cmp    DWORD PTR [rbp-0x4],0xf
  10acdf:	75 0a                	jne    10aceb <dw_get_tag_string+0xab>
  10ace1:	b8 83 6f 10 00       	mov    eax,0x106f83
  10ace6:	e9 30 03 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10aceb:	83 7d fc 10          	cmp    DWORD PTR [rbp-0x4],0x10
  10acef:	75 0a                	jne    10acfb <dw_get_tag_string+0xbb>
  10acf1:	b8 97 6f 10 00       	mov    eax,0x106f97
  10acf6:	e9 20 03 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10acfb:	83 7d fc 11          	cmp    DWORD PTR [rbp-0x4],0x11
  10acff:	75 0a                	jne    10ad0b <dw_get_tag_string+0xcb>
  10ad01:	b8 ad 6f 10 00       	mov    eax,0x106fad
  10ad06:	e9 10 03 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ad0b:	83 7d fc 12          	cmp    DWORD PTR [rbp-0x4],0x12
  10ad0f:	75 0a                	jne    10ad1b <dw_get_tag_string+0xdb>
  10ad11:	b8 c1 6f 10 00       	mov    eax,0x106fc1
  10ad16:	e9 00 03 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ad1b:	83 7d fc 13          	cmp    DWORD PTR [rbp-0x4],0x13
  10ad1f:	75 0a                	jne    10ad2b <dw_get_tag_string+0xeb>
  10ad21:	b8 d4 6f 10 00       	mov    eax,0x106fd4
  10ad26:	e9 f0 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ad2b:	83 7d fc 15          	cmp    DWORD PTR [rbp-0x4],0x15
  10ad2f:	75 0a                	jne    10ad3b <dw_get_tag_string+0xfb>
  10ad31:	b8 ea 6f 10 00       	mov    eax,0x106fea
  10ad36:	e9 e0 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ad3b:	83 7d fc 16          	cmp    DWORD PTR [rbp-0x4],0x16
  10ad3f:	75 0a                	jne    10ad4b <dw_get_tag_string+0x10b>
  10ad41:	b8 01 70 10 00       	mov    eax,0x107001
  10ad46:	e9 d0 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ad4b:	83 7d fc 17          	cmp    DWORD PTR [rbp-0x4],0x17
  10ad4f:	75 0a                	jne    10ad5b <dw_get_tag_string+0x11b>
  10ad51:	b8 10 70 10 00       	mov    eax,0x107010
  10ad56:	e9 c0 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ad5b:	83 7d fc 18          	cmp    DWORD PTR [rbp-0x4],0x18
  10ad5f:	75 0a                	jne    10ad6b <dw_get_tag_string+0x12b>
  10ad61:	b8 22 70 10 00       	mov    eax,0x107022
  10ad66:	e9 b0 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ad6b:	83 7d fc 19          	cmp    DWORD PTR [rbp-0x4],0x19
  10ad6f:	75 0a                	jne    10ad7b <dw_get_tag_string+0x13b>
  10ad71:	b8 40 70 10 00       	mov    eax,0x107040
  10ad76:	e9 a0 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ad7b:	83 7d fc 1a          	cmp    DWORD PTR [rbp-0x4],0x1a
  10ad7f:	75 0a                	jne    10ad8b <dw_get_tag_string+0x14b>
  10ad81:	b8 4f 70 10 00       	mov    eax,0x10704f
  10ad86:	e9 90 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ad8b:	83 7d fc 1b          	cmp    DWORD PTR [rbp-0x4],0x1b
  10ad8f:	75 0a                	jne    10ad9b <dw_get_tag_string+0x15b>
  10ad91:	b8 63 70 10 00       	mov    eax,0x107063
  10ad96:	e9 80 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ad9b:	83 7d fc 1c          	cmp    DWORD PTR [rbp-0x4],0x1c
  10ad9f:	75 0a                	jne    10adab <dw_get_tag_string+0x16b>
  10ada1:	b8 7b 70 10 00       	mov    eax,0x10707b
  10ada6:	e9 70 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10adab:	83 7d fc 1d          	cmp    DWORD PTR [rbp-0x4],0x1d
  10adaf:	75 0a                	jne    10adbb <dw_get_tag_string+0x17b>
  10adb1:	b8 8e 70 10 00       	mov    eax,0x10708e
  10adb6:	e9 60 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10adbb:	83 7d fc 1e          	cmp    DWORD PTR [rbp-0x4],0x1e
  10adbf:	75 0a                	jne    10adcb <dw_get_tag_string+0x18b>
  10adc1:	b8 a8 70 10 00       	mov    eax,0x1070a8
  10adc6:	e9 50 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10adcb:	83 7d fc 1f          	cmp    DWORD PTR [rbp-0x4],0x1f
  10adcf:	75 0a                	jne    10addb <dw_get_tag_string+0x19b>
  10add1:	b8 b6 70 10 00       	mov    eax,0x1070b6
  10add6:	e9 40 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10addb:	83 7d fc 20          	cmp    DWORD PTR [rbp-0x4],0x20
  10addf:	75 0a                	jne    10adeb <dw_get_tag_string+0x1ab>
  10ade1:	b8 d0 70 10 00       	mov    eax,0x1070d0
  10ade6:	e9 30 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10adeb:	83 7d fc 21          	cmp    DWORD PTR [rbp-0x4],0x21
  10adef:	75 0a                	jne    10adfb <dw_get_tag_string+0x1bb>
  10adf1:	b8 e0 70 10 00       	mov    eax,0x1070e0
  10adf6:	e9 20 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10adfb:	83 7d fc 22          	cmp    DWORD PTR [rbp-0x4],0x22
  10adff:	75 0a                	jne    10ae0b <dw_get_tag_string+0x1cb>
  10ae01:	b8 f5 70 10 00       	mov    eax,0x1070f5
  10ae06:	e9 10 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ae0b:	83 7d fc 23          	cmp    DWORD PTR [rbp-0x4],0x23
  10ae0f:	75 0a                	jne    10ae1b <dw_get_tag_string+0x1db>
  10ae11:	b8 06 71 10 00       	mov    eax,0x107106
  10ae16:	e9 00 02 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ae1b:	83 7d fc 24          	cmp    DWORD PTR [rbp-0x4],0x24
  10ae1f:	75 0a                	jne    10ae2b <dw_get_tag_string+0x1eb>
  10ae21:	b8 20 71 10 00       	mov    eax,0x107120
  10ae26:	e9 f0 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ae2b:	83 7d fc 25          	cmp    DWORD PTR [rbp-0x4],0x25
  10ae2f:	75 0a                	jne    10ae3b <dw_get_tag_string+0x1fb>
  10ae31:	b8 31 71 10 00       	mov    eax,0x107131
  10ae36:	e9 e0 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ae3b:	83 7d fc 26          	cmp    DWORD PTR [rbp-0x4],0x26
  10ae3f:	75 0a                	jne    10ae4b <dw_get_tag_string+0x20b>
  10ae41:	b8 44 71 10 00       	mov    eax,0x107144
  10ae46:	e9 d0 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ae4b:	83 7d fc 27          	cmp    DWORD PTR [rbp-0x4],0x27
  10ae4f:	75 0a                	jne    10ae5b <dw_get_tag_string+0x21b>
  10ae51:	b8 56 71 10 00       	mov    eax,0x107156
  10ae56:	e9 c0 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ae5b:	83 7d fc 28          	cmp    DWORD PTR [rbp-0x4],0x28
  10ae5f:	75 0a                	jne    10ae6b <dw_get_tag_string+0x22b>
  10ae61:	b8 66 71 10 00       	mov    eax,0x107166
  10ae66:	e9 b0 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ae6b:	83 7d fc 29          	cmp    DWORD PTR [rbp-0x4],0x29
  10ae6f:	75 0a                	jne    10ae7b <dw_get_tag_string+0x23b>
  10ae71:	b8 78 71 10 00       	mov    eax,0x107178
  10ae76:	e9 a0 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ae7b:	83 7d fc 2a          	cmp    DWORD PTR [rbp-0x4],0x2a
  10ae7f:	75 0a                	jne    10ae8b <dw_get_tag_string+0x24b>
  10ae81:	b8 89 71 10 00       	mov    eax,0x107189
  10ae86:	e9 90 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ae8b:	83 7d fc 2b          	cmp    DWORD PTR [rbp-0x4],0x2b
  10ae8f:	75 0a                	jne    10ae9b <dw_get_tag_string+0x25b>
  10ae91:	b8 97 71 10 00       	mov    eax,0x107197
  10ae96:	e9 80 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10ae9b:	83 7d fc 2c          	cmp    DWORD PTR [rbp-0x4],0x2c
  10ae9f:	75 0a                	jne    10aeab <dw_get_tag_string+0x26b>
  10aea1:	b8 a7 71 10 00       	mov    eax,0x1071a7
  10aea6:	e9 70 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10aeab:	83 7d fc 2d          	cmp    DWORD PTR [rbp-0x4],0x2d
  10aeaf:	75 0a                	jne    10aebb <dw_get_tag_string+0x27b>
  10aeb1:	b8 bc 71 10 00       	mov    eax,0x1071bc
  10aeb6:	e9 60 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10aebb:	83 7d fc 2e          	cmp    DWORD PTR [rbp-0x4],0x2e
  10aebf:	75 0a                	jne    10aecb <dw_get_tag_string+0x28b>
  10aec1:	b8 cf 71 10 00       	mov    eax,0x1071cf
  10aec6:	e9 50 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10aecb:	83 7d fc 2f          	cmp    DWORD PTR [rbp-0x4],0x2f
  10aecf:	75 0a                	jne    10aedb <dw_get_tag_string+0x29b>
  10aed1:	b8 e8 71 10 00       	mov    eax,0x1071e8
  10aed6:	e9 40 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10aedb:	83 7d fc 30          	cmp    DWORD PTR [rbp-0x4],0x30
  10aedf:	75 0a                	jne    10aeeb <dw_get_tag_string+0x2ab>
  10aee1:	b8 08 72 10 00       	mov    eax,0x107208
  10aee6:	e9 30 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10aeeb:	83 7d fc 31          	cmp    DWORD PTR [rbp-0x4],0x31
  10aeef:	75 0a                	jne    10aefb <dw_get_tag_string+0x2bb>
  10aef1:	b8 28 72 10 00       	mov    eax,0x107228
  10aef6:	e9 20 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10aefb:	83 7d fc 32          	cmp    DWORD PTR [rbp-0x4],0x32
  10aeff:	75 0a                	jne    10af0b <dw_get_tag_string+0x2cb>
  10af01:	b8 3b 72 10 00       	mov    eax,0x10723b
  10af06:	e9 10 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10af0b:	83 7d fc 33          	cmp    DWORD PTR [rbp-0x4],0x33
  10af0f:	75 0a                	jne    10af1b <dw_get_tag_string+0x2db>
  10af11:	b8 4c 72 10 00       	mov    eax,0x10724c
  10af16:	e9 00 01 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10af1b:	83 7d fc 34          	cmp    DWORD PTR [rbp-0x4],0x34
  10af1f:	75 0a                	jne    10af2b <dw_get_tag_string+0x2eb>
  10af21:	b8 60 72 10 00       	mov    eax,0x107260
  10af26:	e9 f0 00 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10af2b:	83 7d fc 35          	cmp    DWORD PTR [rbp-0x4],0x35
  10af2f:	75 0a                	jne    10af3b <dw_get_tag_string+0x2fb>
  10af31:	b8 70 72 10 00       	mov    eax,0x107270
  10af36:	e9 e0 00 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10af3b:	83 7d fc 36          	cmp    DWORD PTR [rbp-0x4],0x36
  10af3f:	75 0a                	jne    10af4b <dw_get_tag_string+0x30b>
  10af41:	b8 85 72 10 00       	mov    eax,0x107285
  10af46:	e9 d0 00 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10af4b:	83 7d fc 37          	cmp    DWORD PTR [rbp-0x4],0x37
  10af4f:	75 0a                	jne    10af5b <dw_get_tag_string+0x31b>
  10af51:	b8 9c 72 10 00       	mov    eax,0x10729c
  10af56:	e9 c0 00 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10af5b:	83 7d fc 38          	cmp    DWORD PTR [rbp-0x4],0x38
  10af5f:	75 0a                	jne    10af6b <dw_get_tag_string+0x32b>
  10af61:	b8 b1 72 10 00       	mov    eax,0x1072b1
  10af66:	e9 b0 00 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10af6b:	83 7d fc 39          	cmp    DWORD PTR [rbp-0x4],0x39
  10af6f:	75 0a                	jne    10af7b <dw_get_tag_string+0x33b>
  10af71:	b8 c7 72 10 00       	mov    eax,0x1072c7
  10af76:	e9 a0 00 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10af7b:	83 7d fc 3a          	cmp    DWORD PTR [rbp-0x4],0x3a
  10af7f:	75 0a                	jne    10af8b <dw_get_tag_string+0x34b>
  10af81:	b8 d8 72 10 00       	mov    eax,0x1072d8
  10af86:	e9 90 00 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10af8b:	83 7d fc 3b          	cmp    DWORD PTR [rbp-0x4],0x3b
  10af8f:	75 0a                	jne    10af9b <dw_get_tag_string+0x35b>
  10af91:	b8 ef 72 10 00       	mov    eax,0x1072ef
  10af96:	e9 80 00 00 00       	jmp    10b01b <dw_get_tag_string+0x3db>
  10af9b:	83 7d fc 3c          	cmp    DWORD PTR [rbp-0x4],0x3c
  10af9f:	75 07                	jne    10afa8 <dw_get_tag_string+0x368>
  10afa1:	b8 07 73 10 00       	mov    eax,0x107307
  10afa6:	eb 73                	jmp    10b01b <dw_get_tag_string+0x3db>
  10afa8:	83 7d fc 3d          	cmp    DWORD PTR [rbp-0x4],0x3d
  10afac:	75 07                	jne    10afb5 <dw_get_tag_string+0x375>
  10afae:	b8 1b 73 10 00       	mov    eax,0x10731b
  10afb3:	eb 66                	jmp    10b01b <dw_get_tag_string+0x3db>
  10afb5:	83 7d fc 3f          	cmp    DWORD PTR [rbp-0x4],0x3f
  10afb9:	75 07                	jne    10afc2 <dw_get_tag_string+0x382>
  10afbb:	b8 30 73 10 00       	mov    eax,0x107330
  10afc0:	eb 59                	jmp    10b01b <dw_get_tag_string+0x3db>
  10afc2:	83 7d fc 40          	cmp    DWORD PTR [rbp-0x4],0x40
  10afc6:	75 07                	jne    10afcf <dw_get_tag_string+0x38f>
  10afc8:	b8 41 73 10 00       	mov    eax,0x107341
  10afcd:	eb 4c                	jmp    10b01b <dw_get_tag_string+0x3db>
  10afcf:	83 7d fc 41          	cmp    DWORD PTR [rbp-0x4],0x41
  10afd3:	75 07                	jne    10afdc <dw_get_tag_string+0x39c>
  10afd5:	b8 54 73 10 00       	mov    eax,0x107354
  10afda:	eb 3f                	jmp    10b01b <dw_get_tag_string+0x3db>
  10afdc:	83 7d fc 42          	cmp    DWORD PTR [rbp-0x4],0x42
  10afe0:	75 07                	jne    10afe9 <dw_get_tag_string+0x3a9>
  10afe2:	b8 65 73 10 00       	mov    eax,0x107365
  10afe7:	eb 32                	jmp    10b01b <dw_get_tag_string+0x3db>
  10afe9:	83 7d fc 43          	cmp    DWORD PTR [rbp-0x4],0x43
  10afed:	75 07                	jne    10aff6 <dw_get_tag_string+0x3b6>
  10afef:	b8 82 73 10 00       	mov    eax,0x107382
  10aff4:	eb 25                	jmp    10b01b <dw_get_tag_string+0x3db>
  10aff6:	81 7d fc 80 40 00 00 	cmp    DWORD PTR [rbp-0x4],0x4080
  10affd:	75 07                	jne    10b006 <dw_get_tag_string+0x3c6>
  10afff:	b8 98 73 10 00       	mov    eax,0x107398
  10b004:	eb 15                	jmp    10b01b <dw_get_tag_string+0x3db>
  10b006:	81 7d fc ff ff 00 00 	cmp    DWORD PTR [rbp-0x4],0xffff
  10b00d:	75 07                	jne    10b016 <dw_get_tag_string+0x3d6>
  10b00f:	b8 a7 73 10 00       	mov    eax,0x1073a7
  10b014:	eb 05                	jmp    10b01b <dw_get_tag_string+0x3db>
  else { return "INVALID!!!"; }
  10b016:	b8 b6 73 10 00       	mov    eax,0x1073b6
}
  10b01b:	c9                   	leave  
  10b01c:	c3                   	ret    

000000000010b01d <dw_get_attrib_string>:

const char *dw_get_attrib_string(uint32_t value) {
  10b01d:	55                   	push   rbp
  10b01e:	48 89 e5             	mov    rbp,rsp
  10b021:	48 83 ec 08          	sub    rsp,0x8
  10b025:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
  if (0) {} DW_AT_META_LIST
  10b028:	83 7d fc 01          	cmp    DWORD PTR [rbp-0x4],0x1
  10b02c:	75 0a                	jne    10b038 <dw_get_attrib_string+0x1b>
  10b02e:	b8 c1 73 10 00       	mov    eax,0x1073c1
  10b033:	e9 c0 05 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b038:	83 7d fc 02          	cmp    DWORD PTR [rbp-0x4],0x2
  10b03c:	75 0a                	jne    10b048 <dw_get_attrib_string+0x2b>
  10b03e:	b8 cf 73 10 00       	mov    eax,0x1073cf
  10b043:	e9 b0 05 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b048:	83 7d fc 03          	cmp    DWORD PTR [rbp-0x4],0x3
  10b04c:	75 0a                	jne    10b058 <dw_get_attrib_string+0x3b>
  10b04e:	b8 de 73 10 00       	mov    eax,0x1073de
  10b053:	e9 a0 05 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b058:	83 7d fc 09          	cmp    DWORD PTR [rbp-0x4],0x9
  10b05c:	75 0a                	jne    10b068 <dw_get_attrib_string+0x4b>
  10b05e:	b8 e9 73 10 00       	mov    eax,0x1073e9
  10b063:	e9 90 05 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b068:	83 7d fc 0b          	cmp    DWORD PTR [rbp-0x4],0xb
  10b06c:	75 0a                	jne    10b078 <dw_get_attrib_string+0x5b>
  10b06e:	b8 f8 73 10 00       	mov    eax,0x1073f8
  10b073:	e9 80 05 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b078:	83 7d fc 0c          	cmp    DWORD PTR [rbp-0x4],0xc
  10b07c:	75 0a                	jne    10b088 <dw_get_attrib_string+0x6b>
  10b07e:	b8 08 74 10 00       	mov    eax,0x107408
  10b083:	e9 70 05 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b088:	83 7d fc 0d          	cmp    DWORD PTR [rbp-0x4],0xd
  10b08c:	75 0a                	jne    10b098 <dw_get_attrib_string+0x7b>
  10b08e:	b8 19 74 10 00       	mov    eax,0x107419
  10b093:	e9 60 05 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b098:	83 7d fc 10          	cmp    DWORD PTR [rbp-0x4],0x10
  10b09c:	75 0a                	jne    10b0a8 <dw_get_attrib_string+0x8b>
  10b09e:	b8 28 74 10 00       	mov    eax,0x107428
  10b0a3:	e9 50 05 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b0a8:	83 7d fc 11          	cmp    DWORD PTR [rbp-0x4],0x11
  10b0ac:	75 0a                	jne    10b0b8 <dw_get_attrib_string+0x9b>
  10b0ae:	b8 38 74 10 00       	mov    eax,0x107438
  10b0b3:	e9 40 05 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b0b8:	83 7d fc 12          	cmp    DWORD PTR [rbp-0x4],0x12
  10b0bc:	75 0a                	jne    10b0c8 <dw_get_attrib_string+0xab>
  10b0be:	b8 45 74 10 00       	mov    eax,0x107445
  10b0c3:	e9 30 05 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b0c8:	83 7d fc 13          	cmp    DWORD PTR [rbp-0x4],0x13
  10b0cc:	75 0a                	jne    10b0d8 <dw_get_attrib_string+0xbb>
  10b0ce:	b8 53 74 10 00       	mov    eax,0x107453
  10b0d3:	e9 20 05 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b0d8:	83 7d fc 15          	cmp    DWORD PTR [rbp-0x4],0x15
  10b0dc:	75 0a                	jne    10b0e8 <dw_get_attrib_string+0xcb>
  10b0de:	b8 62 74 10 00       	mov    eax,0x107462
  10b0e3:	e9 10 05 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b0e8:	83 7d fc 16          	cmp    DWORD PTR [rbp-0x4],0x16
  10b0ec:	75 0a                	jne    10b0f8 <dw_get_attrib_string+0xdb>
  10b0ee:	b8 6e 74 10 00       	mov    eax,0x10746e
  10b0f3:	e9 00 05 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b0f8:	83 7d fc 17          	cmp    DWORD PTR [rbp-0x4],0x17
  10b0fc:	75 0a                	jne    10b108 <dw_get_attrib_string+0xeb>
  10b0fe:	b8 80 74 10 00       	mov    eax,0x107480
  10b103:	e9 f0 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b108:	83 7d fc 18          	cmp    DWORD PTR [rbp-0x4],0x18
  10b10c:	75 0a                	jne    10b118 <dw_get_attrib_string+0xfb>
  10b10e:	b8 91 74 10 00       	mov    eax,0x107491
  10b113:	e9 e0 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b118:	83 7d fc 19          	cmp    DWORD PTR [rbp-0x4],0x19
  10b11c:	75 0a                	jne    10b128 <dw_get_attrib_string+0x10b>
  10b11e:	b8 9e 74 10 00       	mov    eax,0x10749e
  10b123:	e9 d0 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b128:	83 7d fc 1a          	cmp    DWORD PTR [rbp-0x4],0x1a
  10b12c:	75 0a                	jne    10b138 <dw_get_attrib_string+0x11b>
  10b12e:	b8 b2 74 10 00       	mov    eax,0x1074b2
  10b133:	e9 c0 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b138:	83 7d fc 1b          	cmp    DWORD PTR [rbp-0x4],0x1b
  10b13c:	75 0a                	jne    10b148 <dw_get_attrib_string+0x12b>
  10b13e:	b8 c9 74 10 00       	mov    eax,0x1074c9
  10b143:	e9 b0 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b148:	83 7d fc 1c          	cmp    DWORD PTR [rbp-0x4],0x1c
  10b14c:	75 0a                	jne    10b158 <dw_get_attrib_string+0x13b>
  10b14e:	b8 d8 74 10 00       	mov    eax,0x1074d8
  10b153:	e9 a0 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b158:	83 7d fc 1d          	cmp    DWORD PTR [rbp-0x4],0x1d
  10b15c:	75 0a                	jne    10b168 <dw_get_attrib_string+0x14b>
  10b15e:	b8 ea 74 10 00       	mov    eax,0x1074ea
  10b163:	e9 90 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b168:	83 7d fc 1e          	cmp    DWORD PTR [rbp-0x4],0x1e
  10b16c:	75 0a                	jne    10b178 <dw_get_attrib_string+0x15b>
  10b16e:	b8 00 75 10 00       	mov    eax,0x107500
  10b173:	e9 80 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b178:	83 7d fc 20          	cmp    DWORD PTR [rbp-0x4],0x20
  10b17c:	75 0a                	jne    10b188 <dw_get_attrib_string+0x16b>
  10b17e:	b8 14 75 10 00       	mov    eax,0x107514
  10b183:	e9 70 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b188:	83 7d fc 21          	cmp    DWORD PTR [rbp-0x4],0x21
  10b18c:	75 0a                	jne    10b198 <dw_get_attrib_string+0x17b>
  10b18e:	b8 21 75 10 00       	mov    eax,0x107521
  10b193:	e9 60 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b198:	83 7d fc 22          	cmp    DWORD PTR [rbp-0x4],0x22
  10b19c:	75 0a                	jne    10b1a8 <dw_get_attrib_string+0x18b>
  10b19e:	b8 33 75 10 00       	mov    eax,0x107533
  10b1a3:	e9 50 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b1a8:	83 7d fc 25          	cmp    DWORD PTR [rbp-0x4],0x25
  10b1ac:	75 0a                	jne    10b1b8 <dw_get_attrib_string+0x19b>
  10b1ae:	b8 45 75 10 00       	mov    eax,0x107545
  10b1b3:	e9 40 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b1b8:	83 7d fc 27          	cmp    DWORD PTR [rbp-0x4],0x27
  10b1bc:	75 0a                	jne    10b1c8 <dw_get_attrib_string+0x1ab>
  10b1be:	b8 54 75 10 00       	mov    eax,0x107554
  10b1c3:	e9 30 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b1c8:	83 7d fc 2a          	cmp    DWORD PTR [rbp-0x4],0x2a
  10b1cc:	75 0a                	jne    10b1d8 <dw_get_attrib_string+0x1bb>
  10b1ce:	b8 65 75 10 00       	mov    eax,0x107565
  10b1d3:	e9 20 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b1d8:	83 7d fc 2c          	cmp    DWORD PTR [rbp-0x4],0x2c
  10b1dc:	75 0a                	jne    10b1e8 <dw_get_attrib_string+0x1cb>
  10b1de:	b8 77 75 10 00       	mov    eax,0x107577
  10b1e3:	e9 10 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b1e8:	83 7d fc 2e          	cmp    DWORD PTR [rbp-0x4],0x2e
  10b1ec:	75 0a                	jne    10b1f8 <dw_get_attrib_string+0x1db>
  10b1ee:	b8 89 75 10 00       	mov    eax,0x107589
  10b1f3:	e9 00 04 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b1f8:	83 7d fc 2f          	cmp    DWORD PTR [rbp-0x4],0x2f
  10b1fc:	75 0a                	jne    10b208 <dw_get_attrib_string+0x1eb>
  10b1fe:	b8 9a 75 10 00       	mov    eax,0x10759a
  10b203:	e9 f0 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b208:	83 7d fc 31          	cmp    DWORD PTR [rbp-0x4],0x31
  10b20c:	75 0a                	jne    10b218 <dw_get_attrib_string+0x1fb>
  10b20e:	b8 ac 75 10 00       	mov    eax,0x1075ac
  10b213:	e9 e0 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b218:	83 7d fc 32          	cmp    DWORD PTR [rbp-0x4],0x32
  10b21c:	75 0a                	jne    10b228 <dw_get_attrib_string+0x20b>
  10b21e:	b8 c2 75 10 00       	mov    eax,0x1075c2
  10b223:	e9 d0 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b228:	83 7d fc 33          	cmp    DWORD PTR [rbp-0x4],0x33
  10b22c:	75 0a                	jne    10b238 <dw_get_attrib_string+0x21b>
  10b22e:	b8 d6 75 10 00       	mov    eax,0x1075d6
  10b233:	e9 c0 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b238:	83 7d fc 34          	cmp    DWORD PTR [rbp-0x4],0x34
  10b23c:	75 0a                	jne    10b248 <dw_get_attrib_string+0x22b>
  10b23e:	b8 ea 75 10 00       	mov    eax,0x1075ea
  10b243:	e9 b0 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b248:	83 7d fc 35          	cmp    DWORD PTR [rbp-0x4],0x35
  10b24c:	75 0a                	jne    10b258 <dw_get_attrib_string+0x23b>
  10b24e:	b8 fb 75 10 00       	mov    eax,0x1075fb
  10b253:	e9 a0 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b258:	83 7d fc 36          	cmp    DWORD PTR [rbp-0x4],0x36
  10b25c:	75 0a                	jne    10b268 <dw_get_attrib_string+0x24b>
  10b25e:	b8 0c 76 10 00       	mov    eax,0x10760c
  10b263:	e9 90 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b268:	83 7d fc 37          	cmp    DWORD PTR [rbp-0x4],0x37
  10b26c:	75 0a                	jne    10b278 <dw_get_attrib_string+0x25b>
  10b26e:	b8 25 76 10 00       	mov    eax,0x107625
  10b273:	e9 80 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b278:	83 7d fc 38          	cmp    DWORD PTR [rbp-0x4],0x38
  10b27c:	75 0a                	jne    10b288 <dw_get_attrib_string+0x26b>
  10b27e:	b8 31 76 10 00       	mov    eax,0x107631
  10b283:	e9 70 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b288:	83 7d fc 39          	cmp    DWORD PTR [rbp-0x4],0x39
  10b28c:	75 0a                	jne    10b298 <dw_get_attrib_string+0x27b>
  10b28e:	b8 4c 76 10 00       	mov    eax,0x10764c
  10b293:	e9 60 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b298:	83 7d fc 3a          	cmp    DWORD PTR [rbp-0x4],0x3a
  10b29c:	75 0a                	jne    10b2a8 <dw_get_attrib_string+0x28b>
  10b29e:	b8 5e 76 10 00       	mov    eax,0x10765e
  10b2a3:	e9 50 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b2a8:	83 7d fc 3b          	cmp    DWORD PTR [rbp-0x4],0x3b
  10b2ac:	75 0a                	jne    10b2b8 <dw_get_attrib_string+0x29b>
  10b2ae:	b8 6e 76 10 00       	mov    eax,0x10766e
  10b2b3:	e9 40 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b2b8:	83 7d fc 3c          	cmp    DWORD PTR [rbp-0x4],0x3c
  10b2bc:	75 0a                	jne    10b2c8 <dw_get_attrib_string+0x2ab>
  10b2be:	b8 7e 76 10 00       	mov    eax,0x10767e
  10b2c3:	e9 30 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b2c8:	83 7d fc 3d          	cmp    DWORD PTR [rbp-0x4],0x3d
  10b2cc:	75 0a                	jne    10b2d8 <dw_get_attrib_string+0x2bb>
  10b2ce:	b8 90 76 10 00       	mov    eax,0x107690
  10b2d3:	e9 20 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b2d8:	83 7d fc 3e          	cmp    DWORD PTR [rbp-0x4],0x3e
  10b2dc:	75 0a                	jne    10b2e8 <dw_get_attrib_string+0x2cb>
  10b2de:	b8 a1 76 10 00       	mov    eax,0x1076a1
  10b2e3:	e9 10 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b2e8:	83 7d fc 3f          	cmp    DWORD PTR [rbp-0x4],0x3f
  10b2ec:	75 0a                	jne    10b2f8 <dw_get_attrib_string+0x2db>
  10b2ee:	b8 b0 76 10 00       	mov    eax,0x1076b0
  10b2f3:	e9 00 03 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b2f8:	83 7d fc 40          	cmp    DWORD PTR [rbp-0x4],0x40
  10b2fc:	75 0a                	jne    10b308 <dw_get_attrib_string+0x2eb>
  10b2fe:	b8 bf 76 10 00       	mov    eax,0x1076bf
  10b303:	e9 f0 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b308:	83 7d fc 41          	cmp    DWORD PTR [rbp-0x4],0x41
  10b30c:	75 0a                	jne    10b318 <dw_get_attrib_string+0x2fb>
  10b30e:	b8 d0 76 10 00       	mov    eax,0x1076d0
  10b313:	e9 e0 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b318:	83 7d fc 42          	cmp    DWORD PTR [rbp-0x4],0x42
  10b31c:	75 0a                	jne    10b328 <dw_get_attrib_string+0x30b>
  10b31e:	b8 dd 76 10 00       	mov    eax,0x1076dd
  10b323:	e9 d0 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b328:	83 7d fc 43          	cmp    DWORD PTR [rbp-0x4],0x43
  10b32c:	75 0a                	jne    10b338 <dw_get_attrib_string+0x31b>
  10b32e:	b8 f3 76 10 00       	mov    eax,0x1076f3
  10b333:	e9 c0 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b338:	83 7d fc 44          	cmp    DWORD PTR [rbp-0x4],0x44
  10b33c:	75 0a                	jne    10b348 <dw_get_attrib_string+0x32b>
  10b33e:	b8 04 77 10 00       	mov    eax,0x107704
  10b343:	e9 b0 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b348:	83 7d fc 45          	cmp    DWORD PTR [rbp-0x4],0x45
  10b34c:	75 0a                	jne    10b358 <dw_get_attrib_string+0x33b>
  10b34e:	b8 18 77 10 00       	mov    eax,0x107718
  10b353:	e9 a0 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b358:	83 7d fc 46          	cmp    DWORD PTR [rbp-0x4],0x46
  10b35c:	75 0a                	jne    10b368 <dw_get_attrib_string+0x34b>
  10b35e:	b8 27 77 10 00       	mov    eax,0x107727
  10b363:	e9 90 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b368:	83 7d fc 47          	cmp    DWORD PTR [rbp-0x4],0x47
  10b36c:	75 0a                	jne    10b378 <dw_get_attrib_string+0x35b>
  10b36e:	b8 35 77 10 00       	mov    eax,0x107735
  10b373:	e9 80 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b378:	83 7d fc 48          	cmp    DWORD PTR [rbp-0x4],0x48
  10b37c:	75 0a                	jne    10b388 <dw_get_attrib_string+0x36b>
  10b37e:	b8 49 77 10 00       	mov    eax,0x107749
  10b383:	e9 70 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b388:	83 7d fc 49          	cmp    DWORD PTR [rbp-0x4],0x49
  10b38c:	75 0a                	jne    10b398 <dw_get_attrib_string+0x37b>
  10b38e:	b8 5b 77 10 00       	mov    eax,0x10775b
  10b393:	e9 60 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b398:	83 7d fc 4a          	cmp    DWORD PTR [rbp-0x4],0x4a
  10b39c:	75 0a                	jne    10b3a8 <dw_get_attrib_string+0x38b>
  10b39e:	b8 66 77 10 00       	mov    eax,0x107766
  10b3a3:	e9 50 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b3a8:	83 7d fc 4b          	cmp    DWORD PTR [rbp-0x4],0x4b
  10b3ac:	75 0a                	jne    10b3b8 <dw_get_attrib_string+0x39b>
  10b3ae:	b8 79 77 10 00       	mov    eax,0x107779
  10b3b3:	e9 40 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b3b8:	83 7d fc 4c          	cmp    DWORD PTR [rbp-0x4],0x4c
  10b3bc:	75 0a                	jne    10b3c8 <dw_get_attrib_string+0x3ab>
  10b3be:	b8 92 77 10 00       	mov    eax,0x107792
  10b3c3:	e9 30 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b3c8:	83 7d fc 4d          	cmp    DWORD PTR [rbp-0x4],0x4d
  10b3cc:	75 0a                	jne    10b3d8 <dw_get_attrib_string+0x3bb>
  10b3ce:	b8 a3 77 10 00       	mov    eax,0x1077a3
  10b3d3:	e9 20 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b3d8:	83 7d fc 4e          	cmp    DWORD PTR [rbp-0x4],0x4e
  10b3dc:	75 0a                	jne    10b3e8 <dw_get_attrib_string+0x3cb>
  10b3de:	b8 be 77 10 00       	mov    eax,0x1077be
  10b3e3:	e9 10 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b3e8:	83 7d fc 4f          	cmp    DWORD PTR [rbp-0x4],0x4f
  10b3ec:	75 0a                	jne    10b3f8 <dw_get_attrib_string+0x3db>
  10b3ee:	b8 ce 77 10 00       	mov    eax,0x1077ce
  10b3f3:	e9 00 02 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b3f8:	83 7d fc 50          	cmp    DWORD PTR [rbp-0x4],0x50
  10b3fc:	75 0a                	jne    10b408 <dw_get_attrib_string+0x3eb>
  10b3fe:	b8 df 77 10 00       	mov    eax,0x1077df
  10b403:	e9 f0 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b408:	83 7d fc 51          	cmp    DWORD PTR [rbp-0x4],0x51
  10b40c:	75 0a                	jne    10b418 <dw_get_attrib_string+0x3fb>
  10b40e:	b8 f3 77 10 00       	mov    eax,0x1077f3
  10b413:	e9 e0 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b418:	83 7d fc 52          	cmp    DWORD PTR [rbp-0x4],0x52
  10b41c:	75 0a                	jne    10b428 <dw_get_attrib_string+0x40b>
  10b41e:	b8 05 78 10 00       	mov    eax,0x107805
  10b423:	e9 d0 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b428:	83 7d fc 53          	cmp    DWORD PTR [rbp-0x4],0x53
  10b42c:	75 0a                	jne    10b438 <dw_get_attrib_string+0x41b>
  10b42e:	b8 14 78 10 00       	mov    eax,0x107814
  10b433:	e9 c0 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b438:	83 7d fc 54          	cmp    DWORD PTR [rbp-0x4],0x54
  10b43c:	75 0a                	jne    10b448 <dw_get_attrib_string+0x42b>
  10b43e:	b8 23 78 10 00       	mov    eax,0x107823
  10b443:	e9 b0 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b448:	83 7d fc 55          	cmp    DWORD PTR [rbp-0x4],0x55
  10b44c:	75 0a                	jne    10b458 <dw_get_attrib_string+0x43b>
  10b44e:	b8 33 78 10 00       	mov    eax,0x107833
  10b453:	e9 a0 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b458:	83 7d fc 56          	cmp    DWORD PTR [rbp-0x4],0x56
  10b45c:	75 0a                	jne    10b468 <dw_get_attrib_string+0x44b>
  10b45e:	b8 40 78 10 00       	mov    eax,0x107840
  10b463:	e9 90 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b468:	83 7d fc 57          	cmp    DWORD PTR [rbp-0x4],0x57
  10b46c:	75 0a                	jne    10b478 <dw_get_attrib_string+0x45b>
  10b46e:	b8 51 78 10 00       	mov    eax,0x107851
  10b473:	e9 80 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b478:	83 7d fc 58          	cmp    DWORD PTR [rbp-0x4],0x58
  10b47c:	75 0a                	jne    10b488 <dw_get_attrib_string+0x46b>
  10b47e:	b8 63 78 10 00       	mov    eax,0x107863
  10b483:	e9 70 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b488:	83 7d fc 59          	cmp    DWORD PTR [rbp-0x4],0x59
  10b48c:	75 0a                	jne    10b498 <dw_get_attrib_string+0x47b>
  10b48e:	b8 73 78 10 00       	mov    eax,0x107873
  10b493:	e9 60 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b498:	83 7d fc 5a          	cmp    DWORD PTR [rbp-0x4],0x5a
  10b49c:	75 0a                	jne    10b4a8 <dw_get_attrib_string+0x48b>
  10b49e:	b8 83 78 10 00       	mov    eax,0x107883
  10b4a3:	e9 50 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b4a8:	83 7d fc 5b          	cmp    DWORD PTR [rbp-0x4],0x5b
  10b4ac:	75 0a                	jne    10b4b8 <dw_get_attrib_string+0x49b>
  10b4ae:	b8 95 78 10 00       	mov    eax,0x107895
  10b4b3:	e9 40 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b4b8:	83 7d fc 5c          	cmp    DWORD PTR [rbp-0x4],0x5c
  10b4bc:	75 0a                	jne    10b4c8 <dw_get_attrib_string+0x4ab>
  10b4be:	b8 a8 78 10 00       	mov    eax,0x1078a8
  10b4c3:	e9 30 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b4c8:	83 7d fc 5d          	cmp    DWORD PTR [rbp-0x4],0x5d
  10b4cc:	75 0a                	jne    10b4d8 <dw_get_attrib_string+0x4bb>
  10b4ce:	b8 bc 78 10 00       	mov    eax,0x1078bc
  10b4d3:	e9 20 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b4d8:	83 7d fc 5e          	cmp    DWORD PTR [rbp-0x4],0x5e
  10b4dc:	75 0a                	jne    10b4e8 <dw_get_attrib_string+0x4cb>
  10b4de:	b8 c8 78 10 00       	mov    eax,0x1078c8
  10b4e3:	e9 10 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b4e8:	83 7d fc 5f          	cmp    DWORD PTR [rbp-0x4],0x5f
  10b4ec:	75 0a                	jne    10b4f8 <dw_get_attrib_string+0x4db>
  10b4ee:	b8 db 78 10 00       	mov    eax,0x1078db
  10b4f3:	e9 00 01 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b4f8:	83 7d fc 60          	cmp    DWORD PTR [rbp-0x4],0x60
  10b4fc:	75 0a                	jne    10b508 <dw_get_attrib_string+0x4eb>
  10b4fe:	b8 ed 78 10 00       	mov    eax,0x1078ed
  10b503:	e9 f0 00 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b508:	83 7d fc 61          	cmp    DWORD PTR [rbp-0x4],0x61
  10b50c:	75 0a                	jne    10b518 <dw_get_attrib_string+0x4fb>
  10b50e:	b8 02 79 10 00       	mov    eax,0x107902
  10b513:	e9 e0 00 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b518:	83 7d fc 62          	cmp    DWORD PTR [rbp-0x4],0x62
  10b51c:	75 0a                	jne    10b528 <dw_get_attrib_string+0x50b>
  10b51e:	b8 10 79 10 00       	mov    eax,0x107910
  10b523:	e9 d0 00 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b528:	83 7d fc 63          	cmp    DWORD PTR [rbp-0x4],0x63
  10b52c:	75 0a                	jne    10b538 <dw_get_attrib_string+0x51b>
  10b52e:	b8 25 79 10 00       	mov    eax,0x107925
  10b533:	e9 c0 00 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b538:	83 7d fc 64          	cmp    DWORD PTR [rbp-0x4],0x64
  10b53c:	75 0a                	jne    10b548 <dw_get_attrib_string+0x52b>
  10b53e:	b8 34 79 10 00       	mov    eax,0x107934
  10b543:	e9 b0 00 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b548:	83 7d fc 65          	cmp    DWORD PTR [rbp-0x4],0x65
  10b54c:	75 0a                	jne    10b558 <dw_get_attrib_string+0x53b>
  10b54e:	b8 49 79 10 00       	mov    eax,0x107949
  10b553:	e9 a0 00 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b558:	83 7d fc 66          	cmp    DWORD PTR [rbp-0x4],0x66
  10b55c:	75 0a                	jne    10b568 <dw_get_attrib_string+0x54b>
  10b55e:	b8 59 79 10 00       	mov    eax,0x107959
  10b563:	e9 90 00 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b568:	83 7d fc 67          	cmp    DWORD PTR [rbp-0x4],0x67
  10b56c:	75 0a                	jne    10b578 <dw_get_attrib_string+0x55b>
  10b56e:	b8 69 79 10 00       	mov    eax,0x107969
  10b573:	e9 80 00 00 00       	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b578:	83 7d fc 68          	cmp    DWORD PTR [rbp-0x4],0x68
  10b57c:	75 07                	jne    10b585 <dw_get_attrib_string+0x568>
  10b57e:	b8 74 79 10 00       	mov    eax,0x107974
  10b583:	eb 73                	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b585:	83 7d fc 69          	cmp    DWORD PTR [rbp-0x4],0x69
  10b589:	75 07                	jne    10b592 <dw_get_attrib_string+0x575>
  10b58b:	b8 84 79 10 00       	mov    eax,0x107984
  10b590:	eb 66                	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b592:	83 7d fc 6a          	cmp    DWORD PTR [rbp-0x4],0x6a
  10b596:	75 07                	jne    10b59f <dw_get_attrib_string+0x582>
  10b598:	b8 94 79 10 00       	mov    eax,0x107994
  10b59d:	eb 59                	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b59f:	83 7d fc 6b          	cmp    DWORD PTR [rbp-0x4],0x6b
  10b5a3:	75 07                	jne    10b5ac <dw_get_attrib_string+0x58f>
  10b5a5:	b8 aa 79 10 00       	mov    eax,0x1079aa
  10b5aa:	eb 4c                	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b5ac:	83 7d fc 6c          	cmp    DWORD PTR [rbp-0x4],0x6c
  10b5b0:	75 07                	jne    10b5b9 <dw_get_attrib_string+0x59c>
  10b5b2:	b8 c0 79 10 00       	mov    eax,0x1079c0
  10b5b7:	eb 3f                	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b5b9:	83 7d fc 6d          	cmp    DWORD PTR [rbp-0x4],0x6d
  10b5bd:	75 07                	jne    10b5c6 <dw_get_attrib_string+0x5a9>
  10b5bf:	b8 d1 79 10 00       	mov    eax,0x1079d1
  10b5c4:	eb 32                	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b5c6:	83 7d fc 6e          	cmp    DWORD PTR [rbp-0x4],0x6e
  10b5ca:	75 07                	jne    10b5d3 <dw_get_attrib_string+0x5b6>
  10b5cc:	b8 e2 79 10 00       	mov    eax,0x1079e2
  10b5d1:	eb 25                	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b5d3:	81 7d fc 00 20 00 00 	cmp    DWORD PTR [rbp-0x4],0x2000
  10b5da:	75 07                	jne    10b5e3 <dw_get_attrib_string+0x5c6>
  10b5dc:	b8 f5 79 10 00       	mov    eax,0x1079f5
  10b5e1:	eb 15                	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  10b5e3:	81 7d fc ff 3f 00 00 	cmp    DWORD PTR [rbp-0x4],0x3fff
  10b5ea:	75 07                	jne    10b5f3 <dw_get_attrib_string+0x5d6>
  10b5ec:	b8 03 7a 10 00       	mov    eax,0x107a03
  10b5f1:	eb 05                	jmp    10b5f8 <dw_get_attrib_string+0x5db>
  else { return "INVALID!!!"; }
  10b5f3:	b8 b6 73 10 00       	mov    eax,0x1073b6
}
  10b5f8:	c9                   	leave  
  10b5f9:	c3                   	ret    

000000000010b5fa <dw_get_form_string>:

const char *dw_get_form_string(uint32_t value) {
  10b5fa:	55                   	push   rbp
  10b5fb:	48 89 e5             	mov    rbp,rsp
  10b5fe:	48 83 ec 08          	sub    rsp,0x8
  10b602:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
  if (0) {} DW_FORM_META_LIST
  10b605:	83 7d fc 01          	cmp    DWORD PTR [rbp-0x4],0x1
  10b609:	75 0a                	jne    10b615 <dw_get_form_string+0x1b>
  10b60b:	b8 11 7a 10 00       	mov    eax,0x107a11
  10b610:	e9 67 01 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b615:	83 7d fc 03          	cmp    DWORD PTR [rbp-0x4],0x3
  10b619:	75 0a                	jne    10b625 <dw_get_form_string+0x2b>
  10b61b:	b8 1e 7a 10 00       	mov    eax,0x107a1e
  10b620:	e9 57 01 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b625:	83 7d fc 04          	cmp    DWORD PTR [rbp-0x4],0x4
  10b629:	75 0a                	jne    10b635 <dw_get_form_string+0x3b>
  10b62b:	b8 2d 7a 10 00       	mov    eax,0x107a2d
  10b630:	e9 47 01 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b635:	83 7d fc 05          	cmp    DWORD PTR [rbp-0x4],0x5
  10b639:	75 0a                	jne    10b645 <dw_get_form_string+0x4b>
  10b63b:	b8 3c 7a 10 00       	mov    eax,0x107a3c
  10b640:	e9 37 01 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b645:	83 7d fc 06          	cmp    DWORD PTR [rbp-0x4],0x6
  10b649:	75 0a                	jne    10b655 <dw_get_form_string+0x5b>
  10b64b:	b8 4a 7a 10 00       	mov    eax,0x107a4a
  10b650:	e9 27 01 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b655:	83 7d fc 07          	cmp    DWORD PTR [rbp-0x4],0x7
  10b659:	75 0a                	jne    10b665 <dw_get_form_string+0x6b>
  10b65b:	b8 58 7a 10 00       	mov    eax,0x107a58
  10b660:	e9 17 01 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b665:	83 7d fc 08          	cmp    DWORD PTR [rbp-0x4],0x8
  10b669:	75 0a                	jne    10b675 <dw_get_form_string+0x7b>
  10b66b:	b8 66 7a 10 00       	mov    eax,0x107a66
  10b670:	e9 07 01 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b675:	83 7d fc 09          	cmp    DWORD PTR [rbp-0x4],0x9
  10b679:	75 0a                	jne    10b685 <dw_get_form_string+0x8b>
  10b67b:	b8 75 7a 10 00       	mov    eax,0x107a75
  10b680:	e9 f7 00 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b685:	83 7d fc 0a          	cmp    DWORD PTR [rbp-0x4],0xa
  10b689:	75 0a                	jne    10b695 <dw_get_form_string+0x9b>
  10b68b:	b8 83 7a 10 00       	mov    eax,0x107a83
  10b690:	e9 e7 00 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b695:	83 7d fc 0b          	cmp    DWORD PTR [rbp-0x4],0xb
  10b699:	75 0a                	jne    10b6a5 <dw_get_form_string+0xab>
  10b69b:	b8 92 7a 10 00       	mov    eax,0x107a92
  10b6a0:	e9 d7 00 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b6a5:	83 7d fc 0c          	cmp    DWORD PTR [rbp-0x4],0xc
  10b6a9:	75 0a                	jne    10b6b5 <dw_get_form_string+0xbb>
  10b6ab:	b8 a0 7a 10 00       	mov    eax,0x107aa0
  10b6b0:	e9 c7 00 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b6b5:	83 7d fc 0d          	cmp    DWORD PTR [rbp-0x4],0xd
  10b6b9:	75 0a                	jne    10b6c5 <dw_get_form_string+0xcb>
  10b6bb:	b8 ad 7a 10 00       	mov    eax,0x107aad
  10b6c0:	e9 b7 00 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b6c5:	83 7d fc 0e          	cmp    DWORD PTR [rbp-0x4],0xe
  10b6c9:	75 0a                	jne    10b6d5 <dw_get_form_string+0xdb>
  10b6cb:	b8 bb 7a 10 00       	mov    eax,0x107abb
  10b6d0:	e9 a7 00 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b6d5:	83 7d fc 0f          	cmp    DWORD PTR [rbp-0x4],0xf
  10b6d9:	75 0a                	jne    10b6e5 <dw_get_form_string+0xeb>
  10b6db:	b8 c8 7a 10 00       	mov    eax,0x107ac8
  10b6e0:	e9 97 00 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b6e5:	83 7d fc 10          	cmp    DWORD PTR [rbp-0x4],0x10
  10b6e9:	75 0a                	jne    10b6f5 <dw_get_form_string+0xfb>
  10b6eb:	b8 d6 7a 10 00       	mov    eax,0x107ad6
  10b6f0:	e9 87 00 00 00       	jmp    10b77c <dw_get_form_string+0x182>
  10b6f5:	83 7d fc 11          	cmp    DWORD PTR [rbp-0x4],0x11
  10b6f9:	75 07                	jne    10b702 <dw_get_form_string+0x108>
  10b6fb:	b8 e7 7a 10 00       	mov    eax,0x107ae7
  10b700:	eb 7a                	jmp    10b77c <dw_get_form_string+0x182>
  10b702:	83 7d fc 12          	cmp    DWORD PTR [rbp-0x4],0x12
  10b706:	75 07                	jne    10b70f <dw_get_form_string+0x115>
  10b708:	b8 f4 7a 10 00       	mov    eax,0x107af4
  10b70d:	eb 6d                	jmp    10b77c <dw_get_form_string+0x182>
  10b70f:	83 7d fc 13          	cmp    DWORD PTR [rbp-0x4],0x13
  10b713:	75 07                	jne    10b71c <dw_get_form_string+0x122>
  10b715:	b8 01 7b 10 00       	mov    eax,0x107b01
  10b71a:	eb 60                	jmp    10b77c <dw_get_form_string+0x182>
  10b71c:	83 7d fc 14          	cmp    DWORD PTR [rbp-0x4],0x14
  10b720:	75 07                	jne    10b729 <dw_get_form_string+0x12f>
  10b722:	b8 0e 7b 10 00       	mov    eax,0x107b0e
  10b727:	eb 53                	jmp    10b77c <dw_get_form_string+0x182>
  10b729:	83 7d fc 15          	cmp    DWORD PTR [rbp-0x4],0x15
  10b72d:	75 07                	jne    10b736 <dw_get_form_string+0x13c>
  10b72f:	b8 1b 7b 10 00       	mov    eax,0x107b1b
  10b734:	eb 46                	jmp    10b77c <dw_get_form_string+0x182>
  10b736:	83 7d fc 16          	cmp    DWORD PTR [rbp-0x4],0x16
  10b73a:	75 07                	jne    10b743 <dw_get_form_string+0x149>
  10b73c:	b8 2d 7b 10 00       	mov    eax,0x107b2d
  10b741:	eb 39                	jmp    10b77c <dw_get_form_string+0x182>
  10b743:	83 7d fc 17          	cmp    DWORD PTR [rbp-0x4],0x17
  10b747:	75 07                	jne    10b750 <dw_get_form_string+0x156>
  10b749:	b8 3e 7b 10 00       	mov    eax,0x107b3e
  10b74e:	eb 2c                	jmp    10b77c <dw_get_form_string+0x182>
  10b750:	83 7d fc 18          	cmp    DWORD PTR [rbp-0x4],0x18
  10b754:	75 07                	jne    10b75d <dw_get_form_string+0x163>
  10b756:	b8 51 7b 10 00       	mov    eax,0x107b51
  10b75b:	eb 1f                	jmp    10b77c <dw_get_form_string+0x182>
  10b75d:	83 7d fc 19          	cmp    DWORD PTR [rbp-0x4],0x19
  10b761:	75 07                	jne    10b76a <dw_get_form_string+0x170>
  10b763:	b8 61 7b 10 00       	mov    eax,0x107b61
  10b768:	eb 12                	jmp    10b77c <dw_get_form_string+0x182>
  10b76a:	83 7d fc 20          	cmp    DWORD PTR [rbp-0x4],0x20
  10b76e:	75 07                	jne    10b777 <dw_get_form_string+0x17d>
  10b770:	b8 76 7b 10 00       	mov    eax,0x107b76
  10b775:	eb 05                	jmp    10b77c <dw_get_form_string+0x182>
  else { return "INVALID!!!"; }
  10b777:	b8 b6 73 10 00       	mov    eax,0x1073b6
}
  10b77c:	c9                   	leave  
  10b77d:	c3                   	ret    

000000000010b77e <kprocess_load_elf_executable>:
  return header->programEntryOffset;
}
#endif

static inline
int kprocess_load_elf_executable(uintptr_t elf_executable){
  10b77e:	55                   	push   rbp
  10b77f:	48 89 e5             	mov    rbp,rsp
  10b782:	48 83 ec 20          	sub    rsp,0x20
  10b786:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  ELF64Header *header = (ELF64Header *)elf_executable;
  10b78a:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10b78e:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  if(header->magicNumber != ELF64_MAGIC_NUMBER){
  10b792:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10b796:	8b 00                	mov    eax,DWORD PTR [rax]
  10b798:	3d 7f 45 4c 46       	cmp    eax,0x464c457f
  10b79d:	74 1b                	je     10b7ba <kprocess_load_elf_executable+0x3c>
    klog_error("invalid elf file was provided");
  10b79f:	be 87 7b 10 00       	mov    esi,0x107b87
  10b7a4:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b7a9:	b8 00 00 00 00       	mov    eax,0x0
  10b7ae:	e8 b4 14 00 00       	call   10cc67 <klog_write_fmt>
    return 0;
  10b7b3:	b8 00 00 00 00       	mov    eax,0x0
  10b7b8:	eb 08                	jmp    10b7c2 <kprocess_load_elf_executable+0x44>
    klog_debug(" segment file size: 0x%X", program_header->segment_file_size);
    klog_debug(" segment memory size: 0x%X", program_header->segment_memory_size);
  }
  #endif

  return header->programEntryOffset;
  10b7ba:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10b7be:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
  10b7c2:	c9                   	leave  
  10b7c3:	c3                   	ret    

000000000010b7c4 <kdebug_ioapic_log_irq_map>:
    klog_info("CPU%lu: lapic_id: %u", i, (uint32_t)sys->cpu_lapic_ids[i]);
  }
}

static void
kdebug_ioapic_log_irq_map(uintptr_t ioapic_base){
  10b7c4:	55                   	push   rbp
  10b7c5:	48 89 e5             	mov    rbp,rsp
  10b7c8:	48 83 ec 20          	sub    rsp,0x20
  10b7cc:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  for(size_t i = 0; i < 8; i++){
  10b7d0:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10b7d7:	00 
  10b7d8:	e9 81 00 00 00       	jmp    10b85e <kdebug_ioapic_log_irq_map+0x9a>
    IOAPIC_IRQR_LOW irqr_low = {};
  10b7dd:	c7 45 f0 00 00 00 00 	mov    DWORD PTR [rbp-0x10],0x0
    //IOAPIC_IRQR_HIGH irqr_high = {};
    irqr_low.packed = ioapic_read_register(ioapic_base, 0x10 + (i * 2));
  10b7e4:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10b7e8:	48 83 c0 08          	add    rax,0x8
  10b7ec:	01 c0                	add    eax,eax
  10b7ee:	0f b6 d0             	movzx  edx,al
  10b7f1:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10b7f5:	89 d6                	mov    esi,edx
  10b7f7:	48 89 c7             	mov    rdi,rax
  10b7fa:	e8 83 e3 ff ff       	call   109b82 <ioapic_read_register>
  10b7ff:	89 45 f0             	mov    DWORD PTR [rbp-0x10],eax
    //irqr_high.packed = ioapic_read_register(ioapic_base, 0x10 + (i * 2) + 1);
    klog_debug("IRQ %u", (uint32_t)i);
  10b802:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10b806:	89 c2                	mov    edx,eax
  10b808:	be a5 7b 10 00       	mov    esi,0x107ba5
  10b80d:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b812:	b8 00 00 00 00       	mov    eax,0x0
  10b817:	e8 4b 14 00 00       	call   10cc67 <klog_write_fmt>
    klog_debug("  vector: %u", (uint32_t)irqr_low.vector);
  10b81c:	0f b6 45 f0          	movzx  eax,BYTE PTR [rbp-0x10]
  10b820:	0f b6 c0             	movzx  eax,al
  10b823:	89 c2                	mov    edx,eax
  10b825:	be ac 7b 10 00       	mov    esi,0x107bac
  10b82a:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b82f:	b8 00 00 00 00       	mov    eax,0x0
  10b834:	e8 2e 14 00 00       	call   10cc67 <klog_write_fmt>
    klog_debug("  mask %u", (uint32_t)irqr_low.mask);
  10b839:	0f b6 45 f1          	movzx  eax,BYTE PTR [rbp-0xf]
  10b83d:	c0 e8 07             	shr    al,0x7
  10b840:	0f b6 c0             	movzx  eax,al
  10b843:	89 c2                	mov    edx,eax
  10b845:	be b9 7b 10 00       	mov    esi,0x107bb9
  10b84a:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b84f:	b8 00 00 00 00       	mov    eax,0x0
  10b854:	e8 0e 14 00 00       	call   10cc67 <klog_write_fmt>
  for(size_t i = 0; i < 8; i++){
  10b859:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10b85e:	48 83 7d f8 07       	cmp    QWORD PTR [rbp-0x8],0x7
  10b863:	0f 86 74 ff ff ff    	jbe    10b7dd <kdebug_ioapic_log_irq_map+0x19>
  }
}
  10b869:	90                   	nop
  10b86a:	c9                   	leave  
  10b86b:	c3                   	ret    

000000000010b86c <kdebug_log_page_table_entry_info>:


static void
kdebug_log_page_table_entry_info(const uintptr_t entry){
  10b86c:	55                   	push   rbp
  10b86d:	48 89 e5             	mov    rbp,rsp
  10b870:	48 83 ec 20          	sub    rsp,0x20
  10b874:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  uintptr_t physical_address = entry & ~0xFFF;
  10b878:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10b87c:	48 25 00 f0 ff ff    	and    rax,0xfffffffffffff000
  10b882:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  bool is_present = entry & PAGE_PRESENT_BIT;
  10b886:	b8 01 00 00 00       	mov    eax,0x1
  10b88b:	48 23 45 e8          	and    rax,QWORD PTR [rbp-0x18]
  10b88f:	48 85 c0             	test   rax,rax
  10b892:	0f 95 c0             	setne  al
  10b895:	88 45 f7             	mov    BYTE PTR [rbp-0x9],al
  bool is_writeable = entry & PAGE_WRITEABLE_BIT;
  10b898:	b8 02 00 00 00       	mov    eax,0x2
  10b89d:	48 23 45 e8          	and    rax,QWORD PTR [rbp-0x18]
  10b8a1:	48 85 c0             	test   rax,rax
  10b8a4:	0f 95 c0             	setne  al
  10b8a7:	88 45 f6             	mov    BYTE PTR [rbp-0xa],al
  bool access_mode = entry & PAGE_USER_ACCESS_BIT;
  10b8aa:	b8 04 00 00 00       	mov    eax,0x4
  10b8af:	48 23 45 e8          	and    rax,QWORD PTR [rbp-0x18]
  10b8b3:	48 85 c0             	test   rax,rax
  10b8b6:	0f 95 c0             	setne  al
  10b8b9:	88 45 f5             	mov    BYTE PTR [rbp-0xb],al
  bool is_write_through_caching = entry & PAGE_WRITE_TROUGH_CACHE_BIT;
  10b8bc:	b8 08 00 00 00       	mov    eax,0x8
  10b8c1:	48 23 45 e8          	and    rax,QWORD PTR [rbp-0x18]
  10b8c5:	48 85 c0             	test   rax,rax
  10b8c8:	0f 95 c0             	setne  al
  10b8cb:	88 45 f4             	mov    BYTE PTR [rbp-0xc],al
  bool is_caching_disabled = entry & PAGE_DISABLE_CACHE_BIT;
  10b8ce:	b8 10 00 00 00       	mov    eax,0x10
  10b8d3:	48 23 45 e8          	and    rax,QWORD PTR [rbp-0x18]
  10b8d7:	48 85 c0             	test   rax,rax
  10b8da:	0f 95 c0             	setne  al
  10b8dd:	88 45 f3             	mov    BYTE PTR [rbp-0xd],al
  bool is_huge_page = entry & PAGE_HUGE_BIT;
  10b8e0:	b8 80 00 00 00       	mov    eax,0x80
  10b8e5:	48 23 45 e8          	and    rax,QWORD PTR [rbp-0x18]
  10b8e9:	48 85 c0             	test   rax,rax
  10b8ec:	0f 95 c0             	setne  al
  10b8ef:	88 45 f2             	mov    BYTE PTR [rbp-0xe],al
  klog_debug("physical_address: 0x%X", physical_address);
  10b8f2:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10b8f6:	48 89 c2             	mov    rdx,rax
  10b8f9:	be c3 7b 10 00       	mov    esi,0x107bc3
  10b8fe:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b903:	b8 00 00 00 00       	mov    eax,0x0
  10b908:	e8 5a 13 00 00       	call   10cc67 <klog_write_fmt>
  klog_debug("present: %s", is_present ? "true" : "false");
  10b90d:	80 7d f7 00          	cmp    BYTE PTR [rbp-0x9],0x0
  10b911:	74 07                	je     10b91a <kdebug_log_page_table_entry_info+0xae>
  10b913:	b8 86 63 10 00       	mov    eax,0x106386
  10b918:	eb 05                	jmp    10b91f <kdebug_log_page_table_entry_info+0xb3>
  10b91a:	b8 8b 63 10 00       	mov    eax,0x10638b
  10b91f:	48 89 c2             	mov    rdx,rax
  10b922:	be da 7b 10 00       	mov    esi,0x107bda
  10b927:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b92c:	b8 00 00 00 00       	mov    eax,0x0
  10b931:	e8 31 13 00 00       	call   10cc67 <klog_write_fmt>
  klog_debug("writeable: %s", is_writeable ? "true" : "false");
  10b936:	80 7d f6 00          	cmp    BYTE PTR [rbp-0xa],0x0
  10b93a:	74 07                	je     10b943 <kdebug_log_page_table_entry_info+0xd7>
  10b93c:	b8 86 63 10 00       	mov    eax,0x106386
  10b941:	eb 05                	jmp    10b948 <kdebug_log_page_table_entry_info+0xdc>
  10b943:	b8 8b 63 10 00       	mov    eax,0x10638b
  10b948:	48 89 c2             	mov    rdx,rax
  10b94b:	be e6 7b 10 00       	mov    esi,0x107be6
  10b950:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b955:	b8 00 00 00 00       	mov    eax,0x0
  10b95a:	e8 08 13 00 00       	call   10cc67 <klog_write_fmt>
  klog_debug("user accessiable: %s", access_mode ? "true" : "false");
  10b95f:	80 7d f5 00          	cmp    BYTE PTR [rbp-0xb],0x0
  10b963:	74 07                	je     10b96c <kdebug_log_page_table_entry_info+0x100>
  10b965:	b8 86 63 10 00       	mov    eax,0x106386
  10b96a:	eb 05                	jmp    10b971 <kdebug_log_page_table_entry_info+0x105>
  10b96c:	b8 8b 63 10 00       	mov    eax,0x10638b
  10b971:	48 89 c2             	mov    rdx,rax
  10b974:	be f4 7b 10 00       	mov    esi,0x107bf4
  10b979:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b97e:	b8 00 00 00 00       	mov    eax,0x0
  10b983:	e8 df 12 00 00       	call   10cc67 <klog_write_fmt>
  klog_debug("write through caching: %s", is_write_through_caching ? "true" : "false");
  10b988:	80 7d f4 00          	cmp    BYTE PTR [rbp-0xc],0x0
  10b98c:	74 07                	je     10b995 <kdebug_log_page_table_entry_info+0x129>
  10b98e:	b8 86 63 10 00       	mov    eax,0x106386
  10b993:	eb 05                	jmp    10b99a <kdebug_log_page_table_entry_info+0x12e>
  10b995:	b8 8b 63 10 00       	mov    eax,0x10638b
  10b99a:	48 89 c2             	mov    rdx,rax
  10b99d:	be 09 7c 10 00       	mov    esi,0x107c09
  10b9a2:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b9a7:	b8 00 00 00 00       	mov    eax,0x0
  10b9ac:	e8 b6 12 00 00       	call   10cc67 <klog_write_fmt>
  klog_debug("caching disabled: %s", is_caching_disabled ? "true" : "false");
  10b9b1:	80 7d f3 00          	cmp    BYTE PTR [rbp-0xd],0x0
  10b9b5:	74 07                	je     10b9be <kdebug_log_page_table_entry_info+0x152>
  10b9b7:	b8 86 63 10 00       	mov    eax,0x106386
  10b9bc:	eb 05                	jmp    10b9c3 <kdebug_log_page_table_entry_info+0x157>
  10b9be:	b8 8b 63 10 00       	mov    eax,0x10638b
  10b9c3:	48 89 c2             	mov    rdx,rax
  10b9c6:	be 23 7c 10 00       	mov    esi,0x107c23
  10b9cb:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b9d0:	b8 00 00 00 00       	mov    eax,0x0
  10b9d5:	e8 8d 12 00 00       	call   10cc67 <klog_write_fmt>
  klog_debug("huge page: %s", is_huge_page ? "true" : "false"); 
  10b9da:	80 7d f2 00          	cmp    BYTE PTR [rbp-0xe],0x0
  10b9de:	74 07                	je     10b9e7 <kdebug_log_page_table_entry_info+0x17b>
  10b9e0:	b8 86 63 10 00       	mov    eax,0x106386
  10b9e5:	eb 05                	jmp    10b9ec <kdebug_log_page_table_entry_info+0x180>
  10b9e7:	b8 8b 63 10 00       	mov    eax,0x10638b
  10b9ec:	48 89 c2             	mov    rdx,rax
  10b9ef:	be 38 7c 10 00       	mov    esi,0x107c38
  10b9f4:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b9f9:	b8 00 00 00 00       	mov    eax,0x0
  10b9fe:	e8 64 12 00 00       	call   10cc67 <klog_write_fmt>
}
  10ba03:	90                   	nop
  10ba04:	c9                   	leave  
  10ba05:	c3                   	ret    

000000000010ba06 <kdebug_log_virtual_address_info_2MB>:

static void 
kdebug_log_virtual_address_info_2MB(const uintptr_t virtual_address){
  10ba06:	55                   	push   rbp
  10ba07:	48 89 e5             	mov    rbp,rsp
  10ba0a:	48 83 ec 30          	sub    rsp,0x30
  10ba0e:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  uint64_t p4_index = (virtual_address >> 39) & 0x1FF;
  10ba12:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10ba16:	48 c1 e8 27          	shr    rax,0x27
  10ba1a:	25 ff 01 00 00       	and    eax,0x1ff
  10ba1f:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  uint64_t p3_index = (virtual_address >> 30) & 0x1FF;
  10ba23:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10ba27:	48 c1 e8 1e          	shr    rax,0x1e
  10ba2b:	25 ff 01 00 00       	and    eax,0x1ff
  10ba30:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
  uint64_t p2_index = (virtual_address >> 21) & 0x1FF;
  10ba34:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10ba38:	48 c1 e8 15          	shr    rax,0x15
  10ba3c:	25 ff 01 00 00       	and    eax,0x1ff
  10ba41:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
  uint64_t offset   = (virtual_address >> 0)  & 0xFFFFF;
  10ba45:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10ba49:	25 ff ff 0f 00       	and    eax,0xfffff
  10ba4e:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax

  klog_debug("logging virtual address info");
  10ba52:	be 46 7c 10 00       	mov    esi,0x107c46
  10ba57:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ba5c:	b8 00 00 00 00       	mov    eax,0x0
  10ba61:	e8 01 12 00 00       	call   10cc67 <klog_write_fmt>
  klog_debug(" virtual_address: 0x%X", virtual_address);
  10ba66:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10ba6a:	48 89 c2             	mov    rdx,rax
  10ba6d:	be 63 7c 10 00       	mov    esi,0x107c63
  10ba72:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ba77:	b8 00 00 00 00       	mov    eax,0x0
  10ba7c:	e8 e6 11 00 00       	call   10cc67 <klog_write_fmt>
  klog_debug(" p4_index: %lu", p4_index);
  10ba81:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10ba85:	48 89 c2             	mov    rdx,rax
  10ba88:	be 7a 7c 10 00       	mov    esi,0x107c7a
  10ba8d:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ba92:	b8 00 00 00 00       	mov    eax,0x0
  10ba97:	e8 cb 11 00 00       	call   10cc67 <klog_write_fmt>
  klog_debug(" p3_index: %lu", p3_index);
  10ba9c:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10baa0:	48 89 c2             	mov    rdx,rax
  10baa3:	be 89 7c 10 00       	mov    esi,0x107c89
  10baa8:	bf 00 e0 10 00       	mov    edi,0x10e000
  10baad:	b8 00 00 00 00       	mov    eax,0x0
  10bab2:	e8 b0 11 00 00       	call   10cc67 <klog_write_fmt>
  klog_debug(" p2_index: %lu", p2_index);
  10bab7:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10babb:	48 89 c2             	mov    rdx,rax
  10babe:	be 98 7c 10 00       	mov    esi,0x107c98
  10bac3:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bac8:	b8 00 00 00 00       	mov    eax,0x0
  10bacd:	e8 95 11 00 00       	call   10cc67 <klog_write_fmt>
  klog_debug(" offset: %lu", offset);
  10bad2:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10bad6:	48 89 c2             	mov    rdx,rax
  10bad9:	be a7 7c 10 00       	mov    esi,0x107ca7
  10bade:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bae3:	b8 00 00 00 00       	mov    eax,0x0
  10bae8:	e8 7a 11 00 00       	call   10cc67 <klog_write_fmt>

  klog_debug(" p4_entry_info:");
  10baed:	be b4 7c 10 00       	mov    esi,0x107cb4
  10baf2:	bf 00 e0 10 00       	mov    edi,0x10e000
  10baf7:	b8 00 00 00 00       	mov    eax,0x0
  10bafc:	e8 66 11 00 00       	call   10cc67 <klog_write_fmt>
  kdebug_log_page_table_entry_info(g_p4_table.entries[p4_index]);
  10bb01:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bb05:	48 8b 04 c5 00 20 12 	mov    rax,QWORD PTR [rax*8+0x122000]
  10bb0c:	00 
  10bb0d:	48 89 c7             	mov    rdi,rax
  10bb10:	e8 57 fd ff ff       	call   10b86c <kdebug_log_page_table_entry_info>
  klog_debug(" p3_entry_info:");
  10bb15:	be c4 7c 10 00       	mov    esi,0x107cc4
  10bb1a:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bb1f:	b8 00 00 00 00       	mov    eax,0x0
  10bb24:	e8 3e 11 00 00       	call   10cc67 <klog_write_fmt>
  kdebug_log_page_table_entry_info(g_p3_table.entries[p3_index]);
  10bb29:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10bb2d:	48 8b 04 c5 00 30 12 	mov    rax,QWORD PTR [rax*8+0x123000]
  10bb34:	00 
  10bb35:	48 89 c7             	mov    rdi,rax
  10bb38:	e8 2f fd ff ff       	call   10b86c <kdebug_log_page_table_entry_info>
  klog_debug(" p2_entry_info:");
  10bb3d:	be d4 7c 10 00       	mov    esi,0x107cd4
  10bb42:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bb47:	b8 00 00 00 00       	mov    eax,0x0
  10bb4c:	e8 16 11 00 00       	call   10cc67 <klog_write_fmt>
  kdebug_log_page_table_entry_info(g_p2_table.entries[p2_index]);
  10bb51:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bb55:	48 8b 04 c5 00 40 12 	mov    rax,QWORD PTR [rax*8+0x124000]
  10bb5c:	00 
  10bb5d:	48 89 c7             	mov    rdi,rax
  10bb60:	e8 07 fd ff ff       	call   10b86c <kdebug_log_page_table_entry_info>
}
  10bb65:	90                   	nop
  10bb66:	c9                   	leave  
  10bb67:	c3                   	ret    

000000000010bb68 <kdebug_log_page_info>:

static void
kdebug_log_page_info() {
  10bb68:	55                   	push   rbp
  10bb69:	48 89 e5             	mov    rbp,rsp
  10bb6c:	48 83 ec 20          	sub    rsp,0x20
  for(size_t i = 0; i < g_current_page_index; i++){
  10bb70:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10bb77:	00 
  10bb78:	eb 61                	jmp    10bbdb <kdebug_log_page_info+0x73>
    bool is_present = g_p2_table.entries[i] & 0b01;
  10bb7a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bb7e:	48 8b 04 c5 00 40 12 	mov    rax,QWORD PTR [rax*8+0x124000]
  10bb85:	00 
  10bb86:	83 e0 01             	and    eax,0x1
  10bb89:	48 85 c0             	test   rax,rax
  10bb8c:	0f 95 c0             	setne  al
  10bb8f:	88 45 f7             	mov    BYTE PTR [rbp-0x9],al
    uintptr_t physical_address = g_p2_table.entries[i] & ~(0b111111111111);
  10bb92:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bb96:	48 8b 04 c5 00 40 12 	mov    rax,QWORD PTR [rax*8+0x124000]
  10bb9d:	00 
  10bb9e:	48 25 00 f0 ff ff    	and    rax,0xfffffffffffff000
  10bba4:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
    uintptr_t virtual_address = i * 1024 * 1024 * 2;
  10bba8:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bbac:	48 c1 e0 15          	shl    rax,0x15
  10bbb0:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
    klog_debug("page_entry: virtual %lu mapped to %lu", virtual_address, physical_address);
  10bbb4:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  10bbb8:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10bbbc:	48 89 d1             	mov    rcx,rdx
  10bbbf:	48 89 c2             	mov    rdx,rax
  10bbc2:	be e8 7c 10 00       	mov    esi,0x107ce8
  10bbc7:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bbcc:	b8 00 00 00 00       	mov    eax,0x0
  10bbd1:	e8 91 10 00 00       	call   10cc67 <klog_write_fmt>
  for(size_t i = 0; i < g_current_page_index; i++){
  10bbd6:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10bbdb:	8b 05 1f 44 01 00    	mov    eax,DWORD PTR [rip+0x1441f]        # 120000 <g_current_page_index>
  10bbe1:	89 c0                	mov    eax,eax
  10bbe3:	48 3b 45 f8          	cmp    rax,QWORD PTR [rbp-0x8]
  10bbe7:	77 91                	ja     10bb7a <kdebug_log_page_info+0x12>
  }
}
  10bbe9:	90                   	nop
  10bbea:	c9                   	leave  
  10bbeb:	c3                   	ret    

000000000010bbec <kernel_longmode_entry>:
#include "kernel_debug.c"

extern void asm_enter_usermode(uintptr_t address_to_execute, uintptr_t stack_pointer);

extern void 
kernel_longmode_entry(uint64_t multiboot2_magic, uint64_t multiboot2_address) {
  10bbec:	55                   	push   rbp
  10bbed:	48 89 e5             	mov    rbp,rsp
  10bbf0:	48 83 ec 70          	sub    rsp,0x70
  10bbf4:	48 89 7d 98          	mov    QWORD PTR [rbp-0x68],rdi
  10bbf8:	48 89 75 90          	mov    QWORD PTR [rbp-0x70],rsi
	serial_debug_init();
  10bbfc:	b8 00 00 00 00       	mov    eax,0x0
  10bc01:	e8 61 ec ff ff       	call   10a867 <serial_debug_init>
	legacy_pic8259_initalize();
  10bc06:	e8 3a e7 ff ff       	call   10a345 <legacy_pic8259_initalize>
	x86_64_idt_initalize();
  10bc0b:	b8 00 00 00 00       	mov    eax,0x0
  10bc10:	e8 32 e9 ff ff       	call   10a547 <x86_64_idt_initalize>
  kmem_initalize();
  10bc15:	b8 00 00 00 00       	mov    eax,0x0
  10bc1a:	e8 ec ef ff ff       	call   10ac0b <kmem_initalize>

  //NOTE(Torin) Setup keyboard event stack
  globals.keyboard.scancode_event_stack = globals.keyboard.scancode_event_stack0;
  10bc1f:	48 c7 05 1e 2a 01 00 	mov    QWORD PTR [rip+0x12a1e],0x11e650        # 11e648 <globals+0x10648>
  10bc26:	50 e6 11 00 


	if (multiboot2_magic != MULTIBOOT2_BOOTLOADER_MAGIC) {
  10bc2a:	48 81 7d 98 89 62 d7 	cmp    QWORD PTR [rbp-0x68],0x36d76289
  10bc31:	36 
  10bc32:	74 20                	je     10bc54 <kernel_longmode_entry+0x68>
		klog_error("the kernel was not booted with a multiboot2 compliant bootloader!");
  10bc34:	be 10 7d 10 00       	mov    esi,0x107d10
  10bc39:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bc3e:	b8 00 00 00 00       	mov    eax,0x0
  10bc43:	e8 1f 10 00 00       	call   10cc67 <klog_write_fmt>
		kpanic();
  10bc48:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bc4d:	e8 cc d9 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10bc52:	fa                   	cli    
  10bc53:	f4                   	hlt    
	}

	if (multiboot2_address & 7) {
  10bc54:	48 8b 45 90          	mov    rax,QWORD PTR [rbp-0x70]
  10bc58:	83 e0 07             	and    eax,0x7
  10bc5b:	48 85 c0             	test   rax,rax
  10bc5e:	74 20                	je     10bc80 <kernel_longmode_entry+0x94>
		klog_error("unaligned multiboot_info!");
  10bc60:	be 52 7d 10 00       	mov    esi,0x107d52
  10bc65:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bc6a:	b8 00 00 00 00       	mov    eax,0x0
  10bc6f:	e8 f3 0f 00 00       	call   10cc67 <klog_write_fmt>
		kpanic();
  10bc74:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bc79:	e8 a0 d9 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10bc7e:	fa                   	cli    
  10bc7f:	f4                   	hlt    
	}

  struct multiboot_tag_framebuffer *fb_mbtag = 0; 
  10bc80:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10bc87:	00 
  uintptr_t rsdp_physical_address = 0;
  10bc88:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
  10bc8f:	00 
	struct multiboot_tag *tag = (struct multiboot_tag *)(multiboot2_address + 8);
  10bc90:	48 8b 45 90          	mov    rax,QWORD PTR [rbp-0x70]
  10bc94:	48 83 c0 08          	add    rax,0x8
  10bc98:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
	while (tag->type != MULTIBOOT_TAG_TYPE_END) {
  10bc9c:	eb 5f                	jmp    10bcfd <kernel_longmode_entry+0x111>
		switch (tag->type) {
  10bc9e:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bca2:	8b 00                	mov    eax,DWORD PTR [rax]
  10bca4:	83 f8 0e             	cmp    eax,0xe
  10bca7:	74 0c                	je     10bcb5 <kernel_longmode_entry+0xc9>
  10bca9:	83 f8 0f             	cmp    eax,0xf
  10bcac:	74 1d                	je     10bccb <kernel_longmode_entry+0xdf>
  10bcae:	83 f8 08             	cmp    eax,0x8
  10bcb1:	74 2e                	je     10bce1 <kernel_longmode_entry+0xf5>
  10bcb3:	eb 35                	jmp    10bcea <kernel_longmode_entry+0xfe>
			case MULTIBOOT_TAG_TYPE_ACPI_OLD: {
		    struct multiboot_tag_old_acpi *acpi_info = (struct multiboot_tag_old_acpi *)(tag);
  10bcb5:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bcb9:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
        rsdp_physical_address = (uintptr_t)acpi_info->rsdp;
  10bcbd:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10bcc1:	48 83 c0 08          	add    rax,0x8
  10bcc5:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
			} break;
  10bcc9:	eb 1f                	jmp    10bcea <kernel_longmode_entry+0xfe>
			case MULTIBOOT_TAG_TYPE_ACPI_NEW: {
				struct multiboot_tag_new_acpi *acpi_info = (struct multiboot_tag_new_acpi *)(tag);
  10bccb:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bccf:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
        rsdp_physical_address = (uintptr_t)acpi_info->rsdp;
  10bcd3:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10bcd7:	48 83 c0 08          	add    rax,0x8
  10bcdb:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
			} break;
  10bcdf:	eb 09                	jmp    10bcea <kernel_longmode_entry+0xfe>

      case MULTIBOOT_TAG_TYPE_FRAMEBUFFER: {
        fb_mbtag = (struct multiboot_tag_framebuffer *)(tag);
  10bce1:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bce5:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
      } break;
  10bce9:	90                   	nop
        }
        #endif
      };

		}
		tag = (struct multiboot_tag *)(((uint8_t *)tag) + ((tag->size + 7) & ~7));
  10bcea:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bcee:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
  10bcf1:	83 c0 07             	add    eax,0x7
  10bcf4:	89 c0                	mov    eax,eax
  10bcf6:	83 e0 f8             	and    eax,0xfffffff8
  10bcf9:	48 01 45 e8          	add    QWORD PTR [rbp-0x18],rax
	while (tag->type != MULTIBOOT_TAG_TYPE_END) {
  10bcfd:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bd01:	8b 00                	mov    eax,DWORD PTR [rax]
  10bd03:	85 c0                	test   eax,eax
  10bd05:	75 97                	jne    10bc9e <kernel_longmode_entry+0xb2>
	}

  //NOTE(Torin) Initalize the framebuffer
  if(fb_mbtag == 0) {
  10bd07:	48 83 7d f8 00       	cmp    QWORD PTR [rbp-0x8],0x0
  10bd0c:	75 30                	jne    10bd3e <kernel_longmode_entry+0x152>
    kassert(0 && "MULTIBOOT FAILED TO PROVIDE FRAMEBUFFER TAG");
  10bd0e:	41 b8 6c 7d 10 00    	mov    r8d,0x107d6c
  10bd14:	b9 38 01 00 00       	mov    ecx,0x138
  10bd19:	ba 80 7d 10 00       	mov    edx,0x107d80
  10bd1e:	be 38 61 10 00       	mov    esi,0x106138
  10bd23:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bd28:	b8 00 00 00 00       	mov    eax,0x0
  10bd2d:	e8 35 0f 00 00       	call   10cc67 <klog_write_fmt>
  10bd32:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bd37:	e8 e2 d8 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10bd3c:	fa                   	cli    
  10bd3d:	f4                   	hlt    
  }

  if(fb_mbtag->common.framebuffer_type != MULTIBOOT_FRAMEBUFFER_TYPE_RGB){
  10bd3e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bd42:	0f b6 40 1d          	movzx  eax,BYTE PTR [rax+0x1d]
  10bd46:	3c 01                	cmp    al,0x1
  10bd48:	74 19                	je     10bd63 <kernel_longmode_entry+0x177>
    klog_info("this is a text buffer");
  10bd4a:	be b3 7d 10 00       	mov    esi,0x107db3
  10bd4f:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bd54:	b8 00 00 00 00       	mov    eax,0x0
  10bd59:	e8 09 0f 00 00       	call   10cc67 <klog_write_fmt>
  10bd5e:	e9 cf 00 00 00       	jmp    10be32 <kernel_longmode_entry+0x246>
  } else {
    uintptr_t framebuffer_virtual_address = 0x0A000000;
  10bd63:	48 c7 45 d0 00 00 00 	mov    QWORD PTR [rbp-0x30],0xa000000
  10bd6a:	0a 
    uintptr_t page_offset = kmem_map_unaligned_physical_to_aligned_virtual_2MB(fb_mbtag->common.framebuffer_addr, framebuffer_virtual_address);
  10bd6b:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bd6f:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10bd73:	48 8b 55 d0          	mov    rdx,QWORD PTR [rbp-0x30]
  10bd77:	48 89 d6             	mov    rsi,rdx
  10bd7a:	48 89 c7             	mov    rdi,rax
  10bd7d:	e8 43 ee ff ff       	call   10abc5 <kmem_map_unaligned_physical_to_aligned_virtual_2MB>
  10bd82:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
    kmem_map_physical_to_virtual_2MB(fb_mbtag->common.framebuffer_addr - page_offset + 0x200000, framebuffer_virtual_address + 0x200000);
  10bd86:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10bd8a:	48 8d 90 00 00 20 00 	lea    rdx,[rax+0x200000]
  10bd91:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bd95:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10bd99:	48 2b 45 c8          	sub    rax,QWORD PTR [rbp-0x38]
  10bd9d:	48 05 00 00 20 00    	add    rax,0x200000
  10bda3:	48 89 d6             	mov    rsi,rdx
  10bda6:	48 89 c7             	mov    rdi,rax
  10bda9:	e8 b1 ec ff ff       	call   10aa5f <kmem_map_physical_to_virtual_2MB>

    Framebuffer *fb = &globals.framebuffer;
  10bdae:	48 c7 45 c0 48 e7 11 	mov    QWORD PTR [rbp-0x40],0x11e748
  10bdb5:	00 
    fb->width = fb_mbtag->common.framebuffer_width; 
  10bdb6:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bdba:	8b 50 14             	mov    edx,DWORD PTR [rax+0x14]
  10bdbd:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10bdc1:	89 10                	mov    DWORD PTR [rax],edx
    fb->height = fb_mbtag->common.framebuffer_height;
  10bdc3:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bdc7:	8b 50 18             	mov    edx,DWORD PTR [rax+0x18]
  10bdca:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10bdce:	89 50 04             	mov    DWORD PTR [rax+0x4],edx
    fb->buffer = (uint8_t *)framebuffer_virtual_address;
  10bdd1:	48 8b 55 d0          	mov    rdx,QWORD PTR [rbp-0x30]
  10bdd5:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10bdd9:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
    fb->depth = fb_mbtag->common.framebuffer_bpp / 8; 
  10bddd:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bde1:	0f b6 40 1c          	movzx  eax,BYTE PTR [rax+0x1c]
  10bde5:	c0 e8 03             	shr    al,0x3
  10bde8:	89 c2                	mov    edx,eax
  10bdea:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10bdee:	88 50 0c             	mov    BYTE PTR [rax+0xc],dl
    fb->pitch = fb_mbtag->common.framebuffer_pitch; 
  10bdf1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bdf5:	8b 50 10             	mov    edx,DWORD PTR [rax+0x10]
  10bdf8:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10bdfc:	89 50 08             	mov    DWORD PTR [rax+0x8],edx
    klog_debug("framebuffer: width: %u, height: %u, depth: %u", fb->width, fb->height, (uint32_t)fb->depth);
  10bdff:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10be03:	0f b6 40 0c          	movzx  eax,BYTE PTR [rax+0xc]
  10be07:	0f b6 c8             	movzx  ecx,al
  10be0a:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10be0e:	8b 50 04             	mov    edx,DWORD PTR [rax+0x4]
  10be11:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10be15:	8b 00                	mov    eax,DWORD PTR [rax]
  10be17:	41 89 c8             	mov    r8d,ecx
  10be1a:	89 d1                	mov    ecx,edx
  10be1c:	89 c2                	mov    edx,eax
  10be1e:	be d0 7d 10 00       	mov    esi,0x107dd0
  10be23:	bf 00 e0 10 00       	mov    edi,0x10e000
  10be28:	b8 00 00 00 00       	mov    eax,0x0
  10be2d:	e8 35 0e 00 00       	call   10cc67 <klog_write_fmt>
  }


  if(rsdp_physical_address == 0){
  10be32:	48 83 7d f0 00       	cmp    QWORD PTR [rbp-0x10],0x0
  10be37:	75 30                	jne    10be69 <kernel_longmode_entry+0x27d>
    kassert(0 && "MULTIBOOT FAILED TO PROVIDE LOCATION OF RSDP");
  10be39:	41 b8 6c 7d 10 00    	mov    r8d,0x107d6c
  10be3f:	b9 4d 01 00 00       	mov    ecx,0x14d
  10be44:	ba 00 7e 10 00       	mov    edx,0x107e00
  10be49:	be 38 61 10 00       	mov    esi,0x106138
  10be4e:	bf 00 e0 10 00       	mov    edi,0x10e000
  10be53:	b8 00 00 00 00       	mov    eax,0x0
  10be58:	e8 0a 0e 00 00       	call   10cc67 <klog_write_fmt>
  10be5d:	bf 00 e0 10 00       	mov    edi,0x10e000
  10be62:	e8 b7 d7 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10be67:	fa                   	cli    
  10be68:	f4                   	hlt    
  }

  System_Info *sys = &globals.system_info;
  10be69:	48 c7 45 b8 90 e6 11 	mov    QWORD PTR [rbp-0x48],0x11e690
  10be70:	00 
  parse_root_system_descriptor((RSDP_Descriptor_1*)rsdp_physical_address, sys);
  10be71:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10be75:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  10be79:	48 89 d6             	mov    rsi,rdx
  10be7c:	48 89 c7             	mov    rdi,rax
  10be7f:	e8 bc d9 ff ff       	call   109840 <parse_root_system_descriptor>
  //NOTE(Torin) Tasking relating thingy-things

  //TODO(Torin 2016-08-29) This should probably be established after
  //the other cpus are initalized
  extern uintptr_t stack_top;
  uintptr_t stack_top_ptr = (uintptr_t)&stack_top;
  10be84:	48 c7 45 b0 02 70 12 	mov    QWORD PTR [rbp-0x50],0x127002
  10be8b:	00 
  sys->kernel_stack_address = stack_top_ptr;
  10be8c:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10be90:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
  10be94:	48 89 50 20          	mov    QWORD PTR [rax+0x20],rdx
  memset(&g_tss_entry, 0x00, sizeof(g_tss_entry));
  10be98:	ba 6c 00 00 00       	mov    edx,0x6c
  10be9d:	be 00 00 00 00       	mov    esi,0x0
  10bea2:	bf 80 e7 11 00       	mov    edi,0x11e780
  10bea7:	e8 54 d1 ff ff       	call   109000 <__memset>
  g_tss_entry.rsp0 = stack_top_ptr;
  10beac:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  10beb0:	48 89 05 cd 28 01 00 	mov    QWORD PTR [rip+0x128cd],rax        # 11e784 <g_tss_entry+0x4>
  g_tss_entry.ist1 = stack_top_ptr;
  10beb7:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  10bebb:	48 89 05 e2 28 01 00 	mov    QWORD PTR [rip+0x128e2],rax        # 11e7a4 <g_tss_entry+0x24>
  klog_debug("tss rsp0: 0x%X", g_tss_entry.rsp0);
  10bec2:	48 8b 05 bb 28 01 00 	mov    rax,QWORD PTR [rip+0x128bb]        # 11e784 <g_tss_entry+0x4>
  10bec9:	48 89 c2             	mov    rdx,rax
  10becc:	be 34 7e 10 00       	mov    esi,0x107e34
  10bed1:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bed6:	b8 00 00 00 00       	mov    eax,0x0
  10bedb:	e8 87 0d 00 00       	call   10cc67 <klog_write_fmt>
  uint8_t *gdt = (uint8_t *)&GDT64;
  10bee0:	48 c7 45 a8 d0 8b 10 	mov    QWORD PTR [rbp-0x58],0x108bd0
  10bee7:	00 
  gdt_encode_system_descriptor((uintptr_t)&g_tss_entry, 0xFF, GDT_DESCRIPTOR_TYPE_TSS, 3, (uintptr_t)(gdt + GDT_TSS));
  10bee8:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  10beec:	48 83 c0 28          	add    rax,0x28
  10bef0:	48 89 c2             	mov    rdx,rax
  10bef3:	b8 80 e7 11 00       	mov    eax,0x11e780
  10bef8:	49 89 d0             	mov    r8,rdx
  10befb:	b9 03 00 00 00       	mov    ecx,0x3
  10bf00:	ba 09 00 00 00       	mov    edx,0x9
  10bf05:	be ff 00 00 00       	mov    esi,0xff
  10bf0a:	48 89 c7             	mov    rdi,rax
  10bf0d:	e8 a7 df ff ff       	call   109eb9 <gdt_encode_system_descriptor>
  tss_ldr(GDT_TSS);
  10bf12:	bf 28 00 00 00       	mov    edi,0x28
  10bf17:	e8 e8 e1 ff ff       	call   10a104 <tss_ldr>
  
  //TODO(Torin) Real page allocator
  //NOTE(Torin) Arbitrarly maps the lapic and ioapic into the kernels virtual addresss space
  //And initalizes the iopapic and lapic
  sys->lapic_virtual_address = 0x0C200000;
  10bf1c:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bf20:	48 c7 40 10 00 00 20 	mov    QWORD PTR [rax+0x10],0xc200000
  10bf27:	0c 
  sys->ioapic_virtual_address = 0x0C400000;
  10bf28:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bf2c:	48 c7 40 18 00 00 40 	mov    QWORD PTR [rax+0x18],0xc400000
  10bf33:	0c 
  kmem_map_physical_to_virtual_2MB(sys->lapic_physical_address, sys->lapic_virtual_address);
  10bf34:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bf38:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10bf3c:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bf40:	48 8b 00             	mov    rax,QWORD PTR [rax]
  10bf43:	48 89 d6             	mov    rsi,rdx
  10bf46:	48 89 c7             	mov    rdi,rax
  10bf49:	e8 11 eb ff ff       	call   10aa5f <kmem_map_physical_to_virtual_2MB>
  kmem_map_physical_to_virtual_2MB(sys->ioapic_physical_address, sys->ioapic_virtual_address);
  10bf4e:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bf52:	48 8b 50 18          	mov    rdx,QWORD PTR [rax+0x18]
  10bf56:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bf5a:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10bf5e:	48 89 d6             	mov    rsi,rdx
  10bf61:	48 89 c7             	mov    rdi,rax
  10bf64:	e8 f6 ea ff ff       	call   10aa5f <kmem_map_physical_to_virtual_2MB>
  klog_debug("ioapic: physical = 0x%X, virtual = 0x%X", sys->ioapic_physical_address, sys->lapic_virtual_address);
  10bf69:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bf6d:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10bf71:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bf75:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10bf79:	48 89 d1             	mov    rcx,rdx
  10bf7c:	48 89 c2             	mov    rdx,rax
  10bf7f:	be 48 7e 10 00       	mov    esi,0x107e48
  10bf84:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bf89:	b8 00 00 00 00       	mov    eax,0x0
  10bf8e:	e8 d4 0c 00 00       	call   10cc67 <klog_write_fmt>
  klog_debug("lapic: physical = 0x%X, virtual = 0x%X", sys->lapic_physical_address, sys->ioapic_virtual_address);
  10bf93:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bf97:	48 8b 50 18          	mov    rdx,QWORD PTR [rax+0x18]
  10bf9b:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bf9f:	48 8b 00             	mov    rax,QWORD PTR [rax]
  10bfa2:	48 89 d1             	mov    rcx,rdx
  10bfa5:	48 89 c2             	mov    rdx,rax
  10bfa8:	be 70 7e 10 00       	mov    esi,0x107e70
  10bfad:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bfb2:	b8 00 00 00 00       	mov    eax,0x0
  10bfb7:	e8 ab 0c 00 00       	call   10cc67 <klog_write_fmt>
  lapic_initalize(sys->lapic_virtual_address);
  10bfbc:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bfc0:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  10bfc4:	48 89 c7             	mov    rdi,rax
  10bfc7:	e8 5e dc ff ff       	call   109c2a <lapic_initalize>
  ioapic_initalize(sys->ioapic_virtual_address);
  10bfcc:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bfd0:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
  10bfd4:	48 89 c7             	mov    rdi,rax
  10bfd7:	e8 03 dc ff ff       	call   109bdf <ioapic_initalize>
  klog_debug("apic initalized");
  10bfdc:	be 97 7e 10 00       	mov    esi,0x107e97
  10bfe1:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bfe6:	b8 00 00 00 00       	mov    eax,0x0
  10bfeb:	e8 77 0c 00 00       	call   10cc67 <klog_write_fmt>
  asm_enter_usermode((uintptr_t)start_address, stack_address);
#endif

  //kgfx_draw_log_if_dirty(&globals.log);

  lapic_configure_timer(sys->lapic_virtual_address, 0xFFFF, 0x20, 1);
  10bff0:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bff4:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  10bff8:	b9 01 00 00 00       	mov    ecx,0x1
  10bffd:	ba 20 00 00 00       	mov    edx,0x20
  10c002:	be ff ff 00 00       	mov    esi,0xffff
  10c007:	48 89 c7             	mov    rdi,rax
  10c00a:	e8 79 dc ff ff       	call   109c88 <lapic_configure_timer>

  //pci_enumerate_devices();
  //lapic_enable_timer(sys->lapic_virtual_address);

	while(1) { asm volatile("hlt"); };
  10c00f:	f4                   	hlt    
  10c010:	eb fd                	jmp    10c00f <kernel_longmode_entry+0x423>

000000000010c012 <kprocess_destroy>:
  0x0,
  0x0,
};


extern void kprocess_destroy(uint64_t pid){
  10c012:	55                   	push   rbp
  10c013:	48 89 e5             	mov    rbp,rsp
  10c016:	48 83 ec 10          	sub    rsp,0x10
  10c01a:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  klog_debug("destroyed process: %lu", pid);
  10c01e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c022:	48 89 c2             	mov    rdx,rax
  10c025:	be a7 7e 10 00       	mov    esi,0x107ea7
  10c02a:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c02f:	b8 00 00 00 00       	mov    eax,0x0
  10c034:	e8 2e 0c 00 00       	call   10cc67 <klog_write_fmt>
  lapic_configure_timer(globals.system_info.lapic_virtual_address, 0xFFFF, 0x20, 0);
  10c039:	48 8b 05 60 26 01 00 	mov    rax,QWORD PTR [rip+0x12660]        # 11e6a0 <globals+0x106a0>
  10c040:	b9 00 00 00 00       	mov    ecx,0x0
  10c045:	ba 20 00 00 00       	mov    edx,0x20
  10c04a:	be ff ff 00 00       	mov    esi,0xffff
  10c04f:	48 89 c7             	mov    rdi,rax
  10c052:	e8 31 dc ff ff       	call   109c88 <lapic_configure_timer>
  asm volatile("int $0x20");
  10c057:	cd 20                	int    0x20
  klog_debug("test");
  10c059:	be be 7e 10 00       	mov    esi,0x107ebe
  10c05e:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c063:	b8 00 00 00 00       	mov    eax,0x0
  10c068:	e8 fa 0b 00 00       	call   10cc67 <klog_write_fmt>
  asm volatile("hlt");
  10c06d:	f4                   	hlt    
}
  10c06e:	90                   	nop
  10c06f:	c9                   	leave  
  10c070:	c3                   	ret    

000000000010c071 <syscall_handler_print_string>:

static void syscall_handler_print_string(const char *string, size_t length){
  10c071:	55                   	push   rbp
  10c072:	48 89 e5             	mov    rbp,rsp
  10c075:	48 83 ec 10          	sub    rsp,0x10
  10c079:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  10c07d:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
  klog_write_string(&globals.log, string, length);
  10c081:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  10c085:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c089:	48 89 c6             	mov    rsi,rax
  10c08c:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c091:	e8 cf 0a 00 00       	call   10cb65 <klog_write_string>
}
  10c096:	90                   	nop
  10c097:	c9                   	leave  
  10c098:	c3                   	ret    

000000000010c099 <syscall_handler_exit_process>:

static void syscall_handler_exit_process(Interrupt_Stack_Frame_Basic stack){
  10c099:	55                   	push   rbp
  10c09a:	48 89 e5             	mov    rbp,rsp
  extern void asm_exit_usermode(void);
  stack.ss = GDT_RING0_DATA;
  10c09d:	48 c7 45 30 08 00 00 	mov    QWORD PTR [rbp+0x30],0x8
  10c0a4:	00 
  stack.cs = GDT_RING0_CODE;
  10c0a5:	48 c7 45 18 18 00 00 	mov    QWORD PTR [rbp+0x18],0x18
  10c0ac:	00 
  stack.rip = (uintptr_t)asm_exit_usermode;
  10c0ad:	b8 a5 d4 10 00       	mov    eax,0x10d4a5
  10c0b2:	48 89 45 10          	mov    QWORD PTR [rbp+0x10],rax
  stack.rsp = (uintptr_t)globals.system_info.kernel_stack_address;
  10c0b6:	48 8b 05 f3 25 01 00 	mov    rax,QWORD PTR [rip+0x125f3]        # 11e6b0 <globals+0x106b0>
  10c0bd:	48 89 45 28          	mov    QWORD PTR [rbp+0x28],rax
  asm volatile("mov $0x00, %rdi");
  10c0c1:	48 c7 c7 00 00 00 00 	mov    rdi,0x0
}
  10c0c8:	90                   	nop
  10c0c9:	5d                   	pop    rbp
  10c0ca:	c3                   	ret    

000000000010c0cb <isr_common_handler>:
  (uintptr_t)syscall_handler_print_string,
  (uintptr_t)syscall_handler_exit_process,
};

extern void 
isr_common_handler(Interrupt_Stack_Frame stack) {
  10c0cb:	55                   	push   rbp
  10c0cc:	48 89 e5             	mov    rbp,rsp
	klog_debug("Exception Occured:%u %s", stack.interrupt_number, EXCEPTION_NAMES[stack.interrupt_number]);
  10c0cf:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  10c0d3:	48 8b 14 c5 80 d6 10 	mov    rdx,QWORD PTR [rax*8+0x10d680]
  10c0da:	00 
  10c0db:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  10c0df:	48 89 d1             	mov    rcx,rdx
  10c0e2:	48 89 c2             	mov    rdx,rax
  10c0e5:	be e0 7e 10 00       	mov    esi,0x107ee0
  10c0ea:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c0ef:	b8 00 00 00 00       	mov    eax,0x0
  10c0f4:	e8 6e 0b 00 00       	call   10cc67 <klog_write_fmt>
	klog_debug("error_code: %u", stack.error_code);
  10c0f9:	48 8b 45 30          	mov    rax,QWORD PTR [rbp+0x30]
  10c0fd:	48 89 c2             	mov    rdx,rax
  10c100:	be f8 7e 10 00       	mov    esi,0x107ef8
  10c105:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c10a:	b8 00 00 00 00       	mov    eax,0x0
  10c10f:	e8 53 0b 00 00       	call   10cc67 <klog_write_fmt>
	klog_debug("rip: 0x%X", stack.rip);
  10c114:	48 8b 45 38          	mov    rax,QWORD PTR [rbp+0x38]
  10c118:	48 89 c2             	mov    rdx,rax
  10c11b:	be 07 7f 10 00       	mov    esi,0x107f07
  10c120:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c125:	b8 00 00 00 00       	mov    eax,0x0
  10c12a:	e8 38 0b 00 00       	call   10cc67 <klog_write_fmt>
  if(g_exception_handlers[stack.interrupt_number] != 0){
  10c12f:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  10c133:	48 8b 04 c5 80 d7 10 	mov    rax,QWORD PTR [rax*8+0x10d780]
  10c13a:	00 
  10c13b:	48 85 c0             	test   rax,rax
  10c13e:	74 30                	je     10c170 <isr_common_handler+0xa5>
    g_exception_handlers[stack.interrupt_number](stack);
  10c140:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  10c144:	48 8b 04 c5 80 d7 10 	mov    rax,QWORD PTR [rax*8+0x10d780]
  10c14b:	00 
  10c14c:	ff 75 58             	push   QWORD PTR [rbp+0x58]
  10c14f:	ff 75 50             	push   QWORD PTR [rbp+0x50]
  10c152:	ff 75 48             	push   QWORD PTR [rbp+0x48]
  10c155:	ff 75 40             	push   QWORD PTR [rbp+0x40]
  10c158:	ff 75 38             	push   QWORD PTR [rbp+0x38]
  10c15b:	ff 75 30             	push   QWORD PTR [rbp+0x30]
  10c15e:	ff 75 28             	push   QWORD PTR [rbp+0x28]
  10c161:	ff 75 20             	push   QWORD PTR [rbp+0x20]
  10c164:	ff 75 18             	push   QWORD PTR [rbp+0x18]
  10c167:	ff 75 10             	push   QWORD PTR [rbp+0x10]
  10c16a:	ff d0                	call   rax
  10c16c:	48 83 c4 50          	add    rsp,0x50
  }
}
  10c170:	90                   	nop
  10c171:	c9                   	leave  
  10c172:	c3                   	ret    

000000000010c173 <irq_common_handler>:

extern void 
irq_common_handler(Interrupt_Stack_Frame_No_Error stack) {
  10c173:	55                   	push   rbp
  10c174:	48 89 e5             	mov    rbp,rsp
  10c177:	48 83 ec 10          	sub    rsp,0x10
  if(_interrupt_handlers[stack.interrupt_number] == 0x00){
  10c17b:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  10c17f:	48 8b 04 c5 00 f8 11 	mov    rax,QWORD PTR [rax*8+0x11f800]
  10c186:	00 
  10c187:	48 85 c0             	test   rax,rax
  10c18a:	75 16                	jne    10c1a2 <irq_common_handler+0x2f>
		klog_error("unregistered interrupt handler");
  10c18c:	be 18 7f 10 00       	mov    esi,0x107f18
  10c191:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c196:	b8 00 00 00 00       	mov    eax,0x0
  10c19b:	e8 c7 0a 00 00       	call   10cc67 <klog_write_fmt>
  10c1a0:	eb 19                	jmp    10c1bb <irq_common_handler+0x48>
  } else {
    bochs_magic_breakpoint;
  10c1a2:	66 87 db             	xchg   bx,bx
	  InterruptHandlerProc proc = (InterruptHandlerProc)_interrupt_handlers[stack.interrupt_number];
  10c1a5:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  10c1a9:	48 8b 04 c5 00 f8 11 	mov    rax,QWORD PTR [rax*8+0x11f800]
  10c1b0:	00 
  10c1b1:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
		proc();
  10c1b5:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c1b9:	ff d0                	call   rax
  }
  lapic_write_register(globals.system_info.lapic_virtual_address, 0xB0, 0x00);
  10c1bb:	48 8b 05 de 24 01 00 	mov    rax,QWORD PTR [rip+0x124de]        # 11e6a0 <globals+0x106a0>
  10c1c2:	ba 00 00 00 00       	mov    edx,0x0
  10c1c7:	be b0 00 00 00       	mov    esi,0xb0
  10c1cc:	48 89 c7             	mov    rdi,rax
  10c1cf:	e8 dd d9 ff ff       	call   109bb1 <lapic_write_register>
}
  10c1d4:	90                   	nop
  10c1d5:	c9                   	leave  
  10c1d6:	c3                   	ret    

000000000010c1d7 <irq_handler_keyboard>:
//was already down it will still register that the key was
//pressed with the modifier.  Does this event matter?  Would this be better?
//Should store keycode + extra btye saying (isdown, shiftdown?, ctrldow?, altdown?)

static void 
irq_handler_keyboard(void) {
  10c1d7:	55                   	push   rbp
  10c1d8:	48 89 e5             	mov    rbp,rsp
  10c1db:	48 83 ec 10          	sub    rsp,0x10
  static const uint32_t KEYBOARD_DATA_PORT   = 0x60;
  static const uint32_t KEYBOARD_STATUS_PORT = 0x64;
	uint8_t keyboard_status = read_port_uint8(KEYBOARD_STATUS_PORT);
  10c1df:	8b 05 6b c0 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffc06b]        # 108250 <KEYBOARD_STATUS_PORT.5346>
  10c1e5:	0f b7 c0             	movzx  eax,ax
  10c1e8:	89 c7                	mov    edi,eax
  10c1ea:	e8 39 d0 ff ff       	call   109228 <read_port_uint8>
  10c1ef:	88 45 ff             	mov    BYTE PTR [rbp-0x1],al
  if(keyboard_status & 0x01){
  10c1f2:	0f b6 45 ff          	movzx  eax,BYTE PTR [rbp-0x1]
  10c1f6:	83 e0 01             	and    eax,0x1
  10c1f9:	85 c0                	test   eax,eax
  10c1fb:	0f 84 aa 00 00 00    	je     10c2ab <irq_handler_keyboard+0xd4>
		uint8_t scancode = read_port_uint8(KEYBOARD_DATA_PORT);
  10c201:	8b 05 4d c0 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffc04d]        # 108254 <KEYBOARD_DATA_PORT.5345>
  10c207:	0f b7 c0             	movzx  eax,ax
  10c20a:	89 c7                	mov    edi,eax
  10c20c:	e8 17 d0 ff ff       	call   109228 <read_port_uint8>
  10c211:	88 45 fe             	mov    BYTE PTR [rbp-0x2],al
    if(globals.log_keyboard_events){
  10c214:	0f b6 05 46 25 01 00 	movzx  eax,BYTE PTR [rip+0x12546]        # 11e761 <globals+0x10761>
  10c21b:	84 c0                	test   al,al
  10c21d:	74 1a                	je     10c239 <irq_handler_keyboard+0x62>
      klog_debug("[keyboard_event] scancode %u", scancode);
  10c21f:	0f b6 45 fe          	movzx  eax,BYTE PTR [rbp-0x2]
  10c223:	89 c2                	mov    edx,eax
  10c225:	be ba 7f 10 00       	mov    esi,0x107fba
  10c22a:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c22f:	b8 00 00 00 00       	mov    eax,0x0
  10c234:	e8 2e 0a 00 00       	call   10cc67 <klog_write_fmt>
    }

    //TODO(Torin) How should this case be handled?  Is it even possbile to occur in practice?
    //What if the user has a stupidly slow computer?
    if(globals.keyboard.scancode_event_stack_count >= sizeof(globals.keyboard.scancode_event_stack)) {
  10c239:	48 8b 05 00 24 01 00 	mov    rax,QWORD PTR [rip+0x12400]        # 11e640 <globals+0x10640>
  10c240:	48 83 f8 07          	cmp    rax,0x7
  10c244:	76 16                	jbe    10c25c <irq_handler_keyboard+0x85>
      klog_warning("[keyboard_event] keyboard event stack reached maximum size before events were processed");
  10c246:	be d8 7f 10 00       	mov    esi,0x107fd8
  10c24b:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c250:	b8 00 00 00 00       	mov    eax,0x0
  10c255:	e8 0d 0a 00 00       	call   10cc67 <klog_write_fmt>
      return;
  10c25a:	eb 4f                	jmp    10c2ab <irq_handler_keyboard+0xd4>
    }

    if (scancode > 0x80) {  //NOTE(Torin)key release event 
  10c25c:	80 7d fe 80          	cmp    BYTE PTR [rbp-0x2],0x80
  10c260:	76 19                	jbe    10c27b <irq_handler_keyboard+0xa4>
      uint8_t base_scancode = scancode - 0x80;
  10c262:	0f b6 45 fe          	movzx  eax,BYTE PTR [rbp-0x2]
  10c266:	83 c0 80             	add    eax,0xffffff80
  10c269:	88 45 fd             	mov    BYTE PTR [rbp-0x3],al
      globals.keyboard.keystate[base_scancode] = 0;
  10c26c:	0f b6 45 fd          	movzx  eax,BYTE PTR [rbp-0x3]
  10c270:	48 98                	cdqe   
  10c272:	c6 80 40 e5 11 00 00 	mov    BYTE PTR [rax+0x11e540],0x0
  10c279:	eb 0d                	jmp    10c288 <irq_handler_keyboard+0xb1>
    } else { //NOTE(Torin)Key press event
      globals.keyboard.keystate[scancode] = 1;
  10c27b:	0f b6 45 fe          	movzx  eax,BYTE PTR [rbp-0x2]
  10c27f:	48 98                	cdqe   
  10c281:	c6 80 40 e5 11 00 01 	mov    BYTE PTR [rax+0x11e540],0x1
    }
    
    //TODO(Torin) we would be saving some subtractions cost in userspace by storing the keycode here instead of the
    //scanconde and adding an extra byte to store information about the isDown state and keyboard modifiers!
    globals.keyboard.scancode_event_stack[globals.keyboard.scancode_event_stack_count++] = scancode;
  10c288:	48 8b 0d b9 23 01 00 	mov    rcx,QWORD PTR [rip+0x123b9]        # 11e648 <globals+0x10648>
  10c28f:	48 8b 05 aa 23 01 00 	mov    rax,QWORD PTR [rip+0x123aa]        # 11e640 <globals+0x10640>
  10c296:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10c29a:	48 89 15 9f 23 01 00 	mov    QWORD PTR [rip+0x1239f],rdx        # 11e640 <globals+0x10640>
  10c2a1:	48 8d 14 01          	lea    rdx,[rcx+rax*1]
  10c2a5:	0f b6 45 fe          	movzx  eax,BYTE PTR [rbp-0x2]
  10c2a9:	88 02                	mov    BYTE PTR [rdx],al
  }
}
  10c2ab:	c9                   	leave  
  10c2ac:	c3                   	ret    

000000000010c2ad <klog_process_keyevents>:

static void 
klog_process_keyevents(Keyboard_State *keyboard, Circular_Log *log){
  10c2ad:	55                   	push   rbp
  10c2ae:	48 89 e5             	mov    rbp,rsp
  10c2b1:	48 83 ec 20          	sub    rsp,0x20
  10c2b5:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10c2b9:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  for(size_t i = 0; i < keyboard->scancode_event_stack_count; i++){
  10c2bd:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10c2c4:	00 
  10c2c5:	e9 2e 01 00 00       	jmp    10c3f8 <klog_process_keyevents+0x14b>
    uint8_t scancode = keyboard->scancode_event_stack[i];
  10c2ca:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10c2ce:	48 8b 90 08 01 00 00 	mov    rdx,QWORD PTR [rax+0x108]
  10c2d5:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c2d9:	48 01 d0             	add    rax,rdx
  10c2dc:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c2df:	88 45 f6             	mov    BYTE PTR [rbp-0xa],al

    if(scancode == KEYCODE_BACKSPACE_PRESSED){
  10c2e2:	80 7d f6 0e          	cmp    BYTE PTR [rbp-0xa],0xe
  10c2e6:	75 11                	jne    10c2f9 <klog_process_keyevents+0x4c>
      klog_remove_last_input_character(log);
  10c2e8:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c2ec:	48 89 c7             	mov    rdi,rax
  10c2ef:	e8 0f 0c 00 00       	call   10cf03 <klog_remove_last_input_character>
  10c2f4:	e9 9e 00 00 00       	jmp    10c397 <klog_process_keyevents+0xea>
		} else if(scancode == KEYCODE_ENTER_PRESSED){
  10c2f9:	80 7d f6 1c          	cmp    BYTE PTR [rbp-0xa],0x1c
  10c2fd:	75 11                	jne    10c310 <klog_process_keyevents+0x63>
      klog_submit_input_to_shell(log);
  10c2ff:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c303:	48 89 c7             	mov    rdi,rax
  10c306:	e8 77 0c 00 00       	call   10cf82 <klog_submit_input_to_shell>
  10c30b:	e9 87 00 00 00       	jmp    10c397 <klog_process_keyevents+0xea>
		} else if (scancode == KEYCODE_UP_PRESSED){
  10c310:	80 7d f6 48          	cmp    BYTE PTR [rbp-0xa],0x48
  10c314:	75 46                	jne    10c35c <klog_process_keyevents+0xaf>
      if(log->scroll_offset < log->current_entry_count - 1){
  10c316:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c31a:	48 8b 90 10 04 01 00 	mov    rdx,QWORD PTR [rax+0x10410]
  10c321:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c325:	48 8b 80 08 04 01 00 	mov    rax,QWORD PTR [rax+0x10408]
  10c32c:	48 83 e8 01          	sub    rax,0x1
  10c330:	48 39 c2             	cmp    rdx,rax
  10c333:	73 1a                	jae    10c34f <klog_process_keyevents+0xa2>
        log->scroll_offset += 1;
  10c335:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c339:	48 8b 80 10 04 01 00 	mov    rax,QWORD PTR [rax+0x10410]
  10c340:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10c344:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c348:	48 89 90 10 04 01 00 	mov    QWORD PTR [rax+0x10410],rdx
      }


      log->is_dirty = true;
  10c34f:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c353:	c6 80 24 05 01 00 01 	mov    BYTE PTR [rax+0x10524],0x1
  10c35a:	eb 3b                	jmp    10c397 <klog_process_keyevents+0xea>
    } else if (scancode == KEYCODE_DOWN_PRESSED){
  10c35c:	80 7d f6 50          	cmp    BYTE PTR [rbp-0xa],0x50
  10c360:	75 35                	jne    10c397 <klog_process_keyevents+0xea>
      if(log->scroll_offset > 0){
  10c362:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c366:	48 8b 80 10 04 01 00 	mov    rax,QWORD PTR [rax+0x10410]
  10c36d:	48 85 c0             	test   rax,rax
  10c370:	74 25                	je     10c397 <klog_process_keyevents+0xea>
        log->scroll_offset -= 1;
  10c372:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c376:	48 8b 80 10 04 01 00 	mov    rax,QWORD PTR [rax+0x10410]
  10c37d:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  10c381:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c385:	48 89 90 10 04 01 00 	mov    QWORD PTR [rax+0x10410],rdx
        log->is_dirty = true;
  10c38c:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c390:	c6 80 24 05 01 00 01 	mov    BYTE PTR [rax+0x10524],0x1
      }
    }

    if(scancode < (int)sizeof(SCANCODE_TO_LOWERCASE_ACII)){
  10c397:	80 7d f6 39          	cmp    BYTE PTR [rbp-0xa],0x39
  10c39b:	77 56                	ja     10c3f3 <klog_process_keyevents+0x146>
      char ascii_character = 0;
  10c39d:	c6 45 f7 00          	mov    BYTE PTR [rbp-0x9],0x0
      if(keyboard->keystate[KEYBOARD_SCANCODE1_LSHIFT] ||
  10c3a1:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10c3a5:	0f b6 40 2a          	movzx  eax,BYTE PTR [rax+0x2a]
  10c3a9:	84 c0                	test   al,al
  10c3ab:	75 0c                	jne    10c3b9 <klog_process_keyevents+0x10c>
        keyboard->keystate[KEYBOARD_SCANCODE1_RSHIFT]){
  10c3ad:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10c3b1:	0f b6 40 36          	movzx  eax,BYTE PTR [rax+0x36]
      if(keyboard->keystate[KEYBOARD_SCANCODE1_LSHIFT] ||
  10c3b5:	84 c0                	test   al,al
  10c3b7:	74 12                	je     10c3cb <klog_process_keyevents+0x11e>
        ascii_character = SCANCODE_TO_UPERCASE_ACII[scancode];
  10c3b9:	0f b6 45 f6          	movzx  eax,BYTE PTR [rbp-0xa]
  10c3bd:	48 98                	cdqe   
  10c3bf:	0f b6 80 80 7f 10 00 	movzx  eax,BYTE PTR [rax+0x107f80]
  10c3c6:	88 45 f7             	mov    BYTE PTR [rbp-0x9],al
  10c3c9:	eb 10                	jmp    10c3db <klog_process_keyevents+0x12e>
      } else { ascii_character = SCANCODE_TO_LOWERCASE_ACII[scancode]; }
  10c3cb:	0f b6 45 f6          	movzx  eax,BYTE PTR [rbp-0xa]
  10c3cf:	48 98                	cdqe   
  10c3d1:	0f b6 80 40 7f 10 00 	movzx  eax,BYTE PTR [rax+0x107f40]
  10c3d8:	88 45 f7             	mov    BYTE PTR [rbp-0x9],al
      if(ascii_character == 0) return;
  10c3db:	80 7d f7 00          	cmp    BYTE PTR [rbp-0x9],0x0
  10c3df:	74 2e                	je     10c40f <klog_process_keyevents+0x162>
      klog_add_input_character(log, ascii_character);
  10c3e1:	0f be 55 f7          	movsx  edx,BYTE PTR [rbp-0x9]
  10c3e5:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c3e9:	89 d6                	mov    esi,edx
  10c3eb:	48 89 c7             	mov    rdi,rax
  10c3ee:	e8 67 0a 00 00       	call   10ce5a <klog_add_input_character>
  for(size_t i = 0; i < keyboard->scancode_event_stack_count; i++){
  10c3f3:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10c3f8:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10c3fc:	48 8b 80 00 01 00 00 	mov    rax,QWORD PTR [rax+0x100]
  10c403:	48 3b 45 f8          	cmp    rax,QWORD PTR [rbp-0x8]
  10c407:	0f 87 bd fe ff ff    	ja     10c2ca <klog_process_keyevents+0x1d>
  10c40d:	eb 01                	jmp    10c410 <klog_process_keyevents+0x163>
      if(ascii_character == 0) return;
  10c40f:	90                   	nop
    }
  }
}
  10c410:	c9                   	leave  
  10c411:	c3                   	ret    

000000000010c412 <irq_handler_pit>:

static void 
irq_handler_pit(void) {
  10c412:	55                   	push   rbp
  10c413:	48 89 e5             	mov    rbp,rsp
  10c416:	48 83 ec 10          	sub    rsp,0x10
  Keyboard_State *keyboard = &globals.keyboard;
  10c41a:	48 c7 45 f8 40 e5 11 	mov    QWORD PTR [rbp-0x8],0x11e540
  10c421:	00 
  if(globals.keyboard.scancode_event_stack_count > 0){
  10c422:	48 8b 05 17 22 01 00 	mov    rax,QWORD PTR [rip+0x12217]        # 11e640 <globals+0x10640>
  10c429:	48 85 c0             	test   rax,rax
  10c42c:	0f 84 86 00 00 00    	je     10c4b8 <irq_handler_pit+0xa6>
    klog_process_keyevents(keyboard, &globals.log); 
  10c432:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c436:	be 00 e0 10 00       	mov    esi,0x10e000
  10c43b:	48 89 c7             	mov    rdi,rax
  10c43e:	e8 6a fe ff ff       	call   10c2ad <klog_process_keyevents>
    if(keyboard->scancode_event_stack == keyboard->scancode_event_stack0){
  10c443:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c447:	48 8b 80 08 01 00 00 	mov    rax,QWORD PTR [rax+0x108]
  10c44e:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10c452:	48 81 c2 10 01 00 00 	add    rdx,0x110
  10c459:	48 39 d0             	cmp    rax,rdx
  10c45c:	75 18                	jne    10c476 <irq_handler_pit+0x64>
      keyboard->scancode_event_stack = keyboard->scancode_event_stack1;
  10c45e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c462:	48 8d 90 30 01 00 00 	lea    rdx,[rax+0x130]
  10c469:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c46d:	48 89 90 08 01 00 00 	mov    QWORD PTR [rax+0x108],rdx
  10c474:	eb 16                	jmp    10c48c <irq_handler_pit+0x7a>
    } else { keyboard->scancode_event_stack = keyboard->scancode_event_stack0; }
  10c476:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c47a:	48 8d 90 10 01 00 00 	lea    rdx,[rax+0x110]
  10c481:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c485:	48 89 90 08 01 00 00 	mov    QWORD PTR [rax+0x108],rdx
    memset(keyboard->scancode_event_stack, 0x00, sizeof(keyboard->scancode_event_stack0));
  10c48c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c490:	48 8b 80 08 01 00 00 	mov    rax,QWORD PTR [rax+0x108]
  10c497:	ba 20 00 00 00       	mov    edx,0x20
  10c49c:	be 00 00 00 00       	mov    esi,0x0
  10c4a1:	48 89 c7             	mov    rdi,rax
  10c4a4:	e8 57 cb ff ff       	call   109000 <__memset>
    keyboard->scancode_event_stack_count = 0;
  10c4a9:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c4ad:	48 c7 80 00 01 00 00 	mov    QWORD PTR [rax+0x100],0x0
  10c4b4:	00 00 00 00 
  }

	kgfx_draw_log_if_dirty(&globals.log);
  10c4b8:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c4bd:	e8 5c d1 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10c4c2:	90                   	nop
  10c4c3:	c9                   	leave  
  10c4c4:	c3                   	ret    

000000000010c4c5 <string_inplace_reverse>:
  uint32_to_string_base16(dest + 8, value0);
}
#endif

static inline
void string_inplace_reverse(char *str, size_t length){
  10c4c5:	55                   	push   rbp
  10c4c6:	48 89 e5             	mov    rbp,rsp
  10c4c9:	48 83 ec 30          	sub    rsp,0x30
  10c4cd:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  10c4d1:	48 89 75 d0          	mov    QWORD PTR [rbp-0x30],rsi
  size_t midpoint = length / 2;
  10c4d5:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10c4d9:	48 d1 e8             	shr    rax,1
  10c4dc:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
  for(size_t i = 0; i < midpoint; i++){
  10c4e0:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10c4e7:	00 
  10c4e8:	eb 52                	jmp    10c53c <string_inplace_reverse+0x77>
    char oldValue = str[i];
  10c4ea:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
  10c4ee:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c4f2:	48 01 d0             	add    rax,rdx
  10c4f5:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c4f8:	88 45 ef             	mov    BYTE PTR [rbp-0x11],al
    str[i] = str[length - 1 - i];
  10c4fb:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
  10c4ff:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c503:	48 01 c2             	add    rdx,rax
  10c506:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10c50a:	48 2b 45 f8          	sub    rax,QWORD PTR [rbp-0x8]
  10c50e:	48 8d 48 ff          	lea    rcx,[rax-0x1]
  10c512:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10c516:	48 01 c8             	add    rax,rcx
  10c519:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c51c:	88 02                	mov    BYTE PTR [rdx],al
    str[length - 1 - i] = oldValue;
  10c51e:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10c522:	48 2b 45 f8          	sub    rax,QWORD PTR [rbp-0x8]
  10c526:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  10c52a:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10c52e:	48 01 c2             	add    rdx,rax
  10c531:	0f b6 45 ef          	movzx  eax,BYTE PTR [rbp-0x11]
  10c535:	88 02                	mov    BYTE PTR [rdx],al
  for(size_t i = 0; i < midpoint; i++){
  10c537:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10c53c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c540:	48 3b 45 f0          	cmp    rax,QWORD PTR [rbp-0x10]
  10c544:	72 a4                	jb     10c4ea <string_inplace_reverse+0x25>
  }
} 
  10c546:	90                   	nop
  10c547:	c9                   	leave  
  10c548:	c3                   	ret    

000000000010c549 <uint64_to_string>:

static inline 
size_t uint64_to_string(char *dest, uint64_t value, uint8_t base){
  10c549:	55                   	push   rbp
  10c54a:	48 89 e5             	mov    rbp,rsp
  10c54d:	48 83 ec 28          	sub    rsp,0x28
  10c551:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10c555:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  10c559:	89 d0                	mov    eax,edx
  10c55b:	88 45 dc             	mov    BYTE PTR [rbp-0x24],al
  size_t bytes_written = 0;
  10c55e:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10c565:	00 
  if(value == 0) {
  10c566:	48 83 7d e0 00       	cmp    QWORD PTR [rbp-0x20],0x0
  10c56b:	75 55                	jne    10c5c2 <uint64_to_string+0x79>
    dest[0] = '0';
  10c56d:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10c571:	c6 00 30             	mov    BYTE PTR [rax],0x30
    bytes_written = 1;
  10c574:	48 c7 45 f8 01 00 00 	mov    QWORD PTR [rbp-0x8],0x1
  10c57b:	00 
  10c57c:	eb 5e                	jmp    10c5dc <uint64_to_string+0x93>
  } else {
    while(value > 0){
      static const char LOOKUP[] = "0123456789ABCDEF";
      dest[bytes_written++] = LOOKUP[value % base];
  10c57e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c582:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10c586:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
  10c58a:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  10c58e:	48 8d 0c 10          	lea    rcx,[rax+rdx*1]
  10c592:	0f b6 75 dc          	movzx  esi,BYTE PTR [rbp-0x24]
  10c596:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c59a:	ba 00 00 00 00       	mov    edx,0x0
  10c59f:	48 f7 f6             	div    rsi
  10c5a2:	48 89 d0             	mov    rax,rdx
  10c5a5:	0f b6 80 60 82 10 00 	movzx  eax,BYTE PTR [rax+0x108260]
  10c5ac:	88 01                	mov    BYTE PTR [rcx],al
      value /= base;
  10c5ae:	0f b6 4d dc          	movzx  ecx,BYTE PTR [rbp-0x24]
  10c5b2:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c5b6:	ba 00 00 00 00       	mov    edx,0x0
  10c5bb:	48 f7 f1             	div    rcx
  10c5be:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
    while(value > 0){
  10c5c2:	48 83 7d e0 00       	cmp    QWORD PTR [rbp-0x20],0x0
  10c5c7:	75 b5                	jne    10c57e <uint64_to_string+0x35>
    }
    string_inplace_reverse(dest, bytes_written);
  10c5c9:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10c5cd:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10c5d1:	48 89 d6             	mov    rsi,rdx
  10c5d4:	48 89 c7             	mov    rdi,rax
  10c5d7:	e8 e9 fe ff ff       	call   10c4c5 <string_inplace_reverse>
  }
  return bytes_written;
  10c5dc:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
}
  10c5e0:	c9                   	leave  
  10c5e1:	c3                   	ret    

000000000010c5e2 <kernel_vsnprintf>:
  return bytes_written;
}

static size_t 
kernel_vsnprintf(char *buffer, size_t capacity, const char *fmt, va_list args) 
{
  10c5e2:	55                   	push   rbp
  10c5e3:	48 89 e5             	mov    rbp,rsp
  10c5e6:	48 83 c4 80          	add    rsp,0xffffffffffffff80
  10c5ea:	48 89 7d 98          	mov    QWORD PTR [rbp-0x68],rdi
  10c5ee:	48 89 75 90          	mov    QWORD PTR [rbp-0x70],rsi
  10c5f2:	48 89 55 88          	mov    QWORD PTR [rbp-0x78],rdx
  10c5f6:	48 89 4d 80          	mov    QWORD PTR [rbp-0x80],rcx
  size_t bytes_written = 0;
  10c5fa:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10c601:	00 
  size_t fmt_index = 0;
  10c602:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
  10c609:	00 
  while(fmt[fmt_index] != 0){
  10c60a:	e9 8c 04 00 00       	jmp    10ca9b <kernel_vsnprintf+0x4b9>
    if(fmt[fmt_index] == '%'){
  10c60f:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c613:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c617:	48 01 d0             	add    rax,rdx
  10c61a:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c61d:	3c 25                	cmp    al,0x25
  10c61f:	0f 85 f1 03 00 00    	jne    10ca16 <kernel_vsnprintf+0x434>
			fmt_index++;
  10c625:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1

			if(fmt[fmt_index] == 'l') {
  10c62a:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c62e:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c632:	48 01 d0             	add    rax,rdx
  10c635:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c638:	3c 6c                	cmp    al,0x6c
  10c63a:	0f 85 aa 00 00 00    	jne    10c6ea <kernel_vsnprintf+0x108>
				fmt_index++;
  10c640:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
				if(fmt[fmt_index] == 'u') {
  10c645:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c649:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c64d:	48 01 d0             	add    rax,rdx
  10c650:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c653:	3c 75                	cmp    al,0x75
  10c655:	0f 85 40 04 00 00    	jne    10ca9b <kernel_vsnprintf+0x4b9>
					uint64_t value = va_arg(args, uint64_t);
  10c65b:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c65f:	8b 00                	mov    eax,DWORD PTR [rax]
  10c661:	83 f8 2f             	cmp    eax,0x2f
  10c664:	77 24                	ja     10c68a <kernel_vsnprintf+0xa8>
  10c666:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c66a:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10c66e:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c672:	8b 00                	mov    eax,DWORD PTR [rax]
  10c674:	89 c0                	mov    eax,eax
  10c676:	48 01 d0             	add    rax,rdx
  10c679:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c67d:	8b 12                	mov    edx,DWORD PTR [rdx]
  10c67f:	8d 4a 08             	lea    ecx,[rdx+0x8]
  10c682:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c686:	89 0a                	mov    DWORD PTR [rdx],ecx
  10c688:	eb 14                	jmp    10c69e <kernel_vsnprintf+0xbc>
  10c68a:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c68e:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10c692:	48 8d 48 08          	lea    rcx,[rax+0x8]
  10c696:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c69a:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  10c69e:	48 8b 00             	mov    rax,QWORD PTR [rax]
  10c6a1:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
          if(bytes_written + 20 > capacity) return bytes_written;
  10c6a5:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c6a9:	48 83 c0 14          	add    rax,0x14
  10c6ad:	48 3b 45 90          	cmp    rax,QWORD PTR [rbp-0x70]
  10c6b1:	76 09                	jbe    10c6bc <kernel_vsnprintf+0xda>
  10c6b3:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c6b7:	e9 f9 03 00 00       	jmp    10cab5 <kernel_vsnprintf+0x4d3>
          bytes_written += uint64_to_string(buffer + bytes_written, value, 10);
  10c6bc:	48 8b 55 98          	mov    rdx,QWORD PTR [rbp-0x68]
  10c6c0:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c6c4:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
  10c6c8:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  10c6cc:	ba 0a 00 00 00       	mov    edx,0xa
  10c6d1:	48 89 c6             	mov    rsi,rax
  10c6d4:	48 89 cf             	mov    rdi,rcx
  10c6d7:	e8 6d fe ff ff       	call   10c549 <uint64_to_string>
  10c6dc:	48 01 45 f8          	add    QWORD PTR [rbp-0x8],rax
          fmt_index++;
  10c6e0:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  10c6e5:	e9 b1 03 00 00       	jmp    10ca9b <kernel_vsnprintf+0x4b9>
				}
			}

      //uint32_t base16	
			else if (fmt[fmt_index] == 'u') {
  10c6ea:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c6ee:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c6f2:	48 01 d0             	add    rax,rdx
  10c6f5:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c6f8:	3c 75                	cmp    al,0x75
  10c6fa:	0f 85 8b 00 00 00    	jne    10c78b <kernel_vsnprintf+0x1a9>
				uint32_t value = va_arg(args, uint32_t);
  10c700:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c704:	8b 00                	mov    eax,DWORD PTR [rax]
  10c706:	83 f8 2f             	cmp    eax,0x2f
  10c709:	77 24                	ja     10c72f <kernel_vsnprintf+0x14d>
  10c70b:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c70f:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10c713:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c717:	8b 00                	mov    eax,DWORD PTR [rax]
  10c719:	89 c0                	mov    eax,eax
  10c71b:	48 01 d0             	add    rax,rdx
  10c71e:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c722:	8b 12                	mov    edx,DWORD PTR [rdx]
  10c724:	8d 4a 08             	lea    ecx,[rdx+0x8]
  10c727:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c72b:	89 0a                	mov    DWORD PTR [rdx],ecx
  10c72d:	eb 14                	jmp    10c743 <kernel_vsnprintf+0x161>
  10c72f:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c733:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10c737:	48 8d 48 08          	lea    rcx,[rax+0x8]
  10c73b:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c73f:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  10c743:	8b 00                	mov    eax,DWORD PTR [rax]
  10c745:	89 45 dc             	mov    DWORD PTR [rbp-0x24],eax
        if(bytes_written + 10 > capacity) return bytes_written;
  10c748:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c74c:	48 83 c0 0a          	add    rax,0xa
  10c750:	48 3b 45 90          	cmp    rax,QWORD PTR [rbp-0x70]
  10c754:	76 09                	jbe    10c75f <kernel_vsnprintf+0x17d>
  10c756:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c75a:	e9 56 03 00 00       	jmp    10cab5 <kernel_vsnprintf+0x4d3>
				bytes_written += uint64_to_string(buffer + bytes_written, (uint64_t)value, 10);
  10c75f:	8b 45 dc             	mov    eax,DWORD PTR [rbp-0x24]
  10c762:	48 8b 4d 98          	mov    rcx,QWORD PTR [rbp-0x68]
  10c766:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10c76a:	48 01 d1             	add    rcx,rdx
  10c76d:	ba 0a 00 00 00       	mov    edx,0xa
  10c772:	48 89 c6             	mov    rsi,rax
  10c775:	48 89 cf             	mov    rdi,rcx
  10c778:	e8 cc fd ff ff       	call   10c549 <uint64_to_string>
  10c77d:	48 01 45 f8          	add    QWORD PTR [rbp-0x8],rax
        fmt_index++;
  10c781:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  10c786:	e9 10 03 00 00       	jmp    10ca9b <kernel_vsnprintf+0x4b9>
			}

      //cstring
			else if (fmt[fmt_index] == 's') {
  10c78b:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c78f:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c793:	48 01 d0             	add    rax,rdx
  10c796:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c799:	3c 73                	cmp    al,0x73
  10c79b:	0f 85 a5 00 00 00    	jne    10c846 <kernel_vsnprintf+0x264>
				const char *str = (const char *)va_arg(args, uintptr_t);
  10c7a1:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c7a5:	8b 00                	mov    eax,DWORD PTR [rax]
  10c7a7:	83 f8 2f             	cmp    eax,0x2f
  10c7aa:	77 24                	ja     10c7d0 <kernel_vsnprintf+0x1ee>
  10c7ac:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c7b0:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10c7b4:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c7b8:	8b 00                	mov    eax,DWORD PTR [rax]
  10c7ba:	89 c0                	mov    eax,eax
  10c7bc:	48 01 d0             	add    rax,rdx
  10c7bf:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c7c3:	8b 12                	mov    edx,DWORD PTR [rdx]
  10c7c5:	8d 4a 08             	lea    ecx,[rdx+0x8]
  10c7c8:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c7cc:	89 0a                	mov    DWORD PTR [rdx],ecx
  10c7ce:	eb 14                	jmp    10c7e4 <kernel_vsnprintf+0x202>
  10c7d0:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c7d4:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10c7d8:	48 8d 48 08          	lea    rcx,[rax+0x8]
  10c7dc:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c7e0:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  10c7e4:	48 8b 00             	mov    rax,QWORD PTR [rax]
  10c7e7:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
				size_t length = strlen(str);
  10c7eb:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10c7ef:	48 89 c7             	mov    rdi,rax
  10c7f2:	e8 96 c8 ff ff       	call   10908d <strlen>
  10c7f7:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
        if(bytes_written + length > capacity) return bytes_written;
  10c7fb:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10c7ff:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  10c803:	48 01 d0             	add    rax,rdx
  10c806:	48 3b 45 90          	cmp    rax,QWORD PTR [rbp-0x70]
  10c80a:	76 09                	jbe    10c815 <kernel_vsnprintf+0x233>
  10c80c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c810:	e9 a0 02 00 00       	jmp    10cab5 <kernel_vsnprintf+0x4d3>
        memcpy(buffer + bytes_written, str, length);
  10c815:	48 8b 55 98          	mov    rdx,QWORD PTR [rbp-0x68]
  10c819:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c81d:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
  10c821:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  10c825:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10c829:	48 89 c6             	mov    rsi,rax
  10c82c:	48 89 cf             	mov    rdi,rcx
  10c82f:	e8 0e c8 ff ff       	call   109042 <__memcpy>
        bytes_written += length; 
  10c834:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  10c838:	48 01 45 f8          	add    QWORD PTR [rbp-0x8],rax
				fmt_index++;
  10c83c:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  10c841:	e9 55 02 00 00       	jmp    10ca9b <kernel_vsnprintf+0x4b9>
			}

      else if(fmt[fmt_index] == 'X'){
  10c846:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c84a:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c84e:	48 01 d0             	add    rax,rdx
  10c851:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c854:	3c 58                	cmp    al,0x58
  10c856:	0f 85 8f 00 00 00    	jne    10c8eb <kernel_vsnprintf+0x309>
        uint64_t value = va_arg(args, uint64_t);
  10c85c:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c860:	8b 00                	mov    eax,DWORD PTR [rax]
  10c862:	83 f8 2f             	cmp    eax,0x2f
  10c865:	77 24                	ja     10c88b <kernel_vsnprintf+0x2a9>
  10c867:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c86b:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10c86f:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c873:	8b 00                	mov    eax,DWORD PTR [rax]
  10c875:	89 c0                	mov    eax,eax
  10c877:	48 01 d0             	add    rax,rdx
  10c87a:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c87e:	8b 12                	mov    edx,DWORD PTR [rdx]
  10c880:	8d 4a 08             	lea    ecx,[rdx+0x8]
  10c883:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c887:	89 0a                	mov    DWORD PTR [rdx],ecx
  10c889:	eb 14                	jmp    10c89f <kernel_vsnprintf+0x2bd>
  10c88b:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c88f:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10c893:	48 8d 48 08          	lea    rcx,[rax+0x8]
  10c897:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c89b:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  10c89f:	48 8b 00             	mov    rax,QWORD PTR [rax]
  10c8a2:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
        if(bytes_written + 16 > capacity) return bytes_written;
  10c8a6:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c8aa:	48 83 c0 10          	add    rax,0x10
  10c8ae:	48 3b 45 90          	cmp    rax,QWORD PTR [rbp-0x70]
  10c8b2:	76 09                	jbe    10c8bd <kernel_vsnprintf+0x2db>
  10c8b4:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c8b8:	e9 f8 01 00 00       	jmp    10cab5 <kernel_vsnprintf+0x4d3>
        bytes_written += uint64_to_string(buffer + bytes_written, value, 16);
  10c8bd:	48 8b 55 98          	mov    rdx,QWORD PTR [rbp-0x68]
  10c8c1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c8c5:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
  10c8c9:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10c8cd:	ba 10 00 00 00       	mov    edx,0x10
  10c8d2:	48 89 c6             	mov    rsi,rax
  10c8d5:	48 89 cf             	mov    rdi,rcx
  10c8d8:	e8 6c fc ff ff       	call   10c549 <uint64_to_string>
  10c8dd:	48 01 45 f8          	add    QWORD PTR [rbp-0x8],rax
        fmt_index++;
  10c8e1:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  10c8e6:	e9 b0 01 00 00       	jmp    10ca9b <kernel_vsnprintf+0x4b9>
      }

			else if (fmt[fmt_index] == '.') {
  10c8eb:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c8ef:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c8f3:	48 01 d0             	add    rax,rdx
  10c8f6:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c8f9:	3c 2e                	cmp    al,0x2e
  10c8fb:	0f 85 9a 01 00 00    	jne    10ca9b <kernel_vsnprintf+0x4b9>
				fmt_index++;
  10c901:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
				if(fmt[fmt_index] == '*'){
  10c906:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c90a:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c90e:	48 01 d0             	add    rax,rdx
  10c911:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c914:	3c 2a                	cmp    al,0x2a
  10c916:	0f 85 7f 01 00 00    	jne    10ca9b <kernel_vsnprintf+0x4b9>
					fmt_index++;
  10c91c:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
          if(fmt[fmt_index] == 's'){
  10c921:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c925:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c929:	48 01 d0             	add    rax,rdx
  10c92c:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c92f:	3c 73                	cmp    al,0x73
  10c931:	0f 85 64 01 00 00    	jne    10ca9b <kernel_vsnprintf+0x4b9>
            fmt_index++;
  10c937:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
            size_t str_length = (size_t)va_arg(args, uintptr_t);
  10c93c:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c940:	8b 00                	mov    eax,DWORD PTR [rax]
  10c942:	83 f8 2f             	cmp    eax,0x2f
  10c945:	77 24                	ja     10c96b <kernel_vsnprintf+0x389>
  10c947:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c94b:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10c94f:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c953:	8b 00                	mov    eax,DWORD PTR [rax]
  10c955:	89 c0                	mov    eax,eax
  10c957:	48 01 d0             	add    rax,rdx
  10c95a:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c95e:	8b 12                	mov    edx,DWORD PTR [rdx]
  10c960:	8d 4a 08             	lea    ecx,[rdx+0x8]
  10c963:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c967:	89 0a                	mov    DWORD PTR [rdx],ecx
  10c969:	eb 14                	jmp    10c97f <kernel_vsnprintf+0x39d>
  10c96b:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c96f:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10c973:	48 8d 48 08          	lea    rcx,[rax+0x8]
  10c977:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c97b:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  10c97f:	48 8b 00             	mov    rax,QWORD PTR [rax]
  10c982:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
            const char *str = (const char *)va_arg(args, uintptr_t);
  10c986:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c98a:	8b 00                	mov    eax,DWORD PTR [rax]
  10c98c:	83 f8 2f             	cmp    eax,0x2f
  10c98f:	77 24                	ja     10c9b5 <kernel_vsnprintf+0x3d3>
  10c991:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c995:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10c999:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c99d:	8b 00                	mov    eax,DWORD PTR [rax]
  10c99f:	89 c0                	mov    eax,eax
  10c9a1:	48 01 d0             	add    rax,rdx
  10c9a4:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c9a8:	8b 12                	mov    edx,DWORD PTR [rdx]
  10c9aa:	8d 4a 08             	lea    ecx,[rdx+0x8]
  10c9ad:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c9b1:	89 0a                	mov    DWORD PTR [rdx],ecx
  10c9b3:	eb 14                	jmp    10c9c9 <kernel_vsnprintf+0x3e7>
  10c9b5:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c9b9:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10c9bd:	48 8d 48 08          	lea    rcx,[rax+0x8]
  10c9c1:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c9c5:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  10c9c9:	48 8b 00             	mov    rax,QWORD PTR [rax]
  10c9cc:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
            if(bytes_written + str_length > capacity) return bytes_written;
  10c9d0:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10c9d4:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10c9d8:	48 01 d0             	add    rax,rdx
  10c9db:	48 3b 45 90          	cmp    rax,QWORD PTR [rbp-0x70]
  10c9df:	76 09                	jbe    10c9ea <kernel_vsnprintf+0x408>
  10c9e1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c9e5:	e9 cb 00 00 00       	jmp    10cab5 <kernel_vsnprintf+0x4d3>
            memcpy(buffer + bytes_written, str, str_length);
  10c9ea:	48 8b 55 98          	mov    rdx,QWORD PTR [rbp-0x68]
  10c9ee:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c9f2:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
  10c9f6:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  10c9fa:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  10c9fe:	48 89 c6             	mov    rsi,rax
  10ca01:	48 89 cf             	mov    rdi,rcx
  10ca04:	e8 39 c6 ff ff       	call   109042 <__memcpy>
            bytes_written += str_length;
  10ca09:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10ca0d:	48 01 45 f8          	add    QWORD PTR [rbp-0x8],rax
  10ca11:	e9 85 00 00 00       	jmp    10ca9b <kernel_vsnprintf+0x4b9>
        }
			}
		}

		else {
      size_t begin = fmt_index;
  10ca16:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10ca1a:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
      while(fmt[fmt_index] != '%' && fmt[fmt_index] != 0){
  10ca1e:	eb 05                	jmp    10ca25 <kernel_vsnprintf+0x443>
       fmt_index++; 
  10ca20:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
      while(fmt[fmt_index] != '%' && fmt[fmt_index] != 0){
  10ca25:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10ca29:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10ca2d:	48 01 d0             	add    rax,rdx
  10ca30:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10ca33:	3c 25                	cmp    al,0x25
  10ca35:	74 12                	je     10ca49 <kernel_vsnprintf+0x467>
  10ca37:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10ca3b:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10ca3f:	48 01 d0             	add    rax,rdx
  10ca42:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10ca45:	84 c0                	test   al,al
  10ca47:	75 d7                	jne    10ca20 <kernel_vsnprintf+0x43e>
      }

      size_t length = fmt_index - begin;
  10ca49:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10ca4d:	48 2b 45 e8          	sub    rax,QWORD PTR [rbp-0x18]
  10ca51:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
      if(bytes_written + length > capacity) return bytes_written;
  10ca55:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10ca59:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10ca5d:	48 01 d0             	add    rax,rdx
  10ca60:	48 3b 45 90          	cmp    rax,QWORD PTR [rbp-0x70]
  10ca64:	76 06                	jbe    10ca6c <kernel_vsnprintf+0x48a>
  10ca66:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10ca6a:	eb 49                	jmp    10cab5 <kernel_vsnprintf+0x4d3>
      memcpy(buffer + bytes_written, fmt + begin, length);
  10ca6c:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10ca70:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10ca74:	48 8d 34 02          	lea    rsi,[rdx+rax*1]
  10ca78:	48 8b 55 98          	mov    rdx,QWORD PTR [rbp-0x68]
  10ca7c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10ca80:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
  10ca84:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10ca88:	48 89 c2             	mov    rdx,rax
  10ca8b:	48 89 cf             	mov    rdi,rcx
  10ca8e:	e8 af c5 ff ff       	call   109042 <__memcpy>
      bytes_written += length;
  10ca93:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10ca97:	48 01 45 f8          	add    QWORD PTR [rbp-0x8],rax
  while(fmt[fmt_index] != 0){
  10ca9b:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10ca9f:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10caa3:	48 01 d0             	add    rax,rdx
  10caa6:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10caa9:	84 c0                	test   al,al
  10caab:	0f 85 5e fb ff ff    	jne    10c60f <kernel_vsnprintf+0x2d>
		}
  } 
  return bytes_written;
  10cab1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
}
  10cab5:	c9                   	leave  
  10cab6:	c3                   	ret    

000000000010cab7 <klog_get_next_available_entry>:

Circular_Log_Entry *klog_get_next_available_entry(Circular_Log *log){
  10cab7:	55                   	push   rbp
  10cab8:	48 89 e5             	mov    rbp,rsp
  10cabb:	48 83 ec 18          	sub    rsp,0x18
  10cabf:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  spinlock_aquire(&log->spinlock);
  10cac3:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cac7:	48 05 20 05 01 00    	add    rax,0x10520
  10cacd:	48 89 c7             	mov    rdi,rax
  10cad0:	e8 e9 c6 ff ff       	call   1091be <spinlock_aquire>
  size_t entry_index = log->entry_write_position % CIRCULAR_LOG_ENTRY_COUNT; 
  10cad5:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cad9:	48 8b 80 00 04 01 00 	mov    rax,QWORD PTR [rax+0x10400]
  10cae0:	25 ff 00 00 00       	and    eax,0xff
  10cae5:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  Circular_Log_Entry *entry = &log->entries[entry_index];
  10cae9:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10caed:	48 89 d0             	mov    rax,rdx
  10caf0:	48 c1 e0 06          	shl    rax,0x6
  10caf4:	48 01 d0             	add    rax,rdx
  10caf7:	48 c1 e0 02          	shl    rax,0x2
  10cafb:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  10caff:	48 01 d0             	add    rax,rdx
  10cb02:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
  log->entry_write_position++;
  10cb06:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cb0a:	48 8b 80 00 04 01 00 	mov    rax,QWORD PTR [rax+0x10400]
  10cb11:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10cb15:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cb19:	48 89 90 00 04 01 00 	mov    QWORD PTR [rax+0x10400],rdx
  if(log->current_entry_count < CIRCULAR_LOG_ENTRY_COUNT) {
  10cb20:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cb24:	48 8b 80 08 04 01 00 	mov    rax,QWORD PTR [rax+0x10408]
  10cb2b:	48 3d ff 00 00 00    	cmp    rax,0xff
  10cb31:	77 1a                	ja     10cb4d <klog_get_next_available_entry+0x96>
    log->current_entry_count++; 
  10cb33:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cb37:	48 8b 80 08 04 01 00 	mov    rax,QWORD PTR [rax+0x10408]
  10cb3e:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10cb42:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cb46:	48 89 90 08 04 01 00 	mov    QWORD PTR [rax+0x10408],rdx
  }
  spinlock_release(&log->spinlock);
  10cb4d:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cb51:	48 05 20 05 01 00    	add    rax,0x10520
  10cb57:	48 89 c7             	mov    rdi,rax
  10cb5a:	e8 8e c6 ff ff       	call   1091ed <spinlock_release>
  return entry;
  10cb5f:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
}
  10cb63:	c9                   	leave  
  10cb64:	c3                   	ret    

000000000010cb65 <klog_write_string>:

void klog_write_string(Circular_Log *log, const char *string, size_t length){
  10cb65:	55                   	push   rbp
  10cb66:	48 89 e5             	mov    rbp,rsp
  10cb69:	48 83 ec 30          	sub    rsp,0x30
  10cb6d:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10cb71:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  10cb75:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
  if(length > CIRCULAR_LOG_MESSAGE_SIZE){
  10cb79:	48 81 7d d8 00 01 00 	cmp    QWORD PTR [rbp-0x28],0x100
  10cb80:	00 
  10cb81:	76 40                	jbe    10cbc3 <klog_write_string+0x5e>
    klog_error("failed to print string of length: %u", length);
  10cb83:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10cb87:	48 89 c2             	mov    rdx,rax
  10cb8a:	be 30 80 10 00       	mov    esi,0x108030
  10cb8f:	bf 00 e0 10 00       	mov    edi,0x10e000
  10cb94:	b8 00 00 00 00       	mov    eax,0x0
  10cb99:	e8 c9 00 00 00       	call   10cc67 <klog_write_fmt>
    klog_error("string: %.*s", 30, string);
  10cb9e:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10cba2:	48 89 c1             	mov    rcx,rax
  10cba5:	ba 1e 00 00 00       	mov    edx,0x1e
  10cbaa:	be 55 80 10 00       	mov    esi,0x108055
  10cbaf:	bf 00 e0 10 00       	mov    edi,0x10e000
  10cbb4:	b8 00 00 00 00       	mov    eax,0x0
  10cbb9:	e8 a9 00 00 00       	call   10cc67 <klog_write_fmt>
    return;
  10cbbe:	e9 a2 00 00 00       	jmp    10cc65 <klog_write_string+0x100>
  }

  if(globals.is_logging_disabled) return;
  10cbc3:	0f b6 05 96 1b 01 00 	movzx  eax,BYTE PTR [rip+0x11b96]        # 11e760 <globals+0x10760>
  10cbca:	84 c0                	test   al,al
  10cbcc:	0f 85 92 00 00 00    	jne    10cc64 <klog_write_string+0xff>
  Circular_Log_Entry *entry = klog_get_next_available_entry(log);
  10cbd2:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cbd6:	48 89 c7             	mov    rdi,rax
  10cbd9:	e8 d9 fe ff ff       	call   10cab7 <klog_get_next_available_entry>
  10cbde:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  memcpy(entry->message, string, length);
  10cbe2:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cbe6:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
  10cbea:	48 8b 4d e0          	mov    rcx,QWORD PTR [rbp-0x20]
  10cbee:	48 89 ce             	mov    rsi,rcx
  10cbf1:	48 89 c7             	mov    rdi,rax
  10cbf4:	e8 49 c4 ff ff       	call   109042 <__memcpy>
  entry->length = length;
  10cbf9:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10cbfd:	89 c2                	mov    edx,eax
  10cbff:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cc03:	89 90 00 01 00 00    	mov    DWORD PTR [rax+0x100],edx

  spinlock_aquire(&log->spinlock);
  10cc09:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cc0d:	48 05 20 05 01 00    	add    rax,0x10520
  10cc13:	48 89 c7             	mov    rdi,rax
  10cc16:	e8 a3 c5 ff ff       	call   1091be <spinlock_aquire>
  log->is_dirty = true;
  10cc1b:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cc1f:	c6 80 24 05 01 00 01 	mov    BYTE PTR [rax+0x10524],0x1
  write_serial(entry->message, entry->length);
  10cc26:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cc2a:	8b 80 00 01 00 00    	mov    eax,DWORD PTR [rax+0x100]
  10cc30:	89 c2                	mov    edx,eax
  10cc32:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cc36:	48 89 d6             	mov    rsi,rdx
  10cc39:	48 89 c7             	mov    rdi,rax
  10cc3c:	e8 ac dc ff ff       	call   10a8ed <write_serial>
  write_serial("\n", 1);
  10cc41:	be 01 00 00 00       	mov    esi,0x1
  10cc46:	bf 62 80 10 00       	mov    edi,0x108062
  10cc4b:	e8 9d dc ff ff       	call   10a8ed <write_serial>
  spinlock_release(&log->spinlock);
  10cc50:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cc54:	48 05 20 05 01 00    	add    rax,0x10520
  10cc5a:	48 89 c7             	mov    rdi,rax
  10cc5d:	e8 8b c5 ff ff       	call   1091ed <spinlock_release>
  10cc62:	eb 01                	jmp    10cc65 <klog_write_string+0x100>
  if(globals.is_logging_disabled) return;
  10cc64:	90                   	nop
}
  10cc65:	c9                   	leave  
  10cc66:	c3                   	ret    

000000000010cc67 <klog_write_fmt>:

void klog_write_fmt(Circular_Log *log, const char *fmt, ...){
  10cc67:	55                   	push   rbp
  10cc68:	48 89 e5             	mov    rbp,rsp
  10cc6b:	48 81 ec f0 00 00 00 	sub    rsp,0xf0
  10cc72:	48 89 bd 18 ff ff ff 	mov    QWORD PTR [rbp-0xe8],rdi
  10cc79:	48 89 b5 10 ff ff ff 	mov    QWORD PTR [rbp-0xf0],rsi
  10cc80:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  10cc87:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  10cc8e:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  10cc95:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  10cc9c:	84 c0                	test   al,al
  10cc9e:	74 20                	je     10ccc0 <klog_write_fmt+0x59>
  10cca0:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  10cca4:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  10cca8:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  10ccac:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  10ccb0:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  10ccb4:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  10ccb8:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  10ccbc:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
  if(globals.is_logging_disabled) return;
  10ccc0:	0f b6 05 99 1a 01 00 	movzx  eax,BYTE PTR [rip+0x11a99]        # 11e760 <globals+0x10760>
  10ccc7:	84 c0                	test   al,al
  10ccc9:	0f 85 88 01 00 00    	jne    10ce57 <klog_write_fmt+0x1f0>

  spinlock_aquire(&log->spinlock); 
  10cccf:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10ccd6:	48 05 20 05 01 00    	add    rax,0x10520
  10ccdc:	48 89 c7             	mov    rdi,rax
  10ccdf:	e8 da c4 ff ff       	call   1091be <spinlock_aquire>
  size_t entry_index = log->entry_write_position % CIRCULAR_LOG_ENTRY_COUNT;
  10cce4:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10cceb:	48 8b 80 00 04 01 00 	mov    rax,QWORD PTR [rax+0x10400]
  10ccf2:	25 ff 00 00 00       	and    eax,0xff
  10ccf7:	48 89 85 48 ff ff ff 	mov    QWORD PTR [rbp-0xb8],rax
  Circular_Log_Entry *entry = &log->entries[entry_index];
  10ccfe:	48 8b 95 48 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xb8]
  10cd05:	48 89 d0             	mov    rax,rdx
  10cd08:	48 c1 e0 06          	shl    rax,0x6
  10cd0c:	48 01 d0             	add    rax,rdx
  10cd0f:	48 c1 e0 02          	shl    rax,0x2
  10cd13:	48 8b 95 18 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xe8]
  10cd1a:	48 01 d0             	add    rax,rdx
  10cd1d:	48 89 85 40 ff ff ff 	mov    QWORD PTR [rbp-0xc0],rax
  log->entry_write_position++;
  10cd24:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10cd2b:	48 8b 80 00 04 01 00 	mov    rax,QWORD PTR [rax+0x10400]
  10cd32:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10cd36:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10cd3d:	48 89 90 00 04 01 00 	mov    QWORD PTR [rax+0x10400],rdx
  if(log->current_entry_count < CIRCULAR_LOG_ENTRY_COUNT){ log->current_entry_count++; }
  10cd44:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10cd4b:	48 8b 80 08 04 01 00 	mov    rax,QWORD PTR [rax+0x10408]
  10cd52:	48 3d ff 00 00 00    	cmp    rax,0xff
  10cd58:	77 20                	ja     10cd7a <klog_write_fmt+0x113>
  10cd5a:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10cd61:	48 8b 80 08 04 01 00 	mov    rax,QWORD PTR [rax+0x10408]
  10cd68:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10cd6c:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10cd73:	48 89 90 08 04 01 00 	mov    QWORD PTR [rax+0x10408],rdx
  spinlock_release(&log->spinlock);
  10cd7a:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10cd81:	48 05 20 05 01 00    	add    rax,0x10520
  10cd87:	48 89 c7             	mov    rdi,rax
  10cd8a:	e8 5e c4 ff ff       	call   1091ed <spinlock_release>
  
  va_list args;
  va_start(args, fmt);
  10cd8f:	c7 85 28 ff ff ff 10 	mov    DWORD PTR [rbp-0xd8],0x10
  10cd96:	00 00 00 
  10cd99:	c7 85 2c ff ff ff 30 	mov    DWORD PTR [rbp-0xd4],0x30
  10cda0:	00 00 00 
  10cda3:	48 8d 45 10          	lea    rax,[rbp+0x10]
  10cda7:	48 89 85 30 ff ff ff 	mov    QWORD PTR [rbp-0xd0],rax
  10cdae:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
  10cdb5:	48 89 85 38 ff ff ff 	mov    QWORD PTR [rbp-0xc8],rax
  entry->length = kernel_vsnprintf(entry->message, CIRCULAR_LOG_MESSAGE_SIZE, fmt, args);
  10cdbc:	48 8b 85 40 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc0]
  10cdc3:	48 8d 8d 28 ff ff ff 	lea    rcx,[rbp-0xd8]
  10cdca:	48 8b 95 10 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xf0]
  10cdd1:	be 00 01 00 00       	mov    esi,0x100
  10cdd6:	48 89 c7             	mov    rdi,rax
  10cdd9:	e8 04 f8 ff ff       	call   10c5e2 <kernel_vsnprintf>
  10cdde:	89 c2                	mov    edx,eax
  10cde0:	48 8b 85 40 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc0]
  10cde7:	89 90 00 01 00 00    	mov    DWORD PTR [rax+0x100],edx
  va_end(args);

  //NOTE(Torin: 2016-08-08) This could cause serial output to mismatch
  //console output if a cpu core formats a sufficantly small message and aquires
  //the spin lock before the first core finishes formating the message
  spinlock_aquire(&log->spinlock);
  10cded:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10cdf4:	48 05 20 05 01 00    	add    rax,0x10520
  10cdfa:	48 89 c7             	mov    rdi,rax
  10cdfd:	e8 bc c3 ff ff       	call   1091be <spinlock_aquire>
  log->is_dirty = true;
  10ce02:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10ce09:	c6 80 24 05 01 00 01 	mov    BYTE PTR [rax+0x10524],0x1
  write_serial(entry->message, entry->length);
  10ce10:	48 8b 85 40 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc0]
  10ce17:	8b 80 00 01 00 00    	mov    eax,DWORD PTR [rax+0x100]
  10ce1d:	89 c2                	mov    edx,eax
  10ce1f:	48 8b 85 40 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc0]
  10ce26:	48 89 d6             	mov    rsi,rdx
  10ce29:	48 89 c7             	mov    rdi,rax
  10ce2c:	e8 bc da ff ff       	call   10a8ed <write_serial>
  write_serial("\n", 1);
  10ce31:	be 01 00 00 00       	mov    esi,0x1
  10ce36:	bf 62 80 10 00       	mov    edi,0x108062
  10ce3b:	e8 ad da ff ff       	call   10a8ed <write_serial>
  spinlock_release(&log->spinlock);
  10ce40:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10ce47:	48 05 20 05 01 00    	add    rax,0x10520
  10ce4d:	48 89 c7             	mov    rdi,rax
  10ce50:	e8 98 c3 ff ff       	call   1091ed <spinlock_release>
  10ce55:	eb 01                	jmp    10ce58 <klog_write_fmt+0x1f1>
  if(globals.is_logging_disabled) return;
  10ce57:	90                   	nop
}
  10ce58:	c9                   	leave  
  10ce59:	c3                   	ret    

000000000010ce5a <klog_add_input_character>:

void klog_add_input_character(Circular_Log *log, const char c){
  10ce5a:	55                   	push   rbp
  10ce5b:	48 89 e5             	mov    rbp,rsp
  10ce5e:	48 83 ec 10          	sub    rsp,0x10
  10ce62:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  10ce66:	89 f0                	mov    eax,esi
  10ce68:	88 45 f4             	mov    BYTE PTR [rbp-0xc],al
  if(c < ' ' || c > '~') return;
  10ce6b:	80 7d f4 1f          	cmp    BYTE PTR [rbp-0xc],0x1f
  10ce6f:	0f 8e 8b 00 00 00    	jle    10cf00 <klog_add_input_character+0xa6>
  10ce75:	80 7d f4 7f          	cmp    BYTE PTR [rbp-0xc],0x7f
  10ce79:	0f 84 81 00 00 00    	je     10cf00 <klog_add_input_character+0xa6>
  spinlock_aquire(&log->spinlock);
  10ce7f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10ce83:	48 05 20 05 01 00    	add    rax,0x10520
  10ce89:	48 89 c7             	mov    rdi,rax
  10ce8c:	e8 2d c3 ff ff       	call   1091be <spinlock_aquire>
  if(log->input_buffer_count > sizeof(log->input_buffer)) {
  10ce91:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10ce95:	48 8b 80 18 05 01 00 	mov    rax,QWORD PTR [rax+0x10518]
  10ce9c:	48 3d 00 01 00 00    	cmp    rax,0x100
  10cea2:	76 14                	jbe    10ceb8 <klog_add_input_character+0x5e>
    spinlock_release(&log->spinlock);
  10cea4:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cea8:	48 05 20 05 01 00    	add    rax,0x10520
  10ceae:	48 89 c7             	mov    rdi,rax
  10ceb1:	e8 37 c3 ff ff       	call   1091ed <spinlock_release>
    return;
  10ceb6:	eb 49                	jmp    10cf01 <klog_add_input_character+0xa7>
  }
  log->input_buffer[log->input_buffer_count++] = c;
  10ceb8:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cebc:	48 8b 80 18 05 01 00 	mov    rax,QWORD PTR [rax+0x10518]
  10cec3:	48 8d 48 01          	lea    rcx,[rax+0x1]
  10cec7:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10cecb:	48 89 8a 18 05 01 00 	mov    QWORD PTR [rdx+0x10518],rcx
  10ced2:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10ced6:	0f b6 4d f4          	movzx  ecx,BYTE PTR [rbp-0xc]
  10ceda:	88 8c 02 18 04 01 00 	mov    BYTE PTR [rdx+rax*1+0x10418],cl
  log->is_dirty = true;
  10cee1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cee5:	c6 80 24 05 01 00 01 	mov    BYTE PTR [rax+0x10524],0x1
  spinlock_release(&log->spinlock);
  10ceec:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cef0:	48 05 20 05 01 00    	add    rax,0x10520
  10cef6:	48 89 c7             	mov    rdi,rax
  10cef9:	e8 ef c2 ff ff       	call   1091ed <spinlock_release>
  10cefe:	eb 01                	jmp    10cf01 <klog_add_input_character+0xa7>
  if(c < ' ' || c > '~') return;
  10cf00:	90                   	nop
}
  10cf01:	c9                   	leave  
  10cf02:	c3                   	ret    

000000000010cf03 <klog_remove_last_input_character>:

void klog_remove_last_input_character(Circular_Log *log){
  10cf03:	55                   	push   rbp
  10cf04:	48 89 e5             	mov    rbp,rsp
  10cf07:	48 83 ec 08          	sub    rsp,0x8
  10cf0b:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  spinlock_aquire(&log->spinlock);
  10cf0f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cf13:	48 05 20 05 01 00    	add    rax,0x10520
  10cf19:	48 89 c7             	mov    rdi,rax
  10cf1c:	e8 9d c2 ff ff       	call   1091be <spinlock_aquire>
  if(log->input_buffer_count > 0) {
  10cf21:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cf25:	48 8b 80 18 05 01 00 	mov    rax,QWORD PTR [rax+0x10518]
  10cf2c:	48 85 c0             	test   rax,rax
  10cf2f:	74 31                	je     10cf62 <klog_remove_last_input_character+0x5f>
    log->input_buffer[log->input_buffer_count] = 0;
  10cf31:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cf35:	48 8b 80 18 05 01 00 	mov    rax,QWORD PTR [rax+0x10518]
  10cf3c:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10cf40:	c6 84 02 18 04 01 00 	mov    BYTE PTR [rdx+rax*1+0x10418],0x0
  10cf47:	00 
    log->input_buffer_count -= 1;
  10cf48:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cf4c:	48 8b 80 18 05 01 00 	mov    rax,QWORD PTR [rax+0x10518]
  10cf53:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  10cf57:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cf5b:	48 89 90 18 05 01 00 	mov    QWORD PTR [rax+0x10518],rdx
  }
  log->is_dirty = true;
  10cf62:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cf66:	c6 80 24 05 01 00 01 	mov    BYTE PTR [rax+0x10524],0x1
  spinlock_release(&log->spinlock);
  10cf6d:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cf71:	48 05 20 05 01 00    	add    rax,0x10520
  10cf77:	48 89 c7             	mov    rdi,rax
  10cf7a:	e8 6e c2 ff ff       	call   1091ed <spinlock_release>
}
  10cf7f:	90                   	nop
  10cf80:	c9                   	leave  
  10cf81:	c3                   	ret    

000000000010cf82 <klog_submit_input_to_shell>:

void klog_submit_input_to_shell(Circular_Log *log){
  10cf82:	55                   	push   rbp
  10cf83:	48 89 e5             	mov    rbp,rsp
  10cf86:	48 83 ec 20          	sub    rsp,0x20
  10cf8a:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  if(log->input_buffer_count > 0){
  10cf8e:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cf92:	48 8b 80 18 05 01 00 	mov    rax,QWORD PTR [rax+0x10518]
  10cf99:	48 85 c0             	test   rax,rax
  10cf9c:	74 43                	je     10cfe1 <klog_submit_input_to_shell+0x5f>
    log->is_dirty = true;
  10cf9e:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cfa2:	c6 80 24 05 01 00 01 	mov    BYTE PTR [rax+0x10524],0x1
    size_t length = log->input_buffer_count;
  10cfa9:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cfad:	48 8b 80 18 05 01 00 	mov    rax,QWORD PTR [rax+0x10518]
  10cfb4:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
    log->input_buffer_count = 0;
  10cfb8:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cfbc:	48 c7 80 18 05 01 00 	mov    QWORD PTR [rax+0x10518],0x0
  10cfc3:	00 00 00 00 
    kshell_process_command(log->input_buffer, length);
  10cfc7:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cfcb:	48 8d 90 18 04 01 00 	lea    rdx,[rax+0x10418]
  10cfd2:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cfd6:	48 89 c6             	mov    rsi,rax
  10cfd9:	48 89 d7             	mov    rdi,rdx
  10cfdc:	e8 f0 01 00 00       	call   10d1d1 <kshell_process_command>
  } 
}
  10cfe1:	90                   	nop
  10cfe2:	c9                   	leave  
  10cfe3:	c3                   	ret    

000000000010cfe4 <klog_disable>:

	

void klog_disable(){
  10cfe4:	55                   	push   rbp
  10cfe5:	48 89 e5             	mov    rbp,rsp
  globals.is_logging_disabled = true;
  10cfe8:	c6 05 71 17 01 00 01 	mov    BYTE PTR [rip+0x11771],0x1        # 11e760 <globals+0x10760>
}
  10cfef:	90                   	nop
  10cff0:	5d                   	pop    rbp
  10cff1:	c3                   	ret    

000000000010cff2 <klog_enable>:

void klog_enable(){
  10cff2:	55                   	push   rbp
  10cff3:	48 89 e5             	mov    rbp,rsp
  globals.is_logging_disabled = false;
  10cff6:	c6 05 63 17 01 00 00 	mov    BYTE PTR [rip+0x11763],0x0        # 11e760 <globals+0x10760>
  10cffd:	90                   	nop
  10cffe:	5d                   	pop    rbp
  10cfff:	c3                   	ret    

000000000010d000 <kshell_help>:
KShell_Command_Metalist
#undef _
};

static void
kshell_help(const char *input, size_t length){
  10d000:	55                   	push   rbp
  10d001:	48 89 e5             	mov    rbp,rsp
  10d004:	48 83 ec 10          	sub    rsp,0x10
  10d008:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  10d00c:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
  klog_info("kshell command list:");
  10d010:	be c8 80 10 00       	mov    esi,0x1080c8
  10d015:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d01a:	b8 00 00 00 00       	mov    eax,0x0
  10d01f:	e8 43 fc ff ff       	call   10cc67 <klog_write_fmt>
  #define _(name, proc) \
  klog_info("  %s", #name);
  KShell_Command_Metalist
  10d024:	ba 64 80 10 00       	mov    edx,0x108064
  10d029:	be dd 80 10 00       	mov    esi,0x1080dd
  10d02e:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d033:	b8 00 00 00 00       	mov    eax,0x0
  10d038:	e8 2a fc ff ff       	call   10cc67 <klog_write_fmt>
  10d03d:	ba 69 80 10 00       	mov    edx,0x108069
  10d042:	be dd 80 10 00       	mov    esi,0x1080dd
  10d047:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d04c:	b8 00 00 00 00       	mov    eax,0x0
  10d051:	e8 11 fc ff ff       	call   10cc67 <klog_write_fmt>
  10d056:	ba 77 80 10 00       	mov    edx,0x108077
  10d05b:	be dd 80 10 00       	mov    esi,0x1080dd
  10d060:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d065:	b8 00 00 00 00       	mov    eax,0x0
  10d06a:	e8 f8 fb ff ff       	call   10cc67 <klog_write_fmt>
  10d06f:	ba 7c 80 10 00       	mov    edx,0x10807c
  10d074:	be dd 80 10 00       	mov    esi,0x1080dd
  10d079:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d07e:	b8 00 00 00 00       	mov    eax,0x0
  10d083:	e8 df fb ff ff       	call   10cc67 <klog_write_fmt>
  10d088:	ba 8b 80 10 00       	mov    edx,0x10808b
  10d08d:	be dd 80 10 00       	mov    esi,0x1080dd
  10d092:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d097:	b8 00 00 00 00       	mov    eax,0x0
  10d09c:	e8 c6 fb ff ff       	call   10cc67 <klog_write_fmt>
  #undef _
}
  10d0a1:	90                   	nop
  10d0a2:	c9                   	leave  
  10d0a3:	c3                   	ret    

000000000010d0a4 <kshell_run_test>:

static void
kshell_run_test(const char *text, size_t length){
  10d0a4:	55                   	push   rbp
  10d0a5:	48 89 e5             	mov    rbp,rsp
  10d0a8:	48 83 ec 40          	sub    rsp,0x40
  10d0ac:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  10d0b0:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  lapic_configure_timer(globals.system_info.lapic_virtual_address, 0x00, 0x20, 0);
  10d0b4:	48 8b 05 e5 15 01 00 	mov    rax,QWORD PTR [rip+0x115e5]        # 11e6a0 <globals+0x106a0>
  10d0bb:	b9 00 00 00 00       	mov    ecx,0x0
  10d0c0:	ba 20 00 00 00       	mov    edx,0x20
  10d0c5:	be 00 00 00 00       	mov    esi,0x0
  10d0ca:	48 89 c7             	mov    rdi,rax
  10d0cd:	e8 b6 cb ff ff       	call   109c88 <lapic_configure_timer>
  uintptr_t executable_physical_address = 0x00A00000;
  10d0d2:	48 c7 45 f8 00 00 a0 	mov    QWORD PTR [rbp-0x8],0xa00000
  10d0d9:	00 
  uintptr_t executable_physical_stack = 0x00C00000;
  10d0da:	48 c7 45 f0 00 00 c0 	mov    QWORD PTR [rbp-0x10],0xc00000
  10d0e1:	00 
  uintptr_t executable_virtual_address = 0x00400000;
  10d0e2:	48 c7 45 e8 00 00 40 	mov    QWORD PTR [rbp-0x18],0x400000
  10d0e9:	00 
  uintptr_t executable_virtual_stack = 0x00600000;
  10d0ea:	48 c7 45 e0 00 00 60 	mov    QWORD PTR [rbp-0x20],0x600000
  10d0f1:	00 
  kmem_map_physical_to_virtual_2MB_ext(executable_physical_address, executable_virtual_address, PAGE_USER_ACCESS_BIT);
  10d0f2:	ba 04 00 00 00       	mov    edx,0x4
  10d0f7:	48 8b 4d e8          	mov    rcx,QWORD PTR [rbp-0x18]
  10d0fb:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d0ff:	48 89 ce             	mov    rsi,rcx
  10d102:	48 89 c7             	mov    rdi,rax
  10d105:	e8 3b d8 ff ff       	call   10a945 <kmem_map_physical_to_virtual_2MB_ext>
  kmem_map_physical_to_virtual_2MB_ext(executable_physical_stack, executable_virtual_stack, PAGE_USER_ACCESS_BIT);
  10d10a:	ba 04 00 00 00       	mov    edx,0x4
  10d10f:	48 8b 4d e0          	mov    rcx,QWORD PTR [rbp-0x20]
  10d113:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10d117:	48 89 ce             	mov    rsi,rcx
  10d11a:	48 89 c7             	mov    rdi,rax
  10d11d:	e8 23 d8 ff ff       	call   10a945 <kmem_map_physical_to_virtual_2MB_ext>
  memcpy(executable_virtual_address, TEST_PROGRAM_ELF, sizeof(TEST_PROGRAM_ELF));
  10d122:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10d126:	ba f8 04 00 00       	mov    edx,0x4f8
  10d12b:	be e0 65 10 00       	mov    esi,0x1065e0
  10d130:	48 89 c7             	mov    rdi,rax
  10d133:	e8 0a bf ff ff       	call   109042 <__memcpy>
  uintptr_t start_address = kprocess_load_elf_executable(executable_virtual_address);
  10d138:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10d13c:	48 89 c7             	mov    rdi,rax
  10d13f:	e8 3a e6 ff ff       	call   10b77e <kprocess_load_elf_executable>
  10d144:	48 98                	cdqe   
  10d146:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
  uintptr_t stack_address = executable_virtual_stack + 0x1FFFFF;
  10d14a:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10d14e:	48 05 ff ff 1f 00    	add    rax,0x1fffff
  10d154:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
  asm_enter_usermode((uintptr_t)start_address, stack_address);
  10d158:	48 8b 55 d0          	mov    rdx,QWORD PTR [rbp-0x30]
  10d15c:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10d160:	48 89 d6             	mov    rsi,rdx
  10d163:	48 89 c7             	mov    rdi,rax
  10d166:	e8 54 03 00 00       	call   10d4bf <asm_enter_usermode>
}
  10d16b:	90                   	nop
  10d16c:	c9                   	leave  
  10d16d:	c3                   	ret    

000000000010d16e <kshell_ioapic_irq_map>:

static void
kshell_ioapic_irq_map(const char *text, size_t length){
  10d16e:	55                   	push   rbp
  10d16f:	48 89 e5             	mov    rbp,rsp
  10d172:	48 83 ec 10          	sub    rsp,0x10
  10d176:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  10d17a:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
  kdebug_ioapic_log_irq_map(globals.system_info.ioapic_virtual_address);
  10d17e:	48 8b 05 23 15 01 00 	mov    rax,QWORD PTR [rip+0x11523]        # 11e6a8 <globals+0x106a8>
  10d185:	48 89 c7             	mov    rdi,rax
  10d188:	e8 37 e6 ff ff       	call   10b7c4 <kdebug_ioapic_log_irq_map>
}
  10d18d:	90                   	nop
  10d18e:	c9                   	leave  
  10d18f:	c3                   	ret    

000000000010d190 <kshell_hardware_info>:

static void
kshell_hardware_info(const char *text, size_t length) {
  10d190:	55                   	push   rbp
  10d191:	48 89 e5             	mov    rbp,rsp
  10d194:	48 83 ec 10          	sub    rsp,0x10
  10d198:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  10d19c:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi

}
  10d1a0:	90                   	nop
  10d1a1:	c9                   	leave  
  10d1a2:	c3                   	ret    

000000000010d1a3 <kshell_unimplemented_command>:

static void
kshell_unimplemented_command(const char *text, size_t length){
  10d1a3:	55                   	push   rbp
  10d1a4:	48 89 e5             	mov    rbp,rsp
  10d1a7:	48 83 ec 10          	sub    rsp,0x10
  10d1ab:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  10d1af:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
  klog_error("%s is an unimplemented command!", text);
  10d1b3:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d1b7:	48 89 c2             	mov    rdx,rax
  10d1ba:	be e8 80 10 00       	mov    esi,0x1080e8
  10d1bf:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d1c4:	b8 00 00 00 00       	mov    eax,0x0
  10d1c9:	e8 99 fa ff ff       	call   10cc67 <klog_write_fmt>
}
  10d1ce:	90                   	nop
  10d1cf:	c9                   	leave  
  10d1d0:	c3                   	ret    

000000000010d1d1 <kshell_process_command>:

void kshell_process_command(const char *input, size_t length){
  10d1d1:	55                   	push   rbp
  10d1d2:	48 89 e5             	mov    rbp,rsp
  10d1d5:	48 83 ec 10          	sub    rsp,0x10
  10d1d9:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  10d1dd:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
  #define _(name, proc) \
  if(string_matches_string(#name, sizeof(#name)-1, input)){\
    proc(input, length);\
    return;\
  }
  KShell_Command_Metalist
  10d1e1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d1e5:	48 89 c2             	mov    rdx,rax
  10d1e8:	be 04 00 00 00       	mov    esi,0x4
  10d1ed:	bf 64 80 10 00       	mov    edi,0x108064
  10d1f2:	e8 39 bf ff ff       	call   109130 <string_matches_string>
  10d1f7:	85 c0                	test   eax,eax
  10d1f9:	74 18                	je     10d213 <kshell_process_command+0x42>
  10d1fb:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  10d1ff:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d203:	48 89 d6             	mov    rsi,rdx
  10d206:	48 89 c7             	mov    rdi,rax
  10d209:	e8 f2 fd ff ff       	call   10d000 <kshell_help>
  10d20e:	e9 da 00 00 00       	jmp    10d2ed <kshell_process_command+0x11c>
  10d213:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d217:	48 89 c2             	mov    rdx,rax
  10d21a:	be 0d 00 00 00       	mov    esi,0xd
  10d21f:	bf 69 80 10 00       	mov    edi,0x108069
  10d224:	e8 07 bf ff ff       	call   109130 <string_matches_string>
  10d229:	85 c0                	test   eax,eax
  10d22b:	74 18                	je     10d245 <kshell_process_command+0x74>
  10d22d:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  10d231:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d235:	48 89 d6             	mov    rsi,rdx
  10d238:	48 89 c7             	mov    rdi,rax
  10d23b:	e8 50 ff ff ff       	call   10d190 <kshell_hardware_info>
  10d240:	e9 a8 00 00 00       	jmp    10d2ed <kshell_process_command+0x11c>
  10d245:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d249:	48 89 c2             	mov    rdx,rax
  10d24c:	be 04 00 00 00       	mov    esi,0x4
  10d251:	bf 77 80 10 00       	mov    edi,0x108077
  10d256:	e8 d5 be ff ff       	call   109130 <string_matches_string>
  10d25b:	85 c0                	test   eax,eax
  10d25d:	74 15                	je     10d274 <kshell_process_command+0xa3>
  10d25f:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  10d263:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d267:	48 89 d6             	mov    rsi,rdx
  10d26a:	48 89 c7             	mov    rdi,rax
  10d26d:	e8 31 ff ff ff       	call   10d1a3 <kshell_unimplemented_command>
  10d272:	eb 79                	jmp    10d2ed <kshell_process_command+0x11c>
  10d274:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d278:	48 89 c2             	mov    rdx,rax
  10d27b:	be 0e 00 00 00       	mov    esi,0xe
  10d280:	bf 7c 80 10 00       	mov    edi,0x10807c
  10d285:	e8 a6 be ff ff       	call   109130 <string_matches_string>
  10d28a:	85 c0                	test   eax,eax
  10d28c:	74 15                	je     10d2a3 <kshell_process_command+0xd2>
  10d28e:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  10d292:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d296:	48 89 d6             	mov    rsi,rdx
  10d299:	48 89 c7             	mov    rdi,rax
  10d29c:	e8 cd fe ff ff       	call   10d16e <kshell_ioapic_irq_map>
  10d2a1:	eb 4a                	jmp    10d2ed <kshell_process_command+0x11c>
  10d2a3:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d2a7:	48 89 c2             	mov    rdx,rax
  10d2aa:	be 08 00 00 00       	mov    esi,0x8
  10d2af:	bf 8b 80 10 00       	mov    edi,0x10808b
  10d2b4:	e8 77 be ff ff       	call   109130 <string_matches_string>
  10d2b9:	85 c0                	test   eax,eax
  10d2bb:	74 15                	je     10d2d2 <kshell_process_command+0x101>
  10d2bd:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  10d2c1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d2c5:	48 89 d6             	mov    rsi,rdx
  10d2c8:	48 89 c7             	mov    rdi,rax
  10d2cb:	e8 d4 fd ff ff       	call   10d0a4 <kshell_run_test>
  10d2d0:	eb 1b                	jmp    10d2ed <kshell_process_command+0x11c>
  #undef _

  klog_error("%s is not a shell command", input);
  10d2d2:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d2d6:	48 89 c2             	mov    rdx,rax
  10d2d9:	be 08 81 10 00       	mov    esi,0x108108
  10d2de:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d2e3:	b8 00 00 00 00       	mov    eax,0x0
  10d2e8:	e8 7a f9 ff ff       	call   10cc67 <klog_write_fmt>
}
  10d2ed:	c9                   	leave  
  10d2ee:	c3                   	ret    
  10d2ef:	90                   	nop

000000000010d2f0 <asm_double_fault_handler>:
  10d2f0:	fa                   	cli    
  10d2f1:	c7 04 25 00 80 0b 00 	mov    DWORD PTR ds:0xb8000,0x2064
  10d2f8:	64 20 00 00 
  10d2fc:	c7 04 25 04 80 0b 00 	mov    DWORD PTR ds:0xb8004,0x2066
  10d303:	66 20 00 00 
  10d307:	c7 04 25 08 80 0b 00 	mov    DWORD PTR ds:0xb8008,0x206c
  10d30e:	6c 20 00 00 
  10d312:	f4                   	hlt    
  10d313:	48 cf                	iretq  

000000000010d315 <asm_debug_handler>:
  10d315:	fa                   	cli    
  10d316:	c7 04 25 00 80 0b 00 	mov    DWORD PTR ds:0xb8000,0x61
  10d31d:	61 00 00 00 
  10d321:	c7 04 25 04 80 0b 00 	mov    DWORD PTR ds:0xb8004,0x62
  10d328:	62 00 00 00 
  10d32c:	c7 04 25 08 80 0b 00 	mov    DWORD PTR ds:0xb8008,0x63
  10d333:	63 00 00 00 
  10d337:	f4                   	hlt    
  10d338:	48 cf                	iretq  

000000000010d33a <asm_spurious_interrupt_handler>:
  10d33a:	48 cf                	iretq  

000000000010d33c <asm_irq_common_handler>:
  10d33c:	50                   	push   rax
  10d33d:	53                   	push   rbx
  10d33e:	51                   	push   rcx
  10d33f:	e8 2f ee ff ff       	call   10c173 <irq_common_handler>
  10d344:	59                   	pop    rcx
  10d345:	5b                   	pop    rbx
  10d346:	58                   	pop    rax
  10d347:	83 c4 08             	add    esp,0x8
  10d34a:	fb                   	sti    
  10d34b:	48 cf                	iretq  

000000000010d34d <asm_isr_common_handler>:
  10d34d:	50                   	push   rax
  10d34e:	53                   	push   rbx
  10d34f:	51                   	push   rcx
  10d350:	e8 76 ed ff ff       	call   10c0cb <isr_common_handler>
  10d355:	59                   	pop    rcx
  10d356:	5b                   	pop    rbx
  10d357:	58                   	pop    rax
  10d358:	83 c4 10             	add    esp,0x10
  10d35b:	fb                   	sti    
  10d35c:	48 cf                	iretq  

000000000010d35e <asm_syscall_handler>:
  10d35e:	fa                   	cli    
  10d35f:	48 8b 04 c5 d0 7e 10 	mov    rax,QWORD PTR [rax*8+0x107ed0]
  10d366:	00 
  10d367:	ff d0                	call   rax
  10d369:	fb                   	sti    
  10d36a:	48 cf                	iretq  

000000000010d36c <asm_isr0>:
  10d36c:	fa                   	cli    
  10d36d:	6a 00                	push   0x0
  10d36f:	6a 00                	push   0x0
  10d371:	eb da                	jmp    10d34d <asm_isr_common_handler>

000000000010d373 <asm_isr1>:
  10d373:	fa                   	cli    
  10d374:	6a 00                	push   0x0
  10d376:	6a 01                	push   0x1
  10d378:	eb d3                	jmp    10d34d <asm_isr_common_handler>

000000000010d37a <asm_isr2>:
  10d37a:	fa                   	cli    
  10d37b:	6a 00                	push   0x0
  10d37d:	6a 02                	push   0x2
  10d37f:	eb cc                	jmp    10d34d <asm_isr_common_handler>

000000000010d381 <asm_isr3>:
  10d381:	fa                   	cli    
  10d382:	6a 00                	push   0x0
  10d384:	6a 03                	push   0x3
  10d386:	eb c5                	jmp    10d34d <asm_isr_common_handler>

000000000010d388 <asm_isr4>:
  10d388:	fa                   	cli    
  10d389:	6a 00                	push   0x0
  10d38b:	6a 04                	push   0x4
  10d38d:	eb be                	jmp    10d34d <asm_isr_common_handler>

000000000010d38f <asm_isr5>:
  10d38f:	fa                   	cli    
  10d390:	6a 00                	push   0x0
  10d392:	6a 05                	push   0x5
  10d394:	eb b7                	jmp    10d34d <asm_isr_common_handler>

000000000010d396 <asm_isr6>:
  10d396:	fa                   	cli    
  10d397:	6a 00                	push   0x0
  10d399:	6a 06                	push   0x6
  10d39b:	eb b0                	jmp    10d34d <asm_isr_common_handler>

000000000010d39d <asm_isr7>:
  10d39d:	fa                   	cli    
  10d39e:	6a 00                	push   0x0
  10d3a0:	6a 07                	push   0x7
  10d3a2:	eb a9                	jmp    10d34d <asm_isr_common_handler>

000000000010d3a4 <asm_isr8>:
  10d3a4:	fa                   	cli    
  10d3a5:	6a 08                	push   0x8
  10d3a7:	eb a4                	jmp    10d34d <asm_isr_common_handler>

000000000010d3a9 <asm_isr9>:
  10d3a9:	fa                   	cli    
  10d3aa:	6a 00                	push   0x0
  10d3ac:	6a 09                	push   0x9
  10d3ae:	eb 9d                	jmp    10d34d <asm_isr_common_handler>

000000000010d3b0 <asm_isr10>:
  10d3b0:	fa                   	cli    
  10d3b1:	6a 0a                	push   0xa
  10d3b3:	eb 98                	jmp    10d34d <asm_isr_common_handler>

000000000010d3b5 <asm_isr11>:
  10d3b5:	fa                   	cli    
  10d3b6:	6a 0b                	push   0xb
  10d3b8:	eb 93                	jmp    10d34d <asm_isr_common_handler>

000000000010d3ba <asm_isr12>:
  10d3ba:	fa                   	cli    
  10d3bb:	6a 0c                	push   0xc
  10d3bd:	eb 8e                	jmp    10d34d <asm_isr_common_handler>

000000000010d3bf <asm_isr13>:
  10d3bf:	fa                   	cli    
  10d3c0:	6a 0d                	push   0xd
  10d3c2:	eb 89                	jmp    10d34d <asm_isr_common_handler>

000000000010d3c4 <asm_isr14>:
  10d3c4:	fa                   	cli    
  10d3c5:	6a 0e                	push   0xe
  10d3c7:	eb 84                	jmp    10d34d <asm_isr_common_handler>

000000000010d3c9 <asm_isr15>:
  10d3c9:	fa                   	cli    
  10d3ca:	6a 00                	push   0x0
  10d3cc:	6a 0f                	push   0xf
  10d3ce:	e9 7a ff ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d3d3 <asm_isr16>:
  10d3d3:	fa                   	cli    
  10d3d4:	6a 00                	push   0x0
  10d3d6:	6a 10                	push   0x10
  10d3d8:	e9 70 ff ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d3dd <asm_isr17>:
  10d3dd:	fa                   	cli    
  10d3de:	6a 11                	push   0x11
  10d3e0:	e9 68 ff ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d3e5 <asm_isr18>:
  10d3e5:	fa                   	cli    
  10d3e6:	6a 00                	push   0x0
  10d3e8:	6a 12                	push   0x12
  10d3ea:	e9 5e ff ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d3ef <asm_isr19>:
  10d3ef:	fa                   	cli    
  10d3f0:	6a 00                	push   0x0
  10d3f2:	6a 13                	push   0x13
  10d3f4:	e9 54 ff ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d3f9 <asm_isr20>:
  10d3f9:	fa                   	cli    
  10d3fa:	6a 00                	push   0x0
  10d3fc:	6a 14                	push   0x14
  10d3fe:	e9 4a ff ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d403 <asm_isr21>:
  10d403:	fa                   	cli    
  10d404:	6a 00                	push   0x0
  10d406:	6a 15                	push   0x15
  10d408:	e9 40 ff ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d40d <asm_isr22>:
  10d40d:	fa                   	cli    
  10d40e:	6a 00                	push   0x0
  10d410:	6a 16                	push   0x16
  10d412:	e9 36 ff ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d417 <asm_isr23>:
  10d417:	fa                   	cli    
  10d418:	6a 00                	push   0x0
  10d41a:	6a 17                	push   0x17
  10d41c:	e9 2c ff ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d421 <asm_isr24>:
  10d421:	fa                   	cli    
  10d422:	6a 00                	push   0x0
  10d424:	6a 18                	push   0x18
  10d426:	e9 22 ff ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d42b <asm_isr25>:
  10d42b:	fa                   	cli    
  10d42c:	6a 00                	push   0x0
  10d42e:	6a 19                	push   0x19
  10d430:	e9 18 ff ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d435 <asm_isr26>:
  10d435:	fa                   	cli    
  10d436:	6a 00                	push   0x0
  10d438:	6a 1a                	push   0x1a
  10d43a:	e9 0e ff ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d43f <asm_isr27>:
  10d43f:	fa                   	cli    
  10d440:	6a 00                	push   0x0
  10d442:	6a 1b                	push   0x1b
  10d444:	e9 04 ff ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d449 <asm_isr28>:
  10d449:	fa                   	cli    
  10d44a:	6a 00                	push   0x0
  10d44c:	6a 1c                	push   0x1c
  10d44e:	e9 fa fe ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d453 <asm_isr29>:
  10d453:	fa                   	cli    
  10d454:	6a 00                	push   0x0
  10d456:	6a 1d                	push   0x1d
  10d458:	e9 f0 fe ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d45d <asm_isr30>:
  10d45d:	fa                   	cli    
  10d45e:	6a 00                	push   0x0
  10d460:	6a 1e                	push   0x1e
  10d462:	e9 e6 fe ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d467 <asm_isr31>:
  10d467:	fa                   	cli    
  10d468:	6a 00                	push   0x0
  10d46a:	6a 1f                	push   0x1f
  10d46c:	e9 dc fe ff ff       	jmp    10d34d <asm_isr_common_handler>

000000000010d471 <asm_irq0>:
  10d471:	fa                   	cli    
  10d472:	6a 00                	push   0x0
  10d474:	e9 c3 fe ff ff       	jmp    10d33c <asm_irq_common_handler>

000000000010d479 <asm_irq1>:
  10d479:	fa                   	cli    
  10d47a:	6a 01                	push   0x1
  10d47c:	e9 bb fe ff ff       	jmp    10d33c <asm_irq_common_handler>

000000000010d481 <asm_irq128>:
  10d481:	fa                   	cli    
  10d482:	68 80 00 00 00       	push   0x80
  10d487:	e9 b0 fe ff ff       	jmp    10d33c <asm_irq_common_handler>

000000000010d48c <asm_longmode_entry>:
  10d48c:	66 b8 08 00          	mov    ax,0x8
  10d490:	8e d8                	mov    ds,eax
  10d492:	8e c0                	mov    es,eax
  10d494:	8e e0                	mov    fs,eax
  10d496:	8e e8                	mov    gs,eax
  10d498:	66 b8 00 00          	mov    ax,0x0
  10d49c:	8e d0                	mov    ss,eax
  10d49e:	5f                   	pop    rdi
  10d49f:	5e                   	pop    rsi
  10d4a0:	e8 47 e7 ff ff       	call   10bbec <kernel_longmode_entry>

000000000010d4a5 <asm_exit_usermode>:
  10d4a5:	fa                   	cli    
  10d4a6:	66 b8 08 00          	mov    ax,0x8
  10d4aa:	8e d8                	mov    ds,eax
  10d4ac:	8e c0                	mov    es,eax
  10d4ae:	8e e0                	mov    fs,eax
  10d4b0:	8e e8                	mov    gs,eax
  10d4b2:	66 b8 00 00          	mov    ax,0x0
  10d4b6:	8e d0                	mov    ss,eax
  10d4b8:	fb                   	sti    
  10d4b9:	e8 54 eb ff ff       	call   10c012 <kprocess_destroy>
  10d4be:	f4                   	hlt    

000000000010d4bf <asm_enter_usermode>:
  10d4bf:	fa                   	cli    
  10d4c0:	66 b8 13 00          	mov    ax,0x13
  10d4c4:	8e d8                	mov    ds,eax
  10d4c6:	8e c0                	mov    es,eax
  10d4c8:	8e e0                	mov    fs,eax
  10d4ca:	8e e8                	mov    gs,eax
  10d4cc:	6a 13                	push   0x13
  10d4ce:	56                   	push   rsi
  10d4cf:	9c                   	pushf  
  10d4d0:	58                   	pop    rax
  10d4d1:	48 0d 00 02 00 00    	or     rax,0x200
  10d4d7:	50                   	push   rax
  10d4d8:	6a 23                	push   0x23
  10d4da:	57                   	push   rdi
  10d4db:	48 cf                	iretq  
  10d4dd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000010d4e0 <start>:
  10d4e0:	fa                   	cli    
  10d4e1:	bc 02 70 12 00       	mov    esp,0x127002
  10d4e6:	3d 89 62 d7 36       	cmp    eax,0x36d76289
  10d4eb:	75 02                	jne    10d4ef <start.no_multiboot>
  10d4ed:	eb 07                	jmp    10d4f6 <start.valid_multiboot>

000000000010d4ef <start.no_multiboot>:
  10d4ef:	b0 30                	mov    al,0x30
  10d4f1:	e9 cf 00 00 00       	jmp    10d5c5 <error_handler>

000000000010d4f6 <start.valid_multiboot>:
  10d4f6:	6a 00                	push   0x0
  10d4f8:	53                   	push   rbx
  10d4f9:	6a 00                	push   0x0
  10d4fb:	50                   	push   rax
  10d4fc:	e8 8a 00 00 00       	call   10d58b <is_cpuid_supported>
  10d501:	e8 9d 00 00 00       	call   10d5a3 <is_longmode_supported>
  10d506:	e8 2b 00 00 00       	call   10d536 <setup_paging_tables>
  10d50b:	e8 50 00 00 00       	call   10d560 <enable_paging>
  10d510:	0f 20 c0             	mov    rax,cr0
  10d513:	66 83 e0 fb          	and    ax,0xfffb
  10d517:	66 83 c8 02          	or     ax,0x2
  10d51b:	0f 22 c0             	mov    cr0,rax
  10d51e:	0f 20 e0             	mov    rax,cr4
  10d521:	66 0d 00 06          	or     ax,0x600
  10d525:	0f 22 e0             	mov    cr4,rax
  10d528:	0f 01 15 08 8c 10 00 	lgdt   [rip+0x108c08]        # 216137 <stack_top+0xef135>
  10d52f:	ea                   	(bad)  
  10d530:	8c d4                	mov    esp,ss
  10d532:	10 00                	adc    BYTE PTR [rax],al
  10d534:	18 00                	sbb    BYTE PTR [rax],al

000000000010d536 <setup_paging_tables>:
  10d536:	b8 00 30 12 00       	mov    eax,0x123000
  10d53b:	83 c8 07             	or     eax,0x7
  10d53e:	a3 00 20 12 00 b8 00 	movabs ds:0x124000b800122000,eax
  10d545:	40 12 
  10d547:	00 83 c8 07 a3 00    	add    BYTE PTR [rbx+0xa307c8],al
  10d54d:	30 12                	xor    BYTE PTR [rdx],dl
  10d54f:	00 b8 00 00 00 00    	add    BYTE PTR [rax+0x0],bh
  10d555:	0d 83 00 00 00       	or     eax,0x83
  10d55a:	a3                   	.byte 0xa3
  10d55b:	00 40 12             	add    BYTE PTR [rax+0x12],al
  10d55e:	00 c3                	add    bl,al

000000000010d560 <enable_paging>:
  10d560:	b8 00 20 12 00       	mov    eax,0x122000
  10d565:	0f 22 d8             	mov    cr3,rax
  10d568:	0f 20 e0             	mov    rax,cr4
  10d56b:	83 c8 20             	or     eax,0x20
  10d56e:	0f 22 e0             	mov    cr4,rax
  10d571:	b9 80 00 00 c0       	mov    ecx,0xc0000080
  10d576:	0f 32                	rdmsr  
  10d578:	0d 00 01 00 00       	or     eax,0x100
  10d57d:	0f 30                	wrmsr  
  10d57f:	0f 20 c0             	mov    rax,cr0
  10d582:	0d 00 00 00 80       	or     eax,0x80000000
  10d587:	0f 22 c0             	mov    cr0,rax
  10d58a:	c3                   	ret    

000000000010d58b <is_cpuid_supported>:
  10d58b:	9c                   	pushf  
  10d58c:	58                   	pop    rax
  10d58d:	89 c1                	mov    ecx,eax
  10d58f:	35 00 00 20 00       	xor    eax,0x200000
  10d594:	50                   	push   rax
  10d595:	9d                   	popf   
  10d596:	9c                   	pushf  
  10d597:	58                   	pop    rax
  10d598:	51                   	push   rcx
  10d599:	9d                   	popf   
  10d59a:	31 c8                	xor    eax,ecx
  10d59c:	74 01                	je     10d59f <is_cpuid_supported.no_cpuid>
  10d59e:	c3                   	ret    

000000000010d59f <is_cpuid_supported.no_cpuid>:
  10d59f:	b0 37                	mov    al,0x37
  10d5a1:	eb 22                	jmp    10d5c5 <error_handler>

000000000010d5a3 <is_longmode_supported>:
  10d5a3:	b8 00 00 00 80       	mov    eax,0x80000000
  10d5a8:	0f a2                	cpuid  
  10d5aa:	3d 01 00 00 80       	cmp    eax,0x80000001
  10d5af:	72 10                	jb     10d5c1 <is_longmode_supported.no_longmode>
  10d5b1:	b8 01 00 00 80       	mov    eax,0x80000001
  10d5b6:	0f a2                	cpuid  
  10d5b8:	f7 c2 00 00 00 20    	test   edx,0x20000000
  10d5be:	74 01                	je     10d5c1 <is_longmode_supported.no_longmode>
  10d5c0:	c3                   	ret    

000000000010d5c1 <is_longmode_supported.no_longmode>:
  10d5c1:	b0 32                	mov    al,0x32
  10d5c3:	eb 00                	jmp    10d5c5 <error_handler>

000000000010d5c5 <error_handler>:
  10d5c5:	c7 05 00 80 0b 00 45 	mov    DWORD PTR [rip+0xb8000],0x4f524f45        # 1c55cf <stack_top+0x9e5cd>
  10d5cc:	4f 52 4f 
  10d5cf:	c7 05 04 80 0b 00 52 	mov    DWORD PTR [rip+0xb8004],0x4f3a4f52        # 1c55dd <stack_top+0x9e5db>
  10d5d6:	4f 3a 4f 
  10d5d9:	c7 05 08 80 0b 00 20 	mov    DWORD PTR [rip+0xb8008],0x4f204f20        # 1c55eb <stack_top+0x9e5e9>
  10d5e0:	4f 20 4f 
  10d5e3:	a2                   	.byte 0xa2
  10d5e4:	0a                   	.byte 0xa
  10d5e5:	80 0b 00             	or     BYTE PTR [rbx],0x0
  10d5e8:	f4                   	hlt    
