
bin/kernel:     file format elf64-x86-64

Decoded dump of debug contents of section .debug_line:

CU: src/utility.h:
File name                            Line number    Starting address
utility.h                                     20            0x109000

utility.h                                     21            0x109015
utility.h                                     22            0x10901f
utility.h                                     21            0x109030
utility.h                                     21            0x109035
utility.h                                     24            0x10903f
utility.h                                     26            0x109042
utility.h                                     27            0x109056
utility.h                                     28            0x109060
utility.h                                     27            0x10907b
utility.h                                     27            0x109080
utility.h                                     30            0x10908a
utility.h                                     33            0x10908d
utility.h                                     34            0x109099
utility.h                                     35            0x1090a1
utility.h                                     36            0x1090a3
utility.h                                     35            0x1090a8
utility.h                                     37            0x1090ba
utility.h                                     38            0x1090be
utility.h                                     47            0x1090c0
utility.h                                     48            0x1090d8
utility.h                                     48            0x1090e2
utility.h                                     49            0x1090e9
utility.h                                     50            0x1090f3
utility.h                                     51            0x109113
utility.h                                     49            0x10911a
utility.h                                     49            0x10911f
utility.h                                     54            0x109129
utility.h                                     55            0x10912e
utility.h                                     58            0x109130
utility.h                                     59            0x109144
utility.h                                     60            0x10914e
utility.h                                     60            0x10916e
utility.h                                     59            0x109175
utility.h                                     59            0x10917a
utility.h                                     61            0x109184
utility.h                                     62            0x109189
utility.h                                     65            0x10918b
utility.h                                     66            0x109198
utility.h                                     66            0x10919e
utility.h                                     66            0x1091a4
utility.h                                     67            0x1091aa
utility.h                                     68            0x1091b0
utility.h                                     71            0x1091b7
utility.h                                     72            0x1091bc

src/kernel_synch.h:
kernel_synch.h                                 6            0x1091be
kernel_synch.h                                 7            0x1091ca
kernel_synch.h                                 7            0x1091cb
kernel_synch.h                                 8            0x1091e7
kernel_synch.h                                 9            0x1091ea
kernel_synch.h                                12            0x1091ed
kernel_synch.h                                13            0x1091f9
kernel_synch.h                                14            0x1091fc
kernel_synch.h                                15            0x109206

src/kernel.h:
kernel.h                                      29            0x109209
kernel.h                                      30            0x10921c
kernel.h                                      31            0x109225
kernel.h                                      40            0x109228
kernel.h                                      42            0x109236
kernel.h                                      43            0x109240
kernel.h                                      44            0x109244
kernel.h                                      55            0x109246
kernel.h                                      59            0x10924e
kernel.h                                      60            0x10925c
kernel.h                                      61            0x109260
kernel.h                                      62            0x109261

src/kernel_graphics.c:
kernel_graphics.c                             25            0x109264
kernel_graphics.c                             26            0x10927d
kernel_graphics.c                             27            0x109293
kernel_graphics.c                             28            0x1092a0
kernel_graphics.c                             29            0x1092ad
kernel_graphics.c                             30            0x1092c3
kernel_graphics.c                             31            0x1092d9
kernel_graphics.c                             32            0x109312
kernel_graphics.c                             33            0x109324
kernel_graphics.c                             34            0x109347
kernel_graphics.c                             28            0x10935d
kernel_graphics.c                             28            0x109362
kernel_graphics.c                             27            0x10936d
kernel_graphics.c                             27            0x109372
kernel_graphics.c                             38            0x10937d
kernel_graphics.c                             41            0x109380
kernel_graphics.c                             42            0x10938c
kernel_graphics.c                             43            0x1093b3

/usr/lib/gcc/x86_64-pc-linux-gnu/6.1.1/include/emmintrin.h:
emmintrin.h                                  755            0x1093bf

src/kernel_graphics.c:
kernel_graphics.c                             44            0x1093c3
kernel_graphics.c                             45            0x1093c7

/usr/lib/gcc/x86_64-pc-linux-gnu/6.1.1/include/emmintrin.h:
emmintrin.h                                  710            0x1093e2

src/kernel_graphics.c:
kernel_graphics.c                             47            0x1093ee
kernel_graphics.c                             45            0x1093fa
kernel_graphics.c                             45            0x1093ff
kernel_graphics.c                             49            0x109409
kernel_graphics.c                             79            0x10940c
kernel_graphics.c                             83            0x109423
kernel_graphics.c                             84            0x109440
kernel_graphics.c                             85            0x109454
kernel_graphics.c                             86            0x10946c
kernel_graphics.c                             89            0x10946f
kernel_graphics.c                             93            0x10947b
kernel_graphics.c                             95            0x1094ab
kernel_graphics.c                             96            0x1094d0
kernel_graphics.c                             97            0x1094dd
kernel_graphics.c                             98            0x1094e9
kernel_graphics.c                             99            0x109515
kernel_graphics.c                            100            0x109532
kernel_graphics.c                            101            0x109551
kernel_graphics.c                            102            0x10955b
kernel_graphics.c                            101            0x109586
kernel_graphics.c                            101            0x10958b
kernel_graphics.c                             96            0x109595
kernel_graphics.c                             96            0x10959a
kernel_graphics.c                            106            0x1095a8
kernel_graphics.c                            107            0x1095c8
kernel_graphics.c                            108            0x1095d2
kernel_graphics.c                            107            0x10960c
kernel_graphics.c                            107            0x109611
kernel_graphics.c                            110            0x10961b
kernel_graphics.c                            170            0x10961e
kernel_graphics.c                            171            0x10962a
kernel_graphics.c                            172            0x109640
kernel_graphics.c                            174            0x10964b
kernel_graphics.c                            178            0x10965b
kernel_graphics.c                            179            0x109663
kernel_graphics.c                            180            0x10966f
kernel_graphics.c                            181            0x109685
kernel_graphics.c                            182            0x1096a5
kernel_graphics.c                            183            0x1096c2
kernel_graphics.c                            184            0x1096cf
kernel_graphics.c                            185            0x1096da
kernel_graphics.c                            186            0x109706
kernel_graphics.c                            187            0x109723
kernel_graphics.c                            188            0x10973b
kernel_graphics.c                            189            0x109745
kernel_graphics.c                            188            0x109789
kernel_graphics.c                            188            0x10978e
kernel_graphics.c                            183            0x109798
kernel_graphics.c                            183            0x10979d
kernel_graphics.c                            193            0x1097aa
kernel_graphics.c                            194            0x1097c3
kernel_graphics.c                            195            0x1097cd
kernel_graphics.c                            194            0x10981e
kernel_graphics.c                            194            0x109823
kernel_graphics.c                            199            0x10982f
kernel_graphics.c                            171            0x10983d
kernel_graphics.c                            201            0x10983e

src/kernel_acpi.c:
kernel_acpi.c                                 41            0x109840
kernel_acpi.c                                 42            0x109859
kernel_acpi.c                                 45            0x109863
kernel_acpi.c                                 42            0x109867
kernel_acpi.c                                 43            0x109876
kernel_acpi.c                                 42            0x109881
kernel_acpi.c                                 43            0x109885
kernel_acpi.c                                 44            0x109894
kernel_acpi.c                                 43            0x10989f
kernel_acpi.c                                 44            0x1098a3
kernel_acpi.c                                 45            0x1098b2
kernel_acpi.c                                 44            0x1098bd
kernel_acpi.c                                 45            0x1098c1
kernel_acpi.c                                 45            0x1098d0
kernel_acpi.c                                 45            0x1098d7
kernel_acpi.c                                 42            0x1098dc
kernel_acpi.c                                 46            0x1098e0
kernel_acpi.c                                 47            0x1098f4
kernel_acpi.c                                 51            0x1098f9
kernel_acpi.c                                 52            0x109901
kernel_acpi.c                                 53            0x109920
kernel_acpi.c                                 54            0x10992f
kernel_acpi.c                                 55            0x109943
kernel_acpi.c                                 56            0x10994f
kernel_acpi.c                                 57            0x10995c
kernel_acpi.c                                 58            0x109977
kernel_acpi.c                                 59            0x10998e
kernel_acpi.c                                 60            0x1099a4
kernel_acpi.c                                 65            0x1099ac
kernel_acpi.c                                 71            0x1099c0
kernel_acpi.c                                 78            0x1099c8
kernel_acpi.c                                 80            0x1099db
kernel_acpi.c                                 81            0x1099e7
kernel_acpi.c                                104            0x1099ec
kernel_acpi.c                                106            0x109a10
kernel_acpi.c                                107            0x109a18
kernel_acpi.c                                110            0x109a2a
kernel_acpi.c                                111            0x109a3c
kernel_acpi.c                                112            0x109a65
kernel_acpi.c                                116            0x109a82
kernel_acpi.c                                114            0x109a84
kernel_acpi.c                                116            0x109a98
kernel_acpi.c                                128            0x109a9a
kernel_acpi.c                                132            0x109aa2
kernel_acpi.c                                133            0x109ab2
kernel_acpi.c                                139            0x109ac6
kernel_acpi.c                                135            0x109ac8
kernel_acpi.c                                139            0x109adc
kernel_acpi.c                                141            0x109ade
kernel_acpi.c                                144            0x109adf
kernel_acpi.c                                 81            0x109af5
kernel_acpi.c                                148            0x109b14
kernel_acpi.c                                149            0x109b24
kernel_acpi.c                                 56            0x109b38
kernel_acpi.c                                 56            0x109b3d
kernel_acpi.c                                154            0x109b4a

src/kernel_apic.c:
kernel_apic.c                                 37            0x109b4c
kernel_apic.c                                 38            0x109b60
kernel_apic.c                                 39            0x109b68
kernel_apic.c                                 40            0x109b72
kernel_apic.c                                 41            0x109b7f
kernel_apic.c                                 44            0x109b82
kernel_apic.c                                 45            0x109b93
kernel_apic.c                                 46            0x109b9b
kernel_apic.c                                 47            0x109ba5
kernel_apic.c                                 48            0x109baf
kernel_apic.c                                 51            0x109bb1
kernel_apic.c                                 52            0x109bc4
kernel_apic.c                                 53            0x109bd3
kernel_apic.c                                 54            0x109bdc
kernel_apic.c                                 57            0x109bdf
kernel_apic.c                                 58            0x109beb
kernel_apic.c                                 61            0x109bec
kernel_apic.c                                 62            0x109bf3
kernel_apic.c                                 63            0x109bfa
kernel_apic.c                                 64            0x109bfe
kernel_apic.c                                 65            0x109c12
kernel_apic.c                                 66            0x109c26
kernel_apic.c                                 67            0x109c27
kernel_apic.c                                 70            0x109c2a
kernel_apic.c                                 71            0x109c36
kernel_apic.c                                 80            0x109c37
kernel_apic.c                                 81            0x109c4d
kernel_apic.c                                 88            0x109c63
kernel_apic.c                                 89            0x109c7e
kernel_apic.c                                 90            0x109c7f
kernel_apic.c                                 94            0x109c82
kernel_apic.c                                109            0x109c8e
kernel_apic.c                                110            0x109caa
kernel_apic.c                                111            0x109cc7
kernel_apic.c                                112            0x109ce9
kernel_apic.c                                113            0x109cec
kernel_apic.c                                117            0x109cef
kernel_apic.c                                155            0x109d05
kernel_apic.c                                156            0x109d0c
kernel_apic.c                                157            0x109d27
kernel_apic.c                                158            0x109d2e
kernel_apic.c                                163            0x109d35
kernel_apic.c                                164            0x109d3e
kernel_apic.c                                165            0x109d47
kernel_apic.c                                166            0x109d60
kernel_apic.c                                168            0x109d79
kernel_apic.c                                169            0x109d95
kernel_apic.c                                170            0x109db1
kernel_apic.c                                171            0x109db3
kernel_apic.c                                170            0x109dc7
kernel_apic.c                                174            0x109dd2
kernel_apic.c                                174            0x109ddc
kernel_apic.c                                174            0x109de2
kernel_apic.c                                177            0x109dec
kernel_apic.c                                178            0x109df3
kernel_apic.c                                179            0x109e0e
kernel_apic.c                                180            0x109e2a
kernel_apic.c                                181            0x109e46
kernel_apic.c                                181            0x109e50
kernel_apic.c                                181            0x109e56
kernel_apic.c                                182            0x109e60
kernel_apic.c                                183            0x109e7c
kernel_apic.c                                184            0x109e98

src/kernel_descriptor.c:
kernel_descriptor.c                           60            0x109e9b
kernel_descriptor.c                           61            0x109eb6
kernel_descriptor.c                           61            0x109ebf
kernel_descriptor.c                           62            0x109eef
kernel_descriptor.c                           62            0x109ef5
kernel_descriptor.c                           63            0x109f25
kernel_descriptor.c                           63            0x109f2b
kernel_descriptor.c                           82            0x109f5b

kernel_descriptor.c                           83            0x109f6f
kernel_descriptor.c                           84            0x109f77
kernel_descriptor.c                           85            0x109f82
kernel_descriptor.c                           86            0x109f91
kernel_descriptor.c                           88            0x109f9c
kernel_descriptor.c                           89            0x109fa3
kernel_descriptor.c                           91            0x109fbd
kernel_descriptor.c                           92            0x109fc7
kernel_descriptor.c                           93            0x109fd1
kernel_descriptor.c                           94            0x109fe9
kernel_descriptor.c                           95            0x10a004
kernel_descriptor.c                           97            0x10a01c
kernel_descriptor.c                           98            0x10a037
kernel_descriptor.c                           99            0x10a050
kernel_descriptor.c                          102            0x10a053
kernel_descriptor.c                          111            0x10a068
kernel_descriptor.c                          112            0x10a070
kernel_descriptor.c                          113            0x10a07d
kernel_descriptor.c                          114            0x10a08f
kernel_descriptor.c                          115            0x10a0a0
kernel_descriptor.c                          115            0x10a0b8
kernel_descriptor.c                          115            0x10a0c1
kernel_descriptor.c                          115            0x10a0c8
kernel_descriptor.c                          116            0x10a0d1
kernel_descriptor.c                          117            0x10a0db
kernel_descriptor.c                          118            0x10a0e3
kernel_descriptor.c                          126            0x10a0e6
kernel_descriptor.c                          127            0x10a0f4
kernel_descriptor.c                          143            0x10a0f5
kernel_descriptor.c                          144            0x10a0fd
kernel_descriptor.c                          146            0x10a117
kernel_descriptor.c                          147            0x10a11e
kernel_descriptor.c                          148            0x10a11f

src/kernel_exceptions.c:
kernel_exceptions.c                           41            0x10a122
kernel_exceptions.c                           70            0x10a12a
kernel_exceptions.c                           71            0x10a131
kernel_exceptions.c                           72            0x10a13c
kernel_exceptions.c                           73            0x10a150
kernel_exceptions.c                           73            0x10a15b
kernel_exceptions.c                           73            0x10a162
kernel_exceptions.c                           73            0x10a167
kernel_exceptions.c                           74            0x10a17e
kernel_exceptions.c                           75            0x10a1ab
kernel_exceptions.c                           76            0x10a1cc
kernel_exceptions.c                           83            0x10a1d8
kernel_exceptions.c                           81            0x10a1da
kernel_exceptions.c                           83            0x10a1e6
kernel_exceptions.c                           86            0x10a1e9
kernel_exceptions.c                           94            0x10a1f1
kernel_exceptions.c                           95            0x10a1f8
kernel_exceptions.c                           96            0x10a20a
kernel_exceptions.c                           97            0x10a21c
kernel_exceptions.c                           98            0x10a22e
kernel_exceptions.c                           99            0x10a240
kernel_exceptions.c                          101            0x10a252
kernel_exceptions.c                          101            0x10a259
kernel_exceptions.c                          101            0x10a260
kernel_exceptions.c                          101            0x10a265
kernel_exceptions.c                          101            0x10a26c
kernel_exceptions.c                          101            0x10a273
kernel_exceptions.c                          101            0x10a278
kernel_exceptions.c                          101            0x10a27f
kernel_exceptions.c                          101            0x10a286
kernel_exceptions.c                          101            0x10a28b
kernel_exceptions.c                          101            0x10a292
kernel_exceptions.c                          101            0x10a299
kernel_exceptions.c                          101            0x10a29e
kernel_exceptions.c                          101            0x10a2a5
kernel_exceptions.c                          101            0x10a2ac
kernel_exceptions.c                          101            0x10a2b1
kernel_exceptions.c                          108            0x10a2d9
kernel_exceptions.c                          110            0x10a2e5
kernel_exceptions.c                          116            0x10a2ec
kernel_exceptions.c                          117            0x10a2f6
kernel_exceptions.c                          123            0x10a302
kernel_exceptions.c                          120            0x10a304
kernel_exceptions.c                          121            0x10a318
kernel_exceptions.c                          123            0x10a324

src/kernel_entry.c:
kernel_entry.c                                48            0x10a327
kernel_entry.c                                63            0x10a32b
kernel_entry.c                                64            0x10a348
kernel_entry.c                                66            0x10a365
kernel_entry.c                                67            0x10a382
kernel_entry.c                                69            0x10a39f
kernel_entry.c                                70            0x10a3bc
kernel_entry.c                                73            0x10a3d9
kernel_entry.c                                74            0x10a3f6
kernel_entry.c                                77            0x10a413
kernel_entry.c                                78            0x10a429
kernel_entry.c                                79            0x10a43f
kernel_entry.c                                80            0x10a455
kernel_entry.c                                81            0x10a46b
kernel_entry.c                                82            0x10a47f
kernel_entry.c                               109            0x10a482
kernel_entry.c                               118            0x10a491
kernel_entry.c                               119            0x10a4a7
kernel_entry.c                               120            0x10a4c1
kernel_entry.c                               121            0x10a4da
kernel_entry.c                               122            0x10a504
kernel_entry.c                               123            0x10a516
kernel_entry.c                               124            0x10a526
kernel_entry.c                               127            0x10a529
kernel_entry.c                               131            0x10a531
kernel_entry.c                               132            0x10a53a
kernel_entry.c                               133            0x10a54c
kernel_entry.c                               131            0x10a55b
kernel_entry.c                               131            0x10a55f
kernel_entry.c                               169            0x10a568
kernel_entry.c                               170            0x10a57a
kernel_entry.c                               171            0x10a58c
kernel_entry.c                               172            0x10a59e
kernel_entry.c                               173            0x10a5b0
kernel_entry.c                               174            0x10a5c2
kernel_entry.c                               175            0x10a5d4
kernel_entry.c                               176            0x10a5e6
kernel_entry.c                               177            0x10a5f8
kernel_entry.c                               178            0x10a60a
kernel_entry.c                               179            0x10a61c
kernel_entry.c                               180            0x10a62e
kernel_entry.c                               181            0x10a640
kernel_entry.c                               182            0x10a652
kernel_entry.c                               183            0x10a664
kernel_entry.c                               184            0x10a676
kernel_entry.c                               185            0x10a688
kernel_entry.c                               186            0x10a69a
kernel_entry.c                               187            0x10a6ac
kernel_entry.c                               188            0x10a6be
kernel_entry.c                               189            0x10a6d0
kernel_entry.c                               190            0x10a6e2
kernel_entry.c                               191            0x10a6f4
kernel_entry.c                               192            0x10a706
kernel_entry.c                               193            0x10a718
kernel_entry.c                               194            0x10a72a
kernel_entry.c                               195            0x10a73c
kernel_entry.c                               196            0x10a74e
kernel_entry.c                               197            0x10a760
kernel_entry.c                               198            0x10a772
kernel_entry.c                               199            0x10a784
kernel_entry.c                               200            0x10a796
kernel_entry.c                               213            0x10a7a8
kernel_entry.c                               214            0x10a7b4
kernel_entry.c                               215            0x10a7c0
kernel_entry.c                               216            0x10a7d5
kernel_entry.c                               217            0x10a7ea
kernel_entry.c                               224            0x10a804
kernel_entry.c                               225            0x10a813
kernel_entry.c                               226            0x10a817
kernel_entry.c                               227            0x10a818
kernel_entry.c                               228            0x10a82c

src/hardware_serial.c:
hardware_serial.c                             18            0x10a82f
hardware_serial.c                             19            0x10a833
hardware_serial.c                             20            0x10a842
hardware_serial.c                             21            0x10a851
hardware_serial.c                             22            0x10a860
hardware_serial.c                             23            0x10a86f
hardware_serial.c                             24            0x10a87e
hardware_serial.c                             25            0x10a88d
hardware_serial.c                             26            0x10a89c
hardware_serial.c                             28            0x10a89f
hardware_serial.c                             29            0x10a8a3
hardware_serial.c                             30            0x10a8b3
hardware_serial.c                             39            0x10a8b5
hardware_serial.c                             40            0x10a8c5
hardware_serial.c                             41            0x10a8cf
hardware_serial.c                             41            0x10a8d0
hardware_serial.c                             42            0x10a8de
hardware_serial.c                             40            0x10a8fb
hardware_serial.c                             40            0x10a900
hardware_serial.c                             44            0x10a90a

src/kernel_memory.c:
kernel_memory.c                               37            0x10a90d
kernel_memory.c                               38            0x10a921
kernel_memory.c                               38            0x10a92f
kernel_memory.c                               39            0x10a95f
kernel_memory.c                               39            0x10a96d
kernel_memory.c                               40            0x10a99d
kernel_memory.c                               41            0x10a9ae
kernel_memory.c                               42            0x10a9bf
kernel_memory.c                               43            0x10a9d0
kernel_memory.c                               44            0x10a9d8
kernel_memory.c                               45            0x10a9e8
kernel_memory.c                               46            0x10a9f8
kernel_memory.c                               47            0x10aa24
kernel_memory.c                               49            0x10aa27
kernel_memory.c                               50            0x10aa37
kernel_memory.c                               50            0x10aa45
kernel_memory.c                               51            0x10aa75
kernel_memory.c                               51            0x10aa83
kernel_memory.c                               52            0x10aab3
kernel_memory.c                               53            0x10aac4
kernel_memory.c                               54            0x10aad5
kernel_memory.c                               55            0x10aae6
kernel_memory.c                               55            0x10aaed
kernel_memory.c                               55            0x10aaf4
kernel_memory.c                               56            0x10ab24
kernel_memory.c                               56            0x10ab35
kernel_memory.c                               57            0x10ab65
kernel_memory.c                               58            0x10ab8a
kernel_memory.c                               60            0x10ab8d
kernel_memory.c                               61            0x10ab9d
kernel_memory.c                               62            0x10aba5
kernel_memory.c                               63            0x10abb2
kernel_memory.c                               64            0x10abba
kernel_memory.c                               65            0x10abcd
kernel_memory.c                               66            0x10abd1
kernel_memory.c                               68            0x10abd3
kernel_memory.c                               69            0x10abd7
kernel_memory.c                               70            0x10abf3
kernel_memory.c                               71            0x10abfd

src/kernel_entry.c:
kernel_entry.c                               235            0x10ac00
kernel_entry.c                               236            0x10ac04
kernel_entry.c                               237            0x10ac05

src/elf64.h:
elf64.h                                      304            0x10ac08
elf64.h                                      305            0x10ac13
elf64.h                                      305            0x10ac19
elf64.h                                      305            0x10ac23
elf64.h                                      305            0x10ac29
elf64.h                                      305            0x10ac33
elf64.h                                      305            0x10ac39
elf64.h                                      305            0x10ac43
elf64.h                                      305            0x10ac49
elf64.h                                      305            0x10ac53
elf64.h                                      305            0x10ac59
elf64.h                                      305            0x10ac63
elf64.h                                      305            0x10ac69
elf64.h                                      305            0x10ac73
elf64.h                                      305            0x10ac79
elf64.h                                      305            0x10ac83
elf64.h                                      305            0x10ac89
elf64.h                                      305            0x10ac93
elf64.h                                      305            0x10ac99
elf64.h                                      305            0x10aca3
elf64.h                                      305            0x10aca9
elf64.h                                      305            0x10acb3
elf64.h                                      305            0x10acb9
elf64.h                                      305            0x10acc3
elf64.h                                      305            0x10acc9
elf64.h                                      305            0x10acd3
elf64.h                                      305            0x10acd9
elf64.h                                      305            0x10ace3
elf64.h                                      305            0x10ace9
elf64.h                                      305            0x10acf3
elf64.h                                      305            0x10acf9
elf64.h                                      305            0x10ad03
elf64.h                                      305            0x10ad09
elf64.h                                      305            0x10ad13
elf64.h                                      305            0x10ad19
elf64.h                                      305            0x10ad23
elf64.h                                      305            0x10ad29
elf64.h                                      305            0x10ad33
elf64.h                                      305            0x10ad39
elf64.h                                      305            0x10ad43
elf64.h                                      305            0x10ad49
elf64.h                                      305            0x10ad53
elf64.h                                      305            0x10ad59
elf64.h                                      305            0x10ad63
elf64.h                                      305            0x10ad69
elf64.h                                      305            0x10ad73
elf64.h                                      305            0x10ad79
elf64.h                                      305            0x10ad83
elf64.h                                      305            0x10ad89
elf64.h                                      305            0x10ad93
elf64.h                                      305            0x10ad99
elf64.h                                      305            0x10ada3
elf64.h                                      305            0x10ada9
elf64.h                                      305            0x10adb3
elf64.h                                      305            0x10adb9
elf64.h                                      305            0x10adc3
elf64.h                                      305            0x10adc9
elf64.h                                      305            0x10add3
elf64.h                                      305            0x10add9
elf64.h                                      305            0x10ade3
elf64.h                                      305            0x10ade9
elf64.h                                      305            0x10adf3
elf64.h                                      305            0x10adf9
elf64.h                                      305            0x10ae03
elf64.h                                      305            0x10ae09
elf64.h                                      305            0x10ae13
elf64.h                                      305            0x10ae19
elf64.h                                      305            0x10ae23
elf64.h                                      305            0x10ae29
elf64.h                                      305            0x10ae33
elf64.h                                      305            0x10ae39
elf64.h                                      305            0x10ae43
elf64.h                                      305            0x10ae49
elf64.h                                      305            0x10ae53
elf64.h                                      305            0x10ae59
elf64.h                                      305            0x10ae63
elf64.h                                      305            0x10ae69
elf64.h                                      305            0x10ae73
elf64.h                                      305            0x10ae79
elf64.h                                      305            0x10ae83
elf64.h                                      305            0x10ae89
elf64.h                                      305            0x10ae93
elf64.h                                      305            0x10ae99
elf64.h                                      305            0x10aea3
elf64.h                                      305            0x10aea9
elf64.h                                      305            0x10aeb3
elf64.h                                      305            0x10aeb9
elf64.h                                      305            0x10aec3
elf64.h                                      305            0x10aec9
elf64.h                                      305            0x10aed3
elf64.h                                      305            0x10aed9
elf64.h                                      305            0x10aee3
elf64.h                                      305            0x10aee9
elf64.h                                      305            0x10aef3
elf64.h                                      305            0x10aef9
elf64.h                                      305            0x10af03
elf64.h                                      305            0x10af09
elf64.h                                      305            0x10af13
elf64.h                                      305            0x10af19
elf64.h                                      305            0x10af23
elf64.h                                      305            0x10af29
elf64.h                                      305            0x10af33
elf64.h                                      305            0x10af39
elf64.h                                      305            0x10af43
elf64.h                                      305            0x10af49
elf64.h                                      305            0x10af53
elf64.h                                      305            0x10af59
elf64.h                                      305            0x10af63
elf64.h                                      305            0x10af69
elf64.h                                      305            0x10af70
elf64.h                                      305            0x10af76
elf64.h                                      305            0x10af7d
elf64.h                                      305            0x10af83
elf64.h                                      305            0x10af8a
elf64.h                                      305            0x10af90
elf64.h                                      305            0x10af97
elf64.h                                      305            0x10af9d
elf64.h                                      305            0x10afa4
elf64.h                                      305            0x10afaa
elf64.h                                      305            0x10afb1
elf64.h                                      305            0x10afb7
elf64.h                                      305            0x10afbe
elf64.h                                      305            0x10afc7
elf64.h                                      305            0x10afce
elf64.h                                      305            0x10afd7
elf64.h                                      306            0x10afde
elf64.h                                      307            0x10afe3
elf64.h                                      309            0x10afe5
elf64.h                                      310            0x10aff0
elf64.h                                      310            0x10aff6
elf64.h                                      310            0x10b000
elf64.h                                      310            0x10b006
elf64.h                                      310            0x10b010
elf64.h                                      310            0x10b016
elf64.h                                      310            0x10b020
elf64.h                                      310            0x10b026
elf64.h                                      310            0x10b030
elf64.h                                      310            0x10b036
elf64.h                                      310            0x10b040
elf64.h                                      310            0x10b046
elf64.h                                      310            0x10b050
elf64.h                                      310            0x10b056
elf64.h                                      310            0x10b060
elf64.h                                      310            0x10b066
elf64.h                                      310            0x10b070
elf64.h                                      310            0x10b076
elf64.h                                      310            0x10b080
elf64.h                                      310            0x10b086
elf64.h                                      310            0x10b090
elf64.h                                      310            0x10b096
elf64.h                                      310            0x10b0a0
elf64.h                                      310            0x10b0a6
elf64.h                                      310            0x10b0b0
elf64.h                                      310            0x10b0b6
elf64.h                                      310            0x10b0c0
elf64.h                                      310            0x10b0c6
elf64.h                                      310            0x10b0d0
elf64.h                                      310            0x10b0d6
elf64.h                                      310            0x10b0e0
elf64.h                                      310            0x10b0e6
elf64.h                                      310            0x10b0f0
elf64.h                                      310            0x10b0f6
elf64.h                                      310            0x10b100
elf64.h                                      310            0x10b106
elf64.h                                      310            0x10b110
elf64.h                                      310            0x10b116
elf64.h                                      310            0x10b120
elf64.h                                      310            0x10b126
elf64.h                                      310            0x10b130
elf64.h                                      310            0x10b136
elf64.h                                      310            0x10b140
elf64.h                                      310            0x10b146
elf64.h                                      310            0x10b150
elf64.h                                      310            0x10b156
elf64.h                                      310            0x10b160
elf64.h                                      310            0x10b166
elf64.h                                      310            0x10b170
elf64.h                                      310            0x10b176
elf64.h                                      310            0x10b180
elf64.h                                      310            0x10b186
elf64.h                                      310            0x10b190
elf64.h                                      310            0x10b196
elf64.h                                      310            0x10b1a0
elf64.h                                      310            0x10b1a6
elf64.h                                      310            0x10b1b0
elf64.h                                      310            0x10b1b6
elf64.h                                      310            0x10b1c0
elf64.h                                      310            0x10b1c6
elf64.h                                      310            0x10b1d0
elf64.h                                      310            0x10b1d6
elf64.h                                      310            0x10b1e0
elf64.h                                      310            0x10b1e6
elf64.h                                      310            0x10b1f0
elf64.h                                      310            0x10b1f6
elf64.h                                      310            0x10b200
elf64.h                                      310            0x10b206
elf64.h                                      310            0x10b210
elf64.h                                      310            0x10b216
elf64.h                                      310            0x10b220
elf64.h                                      310            0x10b226
elf64.h                                      310            0x10b230
elf64.h                                      310            0x10b236
elf64.h                                      310            0x10b240
elf64.h                                      310            0x10b246
elf64.h                                      310            0x10b250
elf64.h                                      310            0x10b256
elf64.h                                      310            0x10b260
elf64.h                                      310            0x10b266
elf64.h                                      310            0x10b270
elf64.h                                      310            0x10b276
elf64.h                                      310            0x10b280
elf64.h                                      310            0x10b286
elf64.h                                      310            0x10b290
elf64.h                                      310            0x10b296
elf64.h                                      310            0x10b2a0
elf64.h                                      310            0x10b2a6
elf64.h                                      310            0x10b2b0
elf64.h                                      310            0x10b2b6
elf64.h                                      310            0x10b2c0
elf64.h                                      310            0x10b2c6
elf64.h                                      310            0x10b2d0
elf64.h                                      310            0x10b2d6
elf64.h                                      310            0x10b2e0
elf64.h                                      310            0x10b2e6
elf64.h                                      310            0x10b2f0
elf64.h                                      310            0x10b2f6
elf64.h                                      310            0x10b300
elf64.h                                      310            0x10b306
elf64.h                                      310            0x10b310
elf64.h                                      310            0x10b316
elf64.h                                      310            0x10b320
elf64.h                                      310            0x10b326
elf64.h                                      310            0x10b330
elf64.h                                      310            0x10b336
elf64.h                                      310            0x10b340
elf64.h                                      310            0x10b346
elf64.h                                      310            0x10b350
elf64.h                                      310            0x10b356
elf64.h                                      310            0x10b360
elf64.h                                      310            0x10b366
elf64.h                                      310            0x10b370
elf64.h                                      310            0x10b376
elf64.h                                      310            0x10b380
elf64.h                                      310            0x10b386
elf64.h                                      310            0x10b390
elf64.h                                      310            0x10b396
elf64.h                                      310            0x10b3a0
elf64.h                                      310            0x10b3a6
elf64.h                                      310            0x10b3b0
elf64.h                                      310            0x10b3b6
elf64.h                                      310            0x10b3c0
elf64.h                                      310            0x10b3c6
elf64.h                                      310            0x10b3d0
elf64.h                                      310            0x10b3d6
elf64.h                                      310            0x10b3e0
elf64.h                                      310            0x10b3e6
elf64.h                                      310            0x10b3f0
elf64.h                                      310            0x10b3f6
elf64.h                                      310            0x10b400
elf64.h                                      310            0x10b406
elf64.h                                      310            0x10b410
elf64.h                                      310            0x10b416
elf64.h                                      310            0x10b420
elf64.h                                      310            0x10b426
elf64.h                                      310            0x10b430
elf64.h                                      310            0x10b436
elf64.h                                      310            0x10b440
elf64.h                                      310            0x10b446
elf64.h                                      310            0x10b450
elf64.h                                      310            0x10b456
elf64.h                                      310            0x10b460
elf64.h                                      310            0x10b466
elf64.h                                      310            0x10b470
elf64.h                                      310            0x10b476
elf64.h                                      310            0x10b480
elf64.h                                      310            0x10b486
elf64.h                                      310            0x10b490
elf64.h                                      310            0x10b496
elf64.h                                      310            0x10b4a0
elf64.h                                      310            0x10b4a6
elf64.h                                      310            0x10b4b0
elf64.h                                      310            0x10b4b6
elf64.h                                      310            0x10b4c0
elf64.h                                      310            0x10b4c6
elf64.h                                      310            0x10b4d0
elf64.h                                      310            0x10b4d6
elf64.h                                      310            0x10b4e0
elf64.h                                      310            0x10b4e6
elf64.h                                      310            0x10b4f0
elf64.h                                      310            0x10b4f6
elf64.h                                      310            0x10b500
elf64.h                                      310            0x10b506
elf64.h                                      310            0x10b510
elf64.h                                      310            0x10b516
elf64.h                                      310            0x10b520
elf64.h                                      310            0x10b526
elf64.h                                      310            0x10b530
elf64.h                                      310            0x10b536
elf64.h                                      310            0x10b540
elf64.h                                      310            0x10b546
elf64.h                                      310            0x10b54d
elf64.h                                      310            0x10b553
elf64.h                                      310            0x10b55a
elf64.h                                      310            0x10b560
elf64.h                                      310            0x10b567
elf64.h                                      310            0x10b56d
elf64.h                                      310            0x10b574
elf64.h                                      310            0x10b57a
elf64.h                                      310            0x10b581
elf64.h                                      310            0x10b587
elf64.h                                      310            0x10b58e
elf64.h                                      310            0x10b594
elf64.h                                      310            0x10b59b
elf64.h                                      310            0x10b5a4
elf64.h                                      310            0x10b5ab
elf64.h                                      310            0x10b5b4
elf64.h                                      311            0x10b5bb
elf64.h                                      312            0x10b5c0
elf64.h                                      314            0x10b5c2
elf64.h                                      315            0x10b5cd
elf64.h                                      315            0x10b5d3
elf64.h                                      315            0x10b5dd
elf64.h                                      315            0x10b5e3
elf64.h                                      315            0x10b5ed
elf64.h                                      315            0x10b5f3
elf64.h                                      315            0x10b5fd
elf64.h                                      315            0x10b603
elf64.h                                      315            0x10b60d
elf64.h                                      315            0x10b613
elf64.h                                      315            0x10b61d
elf64.h                                      315            0x10b623
elf64.h                                      315            0x10b62d
elf64.h                                      315            0x10b633
elf64.h                                      315            0x10b63d
elf64.h                                      315            0x10b643
elf64.h                                      315            0x10b64d
elf64.h                                      315            0x10b653
elf64.h                                      315            0x10b65d
elf64.h                                      315            0x10b663
elf64.h                                      315            0x10b66d
elf64.h                                      315            0x10b673
elf64.h                                      315            0x10b67d
elf64.h                                      315            0x10b683
elf64.h                                      315            0x10b68d
elf64.h                                      315            0x10b693
elf64.h                                      315            0x10b69d
elf64.h                                      315            0x10b6a3
elf64.h                                      315            0x10b6ad
elf64.h                                      315            0x10b6b3
elf64.h                                      315            0x10b6bd
elf64.h                                      315            0x10b6c3
elf64.h                                      315            0x10b6ca
elf64.h                                      315            0x10b6d0
elf64.h                                      315            0x10b6d7
elf64.h                                      315            0x10b6dd
elf64.h                                      315            0x10b6e4
elf64.h                                      315            0x10b6ea
elf64.h                                      315            0x10b6f1
elf64.h                                      315            0x10b6f7
elf64.h                                      315            0x10b6fe
elf64.h                                      315            0x10b704
elf64.h                                      315            0x10b70b
elf64.h                                      315            0x10b711
elf64.h                                      315            0x10b718
elf64.h                                      315            0x10b71e
elf64.h                                      315            0x10b725
elf64.h                                      315            0x10b72b
elf64.h                                      315            0x10b732
elf64.h                                      315            0x10b738
elf64.h                                      316            0x10b73f
elf64.h                                      317            0x10b744

src/kernel_process.c:
kernel_process.c                              17            0x10b746
kernel_process.c                              18            0x10b752
kernel_process.c                              19            0x10b75a
kernel_process.c                              20            0x10b767
kernel_process.c                              21            0x10b77b
kernel_process.c                              24            0x10b785
kernel_process.c                              25            0x10b7a4
kernel_process.c                              26            0x10b7b1
kernel_process.c                              27            0x10b7d7
kernel_process.c                              28            0x10b7eb
kernel_process.c                              29            0x10b80a
kernel_process.c                              30            0x10b829
kernel_process.c                              31            0x10b848
kernel_process.c                              25            0x10b867
kernel_process.c                              25            0x10b86c
kernel_process.c                              34            0x10b881
kernel_process.c                              35            0x10b889

src/kernel_debug.c:
kernel_debug.c                                22            0x10b88b
kernel_debug.c                                23            0x10b897
kernel_debug.c                                24            0x10b8a4
kernel_debug.c                                26            0x10b8ab
kernel_debug.c                                28            0x10b8c9
kernel_debug.c                                29            0x10b8e3
kernel_debug.c                                30            0x10b900
kernel_debug.c                                23            0x10b920
kernel_debug.c                                23            0x10b925
kernel_debug.c                                32            0x10b930
kernel_debug.c                                36            0x10b933
kernel_debug.c                                37            0x10b93f
kernel_debug.c                                38            0x10b94d
kernel_debug.c                                39            0x10b95f
kernel_debug.c                                40            0x10b971
kernel_debug.c                                41            0x10b983
kernel_debug.c                                42            0x10b995
kernel_debug.c                                43            0x10b9a7
kernel_debug.c                                44            0x10b9b9
kernel_debug.c                                45            0x10b9d4
kernel_debug.c                                45            0x10b9da
kernel_debug.c                                45            0x10b9e1
kernel_debug.c                                45            0x10b9e6
kernel_debug.c                                46            0x10b9fd
kernel_debug.c                                46            0x10ba03
kernel_debug.c                                46            0x10ba0a
kernel_debug.c                                46            0x10ba0f
kernel_debug.c                                47            0x10ba26
kernel_debug.c                                47            0x10ba2c
kernel_debug.c                                47            0x10ba33
kernel_debug.c                                47            0x10ba38
kernel_debug.c                                48            0x10ba4f
kernel_debug.c                                48            0x10ba55
kernel_debug.c                                48            0x10ba5c
kernel_debug.c                                48            0x10ba61
kernel_debug.c                                49            0x10ba78
kernel_debug.c                                49            0x10ba7e
kernel_debug.c                                49            0x10ba85
kernel_debug.c                                49            0x10ba8a
kernel_debug.c                                50            0x10baa1
kernel_debug.c                                50            0x10baa7
kernel_debug.c                                50            0x10baae
kernel_debug.c                                50            0x10bab3
kernel_debug.c                                51            0x10baca
kernel_debug.c                                54            0x10bacd
kernel_debug.c                                55            0x10bad9
kernel_debug.c                                56            0x10baea
kernel_debug.c                                57            0x10bafb
kernel_debug.c                                58            0x10bb0c
kernel_debug.c                                60            0x10bb19
kernel_debug.c                                61            0x10bb2d
kernel_debug.c                                62            0x10bb48
kernel_debug.c                                63            0x10bb63
kernel_debug.c                                64            0x10bb7e
kernel_debug.c                                65            0x10bb99
kernel_debug.c                                67            0x10bbb4
kernel_debug.c                                68            0x10bbc8
kernel_debug.c                                69            0x10bbdc
kernel_debug.c                                70            0x10bbf0
kernel_debug.c                                71            0x10bc04
kernel_debug.c                                72            0x10bc18
kernel_debug.c                                73            0x10bc2c
kernel_debug.c                                76            0x10bc2f
kernel_debug.c                                77            0x10bc37
kernel_debug.c                                78            0x10bc41
kernel_debug.c                                79            0x10bc59
kernel_debug.c                                80            0x10bc6f
kernel_debug.c                                81            0x10bc7b
kernel_debug.c                                77            0x10bc9d
kernel_debug.c                                77            0x10bca2
kernel_debug.c                                83            0x10bcb0

src/kernel_entry.c:
kernel_entry.c                               246            0x10bcb3
kernel_entry.c                               247            0x10bcc3
kernel_entry.c                               248            0x10bccd
kernel_entry.c                               249            0x10bcd2
kernel_entry.c                               250            0x10bcdc
kernel_entry.c                               253            0x10bce6
kernel_entry.c                               256            0x10bcf1
kernel_entry.c                               257            0x10bcfb
kernel_entry.c                               258            0x10bd0f
kernel_entry.c                               261            0x10bd1b
kernel_entry.c                               262            0x10bd27
kernel_entry.c                               263            0x10bd3b
kernel_entry.c                               266            0x10bd47
kernel_entry.c                               267            0x10bd4f
kernel_entry.c                               268            0x10bd57
kernel_entry.c                               269            0x10bd63
kernel_entry.c                               270            0x10bd65
kernel_entry.c                               272            0x10bd7c
kernel_entry.c                               273            0x10bd84
kernel_entry.c                               274            0x10bd90
kernel_entry.c                               276            0x10bd92
kernel_entry.c                               277            0x10bd9a
kernel_entry.c                               278            0x10bda6
kernel_entry.c                               281            0x10bda8
kernel_entry.c                               282            0x10bdb0
kernel_entry.c                               305            0x10bdb1
kernel_entry.c                               269            0x10bdc4
kernel_entry.c                               309            0x10bdce
kernel_entry.c                               310            0x10bdd5
kernel_entry.c                               313            0x10be05
kernel_entry.c                               314            0x10be11
kernel_entry.c                               316            0x10be2a
kernel_entry.c                               317            0x10be32
kernel_entry.c                               318            0x10be4d
kernel_entry.c                               320            0x10be75
kernel_entry.c                               321            0x10be7d
kernel_entry.c                               322            0x10be8a
kernel_entry.c                               323            0x10be98
kernel_entry.c                               324            0x10bea4
kernel_entry.c                               325            0x10beb8
kernel_entry.c                               326            0x10bec6
kernel_entry.c                               330            0x10bef9
kernel_entry.c                               331            0x10bf00
kernel_entry.c                               334            0x10bf30
kernel_entry.c                               335            0x10bf38
kernel_entry.c                               342            0x10bf4b
kernel_entry.c                               343            0x10bf53
kernel_entry.c                               344            0x10bf5f
kernel_entry.c                               345            0x10bf73
kernel_entry.c                               346            0x10bf7e
kernel_entry.c                               347            0x10bf89
kernel_entry.c                               348            0x10bfa7
kernel_entry.c                               349            0x10bfaf
kernel_entry.c                               350            0x10bfd9
kernel_entry.c                               355            0x10bfe3
kernel_entry.c                               356            0x10bfef
kernel_entry.c                               357            0x10bffb
kernel_entry.c                               358            0x10c015
kernel_entry.c                               359            0x10c030
kernel_entry.c                               360            0x10c05a
kernel_entry.c                               361            0x10c083
kernel_entry.c                               362            0x10c093
kernel_entry.c                               363            0x10c0a3
kernel_entry.c                               402            0x10c0b7
kernel_entry.c                               404            0x10c0c7

src/interrupt_handler.c:
interrupt_handler.c                           42            0x10c0ca
interrupt_handler.c                           43            0x10c0d6
interrupt_handler.c                           44            0x10c0f1
interrupt_handler.c                           45            0x10c0fb
interrupt_handler.c                           46            0x10c0fc
interrupt_handler.c                           48            0x10c0ff
interrupt_handler.c                           49            0x10c10f
interrupt_handler.c                           50            0x10c124
interrupt_handler.c                           52            0x10c127
interrupt_handler.c                           54            0x10c12b
interrupt_handler.c                           55            0x10c133
interrupt_handler.c                           56            0x10c13b
interrupt_handler.c                           57            0x10c144
interrupt_handler.c                           58            0x10c14f
interrupt_handler.c                           59            0x10c156
interrupt_handler.c                           67            0x10c159
interrupt_handler.c                           68            0x10c161
interrupt_handler.c                           69            0x10c18b
interrupt_handler.c                           70            0x10c1a6
interrupt_handler.c                           72            0x10c1c1
interrupt_handler.c                           73            0x10c1d1
interrupt_handler.c                           74            0x10c1d8
interrupt_handler.c                           76            0x10c200
interrupt_handler.c                           79            0x10c203
interrupt_handler.c                           80            0x10c20b
interrupt_handler.c                           81            0x10c21c
interrupt_handler.c                           83            0x10c232
interrupt_handler.c                           84            0x10c242
interrupt_handler.c                           86            0x10c248
interrupt_handler.c                           87            0x10c261
interrupt_handler.c                          114            0x10c264
interrupt_handler.c                          117            0x10c26c
interrupt_handler.c                          118            0x10c27f
interrupt_handler.c                          119            0x10c28e
interrupt_handler.c                          120            0x10c2a1
interrupt_handler.c                          121            0x10c2ac
interrupt_handler.c                          126            0x10c2c6
interrupt_handler.c                          127            0x10c2d3
interrupt_handler.c                          128            0x10c2e7
interrupt_handler.c                          131            0x10c2e9
interrupt_handler.c                          132            0x10c2ef
interrupt_handler.c                          133            0x10c2f9
interrupt_handler.c                          135            0x10c308
interrupt_handler.c                          140            0x10c315
interrupt_handler.c                          142            0x10c338
interrupt_handler.c                          145            0x10c33a
interrupt_handler.c                          146            0x10c34a
interrupt_handler.c                          147            0x10c357
interrupt_handler.c                          149            0x10c36f
interrupt_handler.c                          150            0x10c375
interrupt_handler.c                          151            0x10c386
interrupt_handler.c                          152            0x10c38c
interrupt_handler.c                          153            0x10c39d
interrupt_handler.c                          154            0x10c3a3
interrupt_handler.c                          155            0x10c3c2
interrupt_handler.c                          159            0x10c3dc
interrupt_handler.c                          160            0x10c3e9
interrupt_handler.c                          161            0x10c3ef
interrupt_handler.c                          162            0x10c3ff
interrupt_handler.c                          163            0x10c419
interrupt_handler.c                          167            0x10c424
interrupt_handler.c                          168            0x10c42a
interrupt_handler.c                          169            0x10c42e
interrupt_handler.c                          170            0x10c43a
interrupt_handler.c                          169            0x10c442
interrupt_handler.c                          171            0x10c446
interrupt_handler.c                          172            0x10c458
interrupt_handler.c                          173            0x10c468
interrupt_handler.c                          174            0x10c46e
interrupt_handler.c                          146            0x10c480
interrupt_handler.c                          146            0x10c485
interrupt_handler.c                          173            0x10c49c
interrupt_handler.c                          177            0x10c49d
interrupt_handler.c                          180            0x10c49f
interrupt_handler.c                          181            0x10c4a7
interrupt_handler.c                          182            0x10c4aa
interrupt_handler.c                          183            0x10c4b2
interrupt_handler.c                          184            0x10c4c2
interrupt_handler.c                          185            0x10c4d3
interrupt_handler.c                          186            0x10c4ee
interrupt_handler.c                          187            0x10c506
interrupt_handler.c                          188            0x10c51c
interrupt_handler.c                          189            0x10c539
interrupt_handler.c                          192            0x10c548
interrupt_handler.c                          193            0x10c552

src/kernel_log.c:
kernel_log.c                                  37            0x10c555
kernel_log.c                                  38            0x10c565
kernel_log.c                                  39            0x10c570
kernel_log.c                                  40            0x10c57a
kernel_log.c                                  41            0x10c58b
kernel_log.c                                  42            0x10c5ae
kernel_log.c                                  39            0x10c5c7
kernel_log.c                                  39            0x10c5cc
kernel_log.c                                  44            0x10c5d6
kernel_log.c                                  47            0x10c5d9
kernel_log.c                                  48            0x10c5ee
kernel_log.c                                  49            0x10c5f6
kernel_log.c                                  50            0x10c5fd
kernel_log.c                                  51            0x10c604
kernel_log.c                                  55            0x10c60e
kernel_log.c                                  56            0x10c63e
kernel_log.c                                  53            0x10c652
kernel_log.c                                  58            0x10c659
kernel_log.c                                  60            0x10c66c
kernel_log.c                                  61            0x10c670
kernel_log.c                                  84            0x10c672
kernel_log.c                                  85            0x10c68a
kernel_log.c                                  86            0x10c692
kernel_log.c                                  87            0x10c69a
kernel_log.c                                  88            0x10c69f
kernel_log.c                                  89            0x10c6b5
kernel_log.c                                  91            0x10c6ba
kernel_log.c                                  92            0x10c6d0
kernel_log.c                                  93            0x10c6d5
kernel_log.c                                  94            0x10c6eb
kernel_log.c                                  95            0x10c735
kernel_log.c                                  95            0x10c743
kernel_log.c                                  96            0x10c74c
kernel_log.c                                  97            0x10c770
kernel_log.c                                 102            0x10c77a
kernel_log.c                                 103            0x10c790
kernel_log.c                                 104            0x10c7d8
kernel_log.c                                 104            0x10c7e6
kernel_log.c                                 105            0x10c7ef
kernel_log.c                                 106            0x10c811
kernel_log.c                                 110            0x10c81b
kernel_log.c                                 111            0x10c831
kernel_log.c                                 112            0x10c87b
kernel_log.c                                 113            0x10c88b
kernel_log.c                                 113            0x10c89c
kernel_log.c                                 114            0x10c8a5
kernel_log.c                                 115            0x10c8c4
kernel_log.c                                 116            0x10c8cc
kernel_log.c                                 119            0x10c8d6
kernel_log.c                                 120            0x10c8ec
kernel_log.c                                 121            0x10c936
kernel_log.c                                 121            0x10c944
kernel_log.c                                 122            0x10c94d
kernel_log.c                                 123            0x10c971
kernel_log.c                                 126            0x10c97b
kernel_log.c                                 127            0x10c991
kernel_log.c                                 128            0x10c996
kernel_log.c                                 129            0x10c9ac
kernel_log.c                                 130            0x10c9b1
kernel_log.c                                 131            0x10c9c7
kernel_log.c                                 132            0x10c9cc
kernel_log.c                                 133            0x10ca16
kernel_log.c                                 134            0x10ca60
kernel_log.c                                 134            0x10ca71
kernel_log.c                                 135            0x10ca7a
kernel_log.c                                 136            0x10ca99
kernel_log.c                                 143            0x10caa6
kernel_log.c                                 144            0x10caae
kernel_log.c                                 145            0x10cab0
kernel_log.c                                 144            0x10cab5
kernel_log.c                                 144            0x10cac7
kernel_log.c                                 148            0x10cad9
kernel_log.c                                 149            0x10cae5
kernel_log.c                                 149            0x10caf6
kernel_log.c                                 150            0x10cafc
kernel_log.c                                 151            0x10cb23
kernel_log.c                                  87            0x10cb2b
kernel_log.c                                 154            0x10cb41
kernel_log.c                                 155            0x10cb45
kernel_log.c                                 157            0x10cb47
kernel_log.c                                 158            0x10cb53
kernel_log.c                                 159            0x10cb65
kernel_log.c                                 160            0x10cb79
kernel_log.c                                 161            0x10cb96
kernel_log.c                                 162            0x10cbb0
kernel_log.c                                 163            0x10cbc3
kernel_log.c                                 165            0x10cbdd
kernel_log.c                                 166            0x10cbef
kernel_log.c                                 167            0x10cbf3
kernel_log.c                                 169            0x10cbf5
kernel_log.c                                 170            0x10cc09
kernel_log.c                                 171            0x10cc13
kernel_log.c                                 172            0x10cc2e
kernel_log.c                                 173            0x10cc4e
kernel_log.c                                 176            0x10cc53
kernel_log.c                                 177            0x10cc62
kernel_log.c                                 178            0x10cc72
kernel_log.c                                 179            0x10cc89
kernel_log.c                                 181            0x10cc99
kernel_log.c                                 182            0x10ccab
kernel_log.c                                 183            0x10ccb6
kernel_log.c                                 184            0x10ccd1
kernel_log.c                                 185            0x10cce0
kernel_log.c                                 176            0x10ccf4
kernel_log.c                                 186            0x10ccf5
kernel_log.c                                 188            0x10ccf7
kernel_log.c                                 189            0x10cd50
kernel_log.c                                 191            0x10cd5f
kernel_log.c                                 192            0x10cd74
kernel_log.c                                 193            0x10cd8e
kernel_log.c                                 194            0x10cdb4
kernel_log.c                                 195            0x10cdd4
kernel_log.c                                 195            0x10cdea
kernel_log.c                                 196            0x10ce0a
kernel_log.c                                 199            0x10ce1f
kernel_log.c                                 200            0x10ce4c
kernel_log.c                                 206            0x10ce7d
kernel_log.c                                 207            0x10ce92
kernel_log.c                                 208            0x10cea0
kernel_log.c                                 209            0x10cec1
kernel_log.c                                 210            0x10ced0
kernel_log.c                                 189            0x10cee7
kernel_log.c                                 211            0x10cee8
kernel_log.c                                 213            0x10ceea
kernel_log.c                                 214            0x10cefb
kernel_log.c                                 214            0x10cf05
kernel_log.c                                 215            0x10cf0f
kernel_log.c                                 216            0x10cf21
kernel_log.c                                 217            0x10cf34
kernel_log.c                                 218            0x10cf46
kernel_log.c                                 220            0x10cf48
kernel_log.c                                 221            0x10cf71
kernel_log.c                                 222            0x10cf7c
kernel_log.c                                 214            0x10cf90
kernel_log.c                                 223            0x10cf91
kernel_log.c                                 225            0x10cf93
kernel_log.c                                 226            0x10cf9f
kernel_log.c                                 227            0x10cfb1
kernel_log.c                                 228            0x10cfc1
kernel_log.c                                 229            0x10cfd8
kernel_log.c                                 231            0x10cff2
kernel_log.c                                 232            0x10cffd
kernel_log.c                                 233            0x10d00f
kernel_log.c                                 235            0x10d012
kernel_log.c                                 236            0x10d01e
kernel_log.c                                 237            0x10d02e
kernel_log.c                                 238            0x10d04f
kernel_log.c                                 239            0x10d05e
kernel_log.c                                 241            0x10d069
kernel_log.c                                 245            0x10d06c
kernel_log.c                                 246            0x10d070
kernel_log.c                                 247            0x10d077
kernel_log.c                                 249            0x10d07a
kernel_log.c                                 250            0x10d07e
kernel_log.c                                 251            0x10d085

src/kernel_shell.c:
kernel_shell.c                                42            0x10d088
kernel_shell.c                                43            0x10d098
kernel_shell.c                                46            0x10d0ac
kernel_shell.c                                48            0x10d129
kernel_shell.c                                51            0x10d12c
kernel_shell.c                                52            0x10d13c
kernel_shell.c                                53            0x10d144
kernel_shell.c                                54            0x10d14c
kernel_shell.c                                55            0x10d162
kernel_shell.c                                56            0x10d178
kernel_shell.c                                57            0x10d18e
kernel_shell.c                                58            0x10d1a0
kernel_shell.c                                59            0x10d1ae
kernel_shell.c                                60            0x10d1c1
kernel_shell.c                                63            0x10d1c4
kernel_shell.c                                64            0x10d1d4
kernel_shell.c                                65            0x10d1e3
kernel_shell.c                                68            0x10d1e6
kernel_shell.c                                70            0x10d1f6
kernel_shell.c                                73            0x10d1f9
kernel_shell.c                                74            0x10d209
kernel_shell.c                                75            0x10d224
kernel_shell.c                                77            0x10d227
kernel_shell.c                                83            0x10d237
kernel_shell.c                                83            0x10d251
kernel_shell.c                                83            0x10d269
kernel_shell.c                                83            0x10d283
kernel_shell.c                                83            0x10d29b
kernel_shell.c                                83            0x10d2b5
kernel_shell.c                                83            0x10d2ca
kernel_shell.c                                83            0x10d2e4
kernel_shell.c                                83            0x10d2f9
kernel_shell.c                                83            0x10d313
kernel_shell.c                                86            0x10d328
kernel_shell.c                                87            0x10d343


Disassembly of section .text:

0000000000109000 <__memset>:
  write += LITERAL_STRLEN(literal)

#define memcpy(dest,src,size) __memcpy((uint8_t*)dest, (uint8_t*)src, size)
#define memset(dest,value,size) __memset((uint8_t*)dest, value, size)

void __memset(uint8_t *dest, uint8_t value, size_t size) {
  109000:	55                   	push   rbp
  109001:	48 89 e5             	mov    rbp,rsp
  109004:	48 83 ec 28          	sub    rsp,0x28
  109008:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10900c:	89 f0                	mov    eax,esi
  10900e:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
  109012:	88 45 e4             	mov    BYTE PTR [rbp-0x1c],al
  for (size_t i = 0; i < size; i++) {
  109015:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10901c:	00 
  10901d:	eb 16                	jmp    109035 <__memset+0x35>
		dest[i] = value;
  10901f:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  109023:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109027:	48 01 c2             	add    rdx,rax
  10902a:	0f b6 45 e4          	movzx  eax,BYTE PTR [rbp-0x1c]
  10902e:	88 02                	mov    BYTE PTR [rdx],al
  for (size_t i = 0; i < size; i++) {
  109030:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  109035:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109039:	48 3b 45 d8          	cmp    rax,QWORD PTR [rbp-0x28]
  10903d:	72 e0                	jb     10901f <__memset+0x1f>
	}
}
  10903f:	90                   	nop
  109040:	c9                   	leave  
  109041:	c3                   	ret    

0000000000109042 <__memcpy>:

void __memcpy(uint8_t *dest, uint8_t *src, size_t size) {
  109042:	55                   	push   rbp
  109043:	48 89 e5             	mov    rbp,rsp
  109046:	48 83 ec 28          	sub    rsp,0x28
  10904a:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10904e:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  109052:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
	for (size_t i = 0; i < size; i++) {
  109056:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10905d:	00 
  10905e:	eb 20                	jmp    109080 <__memcpy+0x3e>
		dest[i] = src[i];
  109060:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  109064:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109068:	48 01 c2             	add    rdx,rax
  10906b:	48 8b 4d e0          	mov    rcx,QWORD PTR [rbp-0x20]
  10906f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109073:	48 01 c8             	add    rax,rcx
  109076:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  109079:	88 02                	mov    BYTE PTR [rdx],al
	for (size_t i = 0; i < size; i++) {
  10907b:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  109080:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109084:	48 3b 45 d8          	cmp    rax,QWORD PTR [rbp-0x28]
  109088:	72 d6                	jb     109060 <__memcpy+0x1e>
	}
}
  10908a:	90                   	nop
  10908b:	c9                   	leave  
  10908c:	c3                   	ret    

000000000010908d <strlen>:

static inline
size_t strlen(const char *str) {
  10908d:	55                   	push   rbp
  10908e:	48 89 e5             	mov    rbp,rsp
  109091:	48 83 ec 18          	sub    rsp,0x18
  109095:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
	size_t result = 0;
  109099:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  1090a0:	00 
	while (str[result] != 0)
  1090a1:	eb 05                	jmp    1090a8 <strlen+0x1b>
		result ++;
  1090a3:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
	while (str[result] != 0)
  1090a8:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  1090ac:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  1090b0:	48 01 d0             	add    rax,rdx
  1090b3:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  1090b6:	84 c0                	test   al,al
  1090b8:	75 e9                	jne    1090a3 <strlen+0x16>
	return result;
  1090ba:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
}
  1090be:	c9                   	leave  
  1090bf:	c3                   	ret    

00000000001090c0 <string_equals_string>:


#define string_matches_literal(string, len, lit) strings_match(string,len, lit, LITERAL_STRLEN(lit))

static int 
string_equals_string(const char *stringA, size_t lengthA, const char *stringB, size_t lengthB) {
  1090c0:	55                   	push   rbp
  1090c1:	48 89 e5             	mov    rbp,rsp
  1090c4:	48 83 ec 30          	sub    rsp,0x30
  1090c8:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  1090cc:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  1090d0:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
  1090d4:	48 89 4d d0          	mov    QWORD PTR [rbp-0x30],rcx
	if (lengthA != lengthB) return 0;
  1090d8:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  1090dc:	48 3b 45 d0          	cmp    rax,QWORD PTR [rbp-0x30]
  1090e0:	74 07                	je     1090e9 <string_equals_string+0x29>
  1090e2:	b8 00 00 00 00       	mov    eax,0x0
  1090e7:	eb 45                	jmp    10912e <string_equals_string+0x6e>
	for (size_t i = 0; i < lengthA; i++) {
  1090e9:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  1090f0:	00 
  1090f1:	eb 2c                	jmp    10911f <string_equals_string+0x5f>
		if (stringA[i] != stringB[i]) {
  1090f3:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  1090f7:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  1090fb:	48 01 d0             	add    rax,rdx
  1090fe:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  109101:	48 8b 4d d8          	mov    rcx,QWORD PTR [rbp-0x28]
  109105:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109109:	48 01 c8             	add    rax,rcx
  10910c:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10910f:	38 c2                	cmp    dl,al
  109111:	74 07                	je     10911a <string_equals_string+0x5a>
			return 0;
  109113:	b8 00 00 00 00       	mov    eax,0x0
  109118:	eb 14                	jmp    10912e <string_equals_string+0x6e>
	for (size_t i = 0; i < lengthA; i++) {
  10911a:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10911f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109123:	48 3b 45 e0          	cmp    rax,QWORD PTR [rbp-0x20]
  109127:	72 ca                	jb     1090f3 <string_equals_string+0x33>
		}
	}
	return 1;
  109129:	b8 01 00 00 00       	mov    eax,0x1
}
  10912e:	c9                   	leave  
  10912f:	c3                   	ret    

0000000000109130 <string_matches_string>:

static int
string_matches_string(const char *str0, size_t length, const char *str1){
  109130:	55                   	push   rbp
  109131:	48 89 e5             	mov    rbp,rsp
  109134:	48 83 ec 28          	sub    rsp,0x28
  109138:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10913c:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  109140:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
  for(size_t i = 0; i < length; i++) 
  109144:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10914b:	00 
  10914c:	eb 2c                	jmp    10917a <string_matches_string+0x4a>
    if(str0[i] != str1[i]) return 0;
  10914e:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  109152:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109156:	48 01 d0             	add    rax,rdx
  109159:	0f b6 10             	movzx  edx,BYTE PTR [rax]
  10915c:	48 8b 4d d8          	mov    rcx,QWORD PTR [rbp-0x28]
  109160:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109164:	48 01 c8             	add    rax,rcx
  109167:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10916a:	38 c2                	cmp    dl,al
  10916c:	74 07                	je     109175 <string_matches_string+0x45>
  10916e:	b8 00 00 00 00       	mov    eax,0x0
  109173:	eb 14                	jmp    109189 <string_matches_string+0x59>
  for(size_t i = 0; i < length; i++) 
  109175:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10917a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10917e:	48 3b 45 e0          	cmp    rax,QWORD PTR [rbp-0x20]
  109182:	72 ca                	jb     10914e <string_matches_string+0x1e>
  return 1;
  109184:	b8 01 00 00 00       	mov    eax,0x1
}
  109189:	c9                   	leave  
  10918a:	c3                   	ret    

000000000010918b <is_char_alpha>:


int is_char_alpha(char c) {
  10918b:	55                   	push   rbp
  10918c:	48 89 e5             	mov    rbp,rsp
  10918f:	48 83 ec 08          	sub    rsp,0x8
  109193:	89 f8                	mov    eax,edi
  109195:	88 45 fc             	mov    BYTE PTR [rbp-0x4],al
	if ((c >= 'A' && c <= 'Z') ||
  109198:	80 7d fc 40          	cmp    BYTE PTR [rbp-0x4],0x40
  10919c:	7e 06                	jle    1091a4 <is_char_alpha+0x19>
  10919e:	80 7d fc 5a          	cmp    BYTE PTR [rbp-0x4],0x5a
  1091a2:	7e 0c                	jle    1091b0 <is_char_alpha+0x25>
  1091a4:	80 7d fc 60          	cmp    BYTE PTR [rbp-0x4],0x60
  1091a8:	7e 0d                	jle    1091b7 <is_char_alpha+0x2c>
			(c >= 'a' && c <= 'z')) {
  1091aa:	80 7d fc 7a          	cmp    BYTE PTR [rbp-0x4],0x7a
  1091ae:	7f 07                	jg     1091b7 <is_char_alpha+0x2c>
		return 1;
  1091b0:	b8 01 00 00 00       	mov    eax,0x1
  1091b5:	eb 05                	jmp    1091bc <is_char_alpha+0x31>
	}

	return 0;
  1091b7:	b8 00 00 00 00       	mov    eax,0x0
}
  1091bc:	c9                   	leave  
  1091bd:	c3                   	ret    

00000000001091be <spinlock_aquire>:
typedef struct {
  volatile int lock;
} Spin_Lock;

static inline
void spinlock_aquire(Spin_Lock *lock){
  1091be:	55                   	push   rbp
  1091bf:	48 89 e5             	mov    rbp,rsp
  1091c2:	48 83 ec 08          	sub    rsp,0x8
  1091c6:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  while(!__sync_bool_compare_and_swap(&lock->lock, 0, 1));
  1091ca:	90                   	nop
  1091cb:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  1091cf:	b8 00 00 00 00       	mov    eax,0x0
  1091d4:	b9 01 00 00 00       	mov    ecx,0x1
  1091d9:	f0 0f b1 0a          	lock cmpxchg DWORD PTR [rdx],ecx
  1091dd:	0f 94 c0             	sete   al
  1091e0:	83 f0 01             	xor    eax,0x1
  1091e3:	84 c0                	test   al,al
  1091e5:	75 e4                	jne    1091cb <spinlock_aquire+0xd>
  __sync_synchronize();
  1091e7:	0f ae f0             	mfence 
}
  1091ea:	90                   	nop
  1091eb:	c9                   	leave  
  1091ec:	c3                   	ret    

00000000001091ed <spinlock_release>:

static inline
void spinlock_release(Spin_Lock *lock){
  1091ed:	55                   	push   rbp
  1091ee:	48 89 e5             	mov    rbp,rsp
  1091f1:	48 83 ec 08          	sub    rsp,0x8
  1091f5:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  __sync_synchronize(); 
  1091f9:	0f ae f0             	mfence 
  lock->lock = 0;
  1091fc:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109200:	c7 00 00 00 00 00    	mov    DWORD PTR [rax],0x0
  109206:	90                   	nop
  109207:	c9                   	leave  
  109208:	c3                   	ret    

0000000000109209 <write_port_uint8>:
	asm volatile ("cli"); \
	asm volatile ("hlt")


static inline 
void write_port_uint8(uint16_t port, uint8_t value) {
  109209:	55                   	push   rbp
  10920a:	48 89 e5             	mov    rbp,rsp
  10920d:	48 83 ec 08          	sub    rsp,0x8
  109211:	89 fa                	mov    edx,edi
  109213:	89 f0                	mov    eax,esi
  109215:	66 89 55 fc          	mov    WORD PTR [rbp-0x4],dx
  109219:	88 45 f8             	mov    BYTE PTR [rbp-0x8],al
	asm volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
  10921c:	0f b6 45 f8          	movzx  eax,BYTE PTR [rbp-0x8]
  109220:	0f b7 55 fc          	movzx  edx,WORD PTR [rbp-0x4]
  109224:	ee                   	out    dx,al
}
  109225:	90                   	nop
  109226:	c9                   	leave  
  109227:	c3                   	ret    

0000000000109228 <read_port_uint8>:
  asm volatile ("outl %0, %1" : : "a"(value), "Nd"(port));
}


static inline
uint8_t read_port_uint8(uint16_t port) {
  109228:	55                   	push   rbp
  109229:	48 89 e5             	mov    rbp,rsp
  10922c:	48 83 ec 18          	sub    rsp,0x18
  109230:	89 f8                	mov    eax,edi
  109232:	66 89 45 ec          	mov    WORD PTR [rbp-0x14],ax
	uint8_t result;
	asm volatile ("inb %1, %0" : "=a"(result) : "Nd"(port));
  109236:	0f b7 45 ec          	movzx  eax,WORD PTR [rbp-0x14]
  10923a:	89 c2                	mov    edx,eax
  10923c:	ec                   	in     al,dx
  10923d:	88 45 ff             	mov    BYTE PTR [rbp-0x1],al
	return result;
  109240:	0f b6 45 ff          	movzx  eax,BYTE PTR [rbp-0x1]
}
  109244:	c9                   	leave  
  109245:	c3                   	ret    

0000000000109246 <kernel_reboot>:
	return result;
}

//TODO(Torin) Proper rebooting with ACPI
static void
kernel_reboot() {
  109246:	55                   	push   rbp
  109247:	48 89 e5             	mov    rbp,rsp
  10924a:	48 83 ec 10          	sub    rsp,0x10
	struct {
			uint16_t size;
			uintptr_t address;
	} __attribute__((packed)) idtr = { 0, 0 };
  10924e:	66 c7 45 f0 00 00    	mov    WORD PTR [rbp-0x10],0x0
  109254:	48 c7 45 f2 00 00 00 	mov    QWORD PTR [rbp-0xe],0x0
  10925b:	00 
	asm volatile ("lidt %0" : : "m"(idtr));
  10925c:	0f 01 5d f0          	lidt   [rbp-0x10]
	asm volatile ("int $0x3");
  109260:	cc                   	int3   
}
  109261:	90                   	nop
  109262:	c9                   	leave  
  109263:	c3                   	ret    

0000000000109264 <kgfx_draw_character>:
    }
  }
}

#else
void kgfx_draw_character(char c, size_t x_orign, size_t y_origin, Framebuffer *fb) {
  109264:	55                   	push   rbp
  109265:	48 89 e5             	mov    rbp,rsp
  109268:	48 83 ec 50          	sub    rsp,0x50
  10926c:	89 f8                	mov    eax,edi
  10926e:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  109272:	48 89 55 b8          	mov    QWORD PTR [rbp-0x48],rdx
  109276:	48 89 4d b0          	mov    QWORD PTR [rbp-0x50],rcx
  10927a:	88 45 cc             	mov    BYTE PTR [rbp-0x34],al
  const uint8_t *character_data = &INCONSOLATA16[(c - ' ') * 256];
  10927d:	0f be 45 cc          	movsx  eax,BYTE PTR [rbp-0x34]
  109281:	83 e8 20             	sub    eax,0x20
  109284:	c1 e0 08             	shl    eax,0x8
  109287:	48 98                	cdqe   
  109289:	48 05 40 00 10 00    	add    rax,0x100040
  10928f:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
  for(size_t i = 0; i < 16; i++){
  109293:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10929a:	00 
  10929b:	e9 d2 00 00 00       	jmp    109372 <kgfx_draw_character+0x10e>
    for(size_t j = 0; j < 16; j++){
  1092a0:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
  1092a7:	00 
  1092a8:	e9 b5 00 00 00       	jmp    109362 <kgfx_draw_character+0xfe>
      size_t char_index = j + i*16; 
  1092ad:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  1092b1:	48 c1 e0 04          	shl    rax,0x4
  1092b5:	48 89 c2             	mov    rdx,rax
  1092b8:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  1092bc:	48 01 d0             	add    rax,rdx
  1092bf:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
      if(character_data[char_index] > 0){
  1092c3:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  1092c7:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  1092cb:	48 01 d0             	add    rax,rdx
  1092ce:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  1092d1:	84 c0                	test   al,al
  1092d3:	0f 84 84 00 00 00    	je     10935d <kgfx_draw_character+0xf9>
        size_t fb_index = ((j+x_orign)*fb->depth) + ((i+y_origin)*fb->pitch);
  1092d9:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  1092dd:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  1092e1:	48 01 c2             	add    rdx,rax
  1092e4:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  1092e8:	0f b6 40 0c          	movzx  eax,BYTE PTR [rax+0xc]
  1092ec:	0f b6 c0             	movzx  eax,al
  1092ef:	48 0f af d0          	imul   rdx,rax
  1092f3:	48 8b 4d f8          	mov    rcx,QWORD PTR [rbp-0x8]
  1092f7:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  1092fb:	48 01 c1             	add    rcx,rax
  1092fe:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  109302:	8b 40 08             	mov    eax,DWORD PTR [rax+0x8]
  109305:	89 c0                	mov    eax,eax
  109307:	48 0f af c1          	imul   rax,rcx
  10930b:	48 01 d0             	add    rax,rdx
  10930e:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
        fb->buffer[fb_index + 0] = 0x00;
  109312:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  109316:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10931a:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10931e:	48 01 d0             	add    rax,rdx
  109321:	c6 00 00             	mov    BYTE PTR [rax],0x0
        fb->buffer[fb_index + 1] = character_data[char_index];
  109324:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  109328:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  10932c:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
  109330:	48 83 c2 01          	add    rdx,0x1
  109334:	48 01 c2             	add    rdx,rax
  109337:	48 8b 4d e8          	mov    rcx,QWORD PTR [rbp-0x18]
  10933b:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10933f:	48 01 c8             	add    rax,rcx
  109342:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  109345:	88 02                	mov    BYTE PTR [rdx],al
        fb->buffer[fb_index + 2] = 0x00;
  109347:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  10934b:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  10934f:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
  109353:	48 83 c2 02          	add    rdx,0x2
  109357:	48 01 d0             	add    rax,rdx
  10935a:	c6 00 00             	mov    BYTE PTR [rax],0x0
    for(size_t j = 0; j < 16; j++){
  10935d:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  109362:	48 83 7d f0 0f       	cmp    QWORD PTR [rbp-0x10],0xf
  109367:	0f 86 40 ff ff ff    	jbe    1092ad <kgfx_draw_character+0x49>
  for(size_t i = 0; i < 16; i++){
  10936d:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  109372:	48 83 7d f8 0f       	cmp    QWORD PTR [rbp-0x8],0xf
  109377:	0f 86 23 ff ff ff    	jbe    1092a0 <kgfx_draw_character+0x3c>
      }
    }
  }
}
  10937d:	90                   	nop
  10937e:	c9                   	leave  
  10937f:	c3                   	ret    

0000000000109380 <kgfx_clear_framebuffer>:
#endif

void kgfx_clear_framebuffer(Framebuffer *fb){
  109380:	55                   	push   rbp
  109381:	48 89 e5             	mov    rbp,rsp
  109384:	48 83 ec 60          	sub    rsp,0x60
  109388:	48 89 7d a8          	mov    QWORD PTR [rbp-0x58],rdi
  size_t step_count = (fb->width * fb->height * fb->depth) / 16;
  10938c:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  109390:	8b 10                	mov    edx,DWORD PTR [rax]
  109392:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  109396:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
  109399:	0f af d0             	imul   edx,eax
  10939c:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1093a0:	0f b6 40 0c          	movzx  eax,BYTE PTR [rax+0xc]
  1093a4:	0f b6 c0             	movzx  eax,al
  1093a7:	0f af c2             	imul   eax,edx
  1093aa:	c1 e8 04             	shr    eax,0x4
  1093ad:	89 c0                	mov    eax,eax
  1093af:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
  __m128i *write_ptr = (__m128i *)fb->buffer; 
  1093b3:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1093b7:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  1093bb:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax

/* Create a vector of zeros.  */
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_si128 (void)
{
  return __extension__ (__m128i)(__v4si){ 0, 0, 0, 0 };
  1093bf:	66 0f ef c0          	pxor   xmm0,xmm0
  __m128i clear_value = _mm_setzero_si128();
  1093c3:	0f 29 45 d0          	movaps XMMWORD PTR [rbp-0x30],xmm0
  for(size_t i = 0; i < step_count; i++){
  1093c7:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
  1093ce:	00 
  1093cf:	eb 2e                	jmp    1093ff <kgfx_clear_framebuffer+0x7f>
  1093d1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  1093d5:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
  1093d9:	66 0f 6f 45 d0       	movdqa xmm0,XMMWORD PTR [rbp-0x30]
  1093de:	0f 29 45 b0          	movaps XMMWORD PTR [rbp-0x50],xmm0
  *__P = __B;
  1093e2:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  1093e6:	66 0f 6f 45 b0       	movdqa xmm0,XMMWORD PTR [rbp-0x50]
  1093eb:	0f 29 00             	movaps XMMWORD PTR [rax],xmm0
    _mm_store_si128(write_ptr, clear_value);
    write_ptr = (__m128i *)((uintptr_t)write_ptr + 16);
  1093ee:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  1093f2:	48 83 c0 10          	add    rax,0x10
  1093f6:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  for(size_t i = 0; i < step_count; i++){
  1093fa:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  1093ff:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109403:	48 3b 45 e8          	cmp    rax,QWORD PTR [rbp-0x18]
  109407:	72 c8                	jb     1093d1 <kgfx_clear_framebuffer+0x51>
  }
}
  109409:	90                   	nop
  10940a:	c9                   	leave  
  10940b:	c3                   	ret    

000000000010940c <vga_set_char>:
  }
}
#endif

static inline
void vga_set_char(char c, uint8_t color, int x, int y){
  10940c:	55                   	push   rbp
  10940d:	48 89 e5             	mov    rbp,rsp
  109410:	48 83 ec 20          	sub    rsp,0x20
  109414:	89 f0                	mov    eax,esi
  109416:	89 55 e4             	mov    DWORD PTR [rbp-0x1c],edx
  109419:	89 4d e0             	mov    DWORD PTR [rbp-0x20],ecx
  10941c:	40 88 7d ec          	mov    BYTE PTR [rbp-0x14],dil
  109420:	88 45 e8             	mov    BYTE PTR [rbp-0x18],al
  static const uint8_t VGA_TEXT_COLUMN_COUNT = 80;
	static const uint8_t VGA_TEXT_ROW_COUNT = 25;
	static uint8_t *VGA_TEXT_BUFFER = (uint8_t*)(0xB8000);
  size_t vga_index = ((y * VGA_TEXT_COLUMN_COUNT) + x) * 2;
  109423:	0f b6 05 48 ee ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffee48]        # 108272 <VGA_TEXT_COLUMN_COUNT.4112>
  10942a:	0f b6 c0             	movzx  eax,al
  10942d:	0f af 45 e0          	imul   eax,DWORD PTR [rbp-0x20]
  109431:	89 c2                	mov    edx,eax
  109433:	8b 45 e4             	mov    eax,DWORD PTR [rbp-0x1c]
  109436:	01 d0                	add    eax,edx
  109438:	01 c0                	add    eax,eax
  10943a:	48 98                	cdqe   
  10943c:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  VGA_TEXT_BUFFER[vga_index+0] = c;
  109440:	48 8b 15 49 44 00 00 	mov    rdx,QWORD PTR [rip+0x4449]        # 10d890 <VGA_TEXT_BUFFER.4114>
  109447:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10944b:	48 01 c2             	add    rdx,rax
  10944e:	0f b6 45 ec          	movzx  eax,BYTE PTR [rbp-0x14]
  109452:	88 02                	mov    BYTE PTR [rdx],al
  VGA_TEXT_BUFFER[vga_index+1] = color;
  109454:	48 8b 05 35 44 00 00 	mov    rax,QWORD PTR [rip+0x4435]        # 10d890 <VGA_TEXT_BUFFER.4114>
  10945b:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10945f:	48 83 c2 01          	add    rdx,0x1
  109463:	48 01 c2             	add    rdx,rax
  109466:	0f b6 45 e8          	movzx  eax,BYTE PTR [rbp-0x18]
  10946a:	88 02                	mov    BYTE PTR [rdx],al
}
  10946c:	90                   	nop
  10946d:	c9                   	leave  
  10946e:	c3                   	ret    

000000000010946f <draw_vga_text_terminal>:

static inline
void draw_vga_text_terminal(Circular_Log *log){
  10946f:	55                   	push   rbp
  109470:	48 89 e5             	mov    rbp,rsp
  109473:	48 83 ec 58          	sub    rsp,0x58
  109477:	48 89 7d a8          	mov    QWORD PTR [rbp-0x58],rdi
  static const uint8_t VGA_TEXT_COLUMN_COUNT = 80;
	static const uint8_t VGA_TEXT_ROW_COUNT = 25;
	static uint8_t *VGA_TEXT_BUFFER = (uint8_t*)(0xB8000);
  memset(VGA_TEXT_BUFFER, 0x00, VGA_TEXT_COLUMN_COUNT*VGA_TEXT_ROW_COUNT*2);
  10947b:	0f b6 05 ee ed ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffedee]        # 108270 <VGA_TEXT_COLUMN_COUNT.4119>
  109482:	0f b6 d0             	movzx  edx,al
  109485:	0f b6 05 e5 ed ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffede5]        # 108271 <VGA_TEXT_ROW_COUNT.4120>
  10948c:	0f b6 c0             	movzx  eax,al
  10948f:	0f af c2             	imul   eax,edx
  109492:	01 c0                	add    eax,eax
  109494:	48 63 d0             	movsxd rdx,eax
  109497:	48 8b 05 ea 43 00 00 	mov    rax,QWORD PTR [rip+0x43ea]        # 10d888 <VGA_TEXT_BUFFER.4121>
  10949e:	be 00 00 00 00       	mov    esi,0x0
  1094a3:	48 89 c7             	mov    rdi,rax
  1094a6:	e8 55 fb ff ff       	call   109000 <__memset>

  size_t entries_to_draw = min((VGA_TEXT_ROW_COUNT - 1), log->current_entry_count);
  1094ab:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1094af:	48 8b 90 08 04 01 00 	mov    rdx,QWORD PTR [rax+0x10408]
  1094b6:	0f b6 05 b4 ed ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffedb4]        # 108271 <VGA_TEXT_ROW_COUNT.4120>
  1094bd:	0f b6 c0             	movzx  eax,al
  1094c0:	83 e8 01             	sub    eax,0x1
  1094c3:	48 98                	cdqe   
  1094c5:	48 39 c2             	cmp    rdx,rax
  1094c8:	48 0f 46 c2          	cmovbe rax,rdx
  1094cc:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
  for(size_t i = 0; i < entries_to_draw; i++){
  1094d0:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  1094d7:	00 
  1094d8:	e9 bd 00 00 00       	jmp    10959a <draw_vga_text_terminal+0x12b>
    size_t entry_offset = entries_to_draw - i; 
  1094dd:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  1094e1:	48 2b 45 f8          	sub    rax,QWORD PTR [rbp-0x8]
  1094e5:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
    size_t entry_index = (log->entry_write_position - entry_offset - log->scroll_offset) % CIRCULAR_LOG_ENTRY_COUNT;
  1094e9:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1094ed:	48 8b 80 00 04 01 00 	mov    rax,QWORD PTR [rax+0x10400]
  1094f4:	48 2b 45 d8          	sub    rax,QWORD PTR [rbp-0x28]
  1094f8:	48 89 c2             	mov    rdx,rax
  1094fb:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1094ff:	48 8b 80 10 04 01 00 	mov    rax,QWORD PTR [rax+0x10410]
  109506:	48 29 c2             	sub    rdx,rax
  109509:	48 89 d0             	mov    rax,rdx
  10950c:	25 ff 00 00 00       	and    eax,0xff
  109511:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
    Circular_Log_Entry *entry = &log->entries[entry_index];  
  109515:	48 8b 55 d0          	mov    rdx,QWORD PTR [rbp-0x30]
  109519:	48 89 d0             	mov    rax,rdx
  10951c:	48 c1 e0 06          	shl    rax,0x6
  109520:	48 01 d0             	add    rax,rdx
  109523:	48 c1 e0 02          	shl    rax,0x2
  109527:	48 8b 55 a8          	mov    rdx,QWORD PTR [rbp-0x58]
  10952b:	48 01 d0             	add    rax,rdx
  10952e:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
    size_t chars_to_write = min(entry->length, VGA_TEXT_COLUMN_COUNT);
  109532:	0f b6 05 37 ed ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffed37]        # 108270 <VGA_TEXT_COLUMN_COUNT.4119>
  109539:	0f b6 d0             	movzx  edx,al
  10953c:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  109540:	8b 80 00 01 00 00    	mov    eax,DWORD PTR [rax+0x100]
  109546:	39 c2                	cmp    edx,eax
  109548:	0f 46 c2             	cmovbe eax,edx
  10954b:	89 c0                	mov    eax,eax
  10954d:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
    for(size_t j = 0; j < chars_to_write; j++){
  109551:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
  109558:	00 
  109559:	eb 30                	jmp    10958b <draw_vga_text_terminal+0x11c>
      vga_set_char(entry->message[j], VGAColor_GREEN, j, i);
  10955b:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10955f:	89 c1                	mov    ecx,eax
  109561:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109565:	89 c6                	mov    esi,eax
  109567:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  10956b:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10956f:	48 01 d0             	add    rax,rdx
  109572:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  109575:	0f be c0             	movsx  eax,al
  109578:	89 f2                	mov    edx,esi
  10957a:	be 02 00 00 00       	mov    esi,0x2
  10957f:	89 c7                	mov    edi,eax
  109581:	e8 86 fe ff ff       	call   10940c <vga_set_char>
    for(size_t j = 0; j < chars_to_write; j++){
  109586:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  10958b:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10958f:	48 3b 45 c0          	cmp    rax,QWORD PTR [rbp-0x40]
  109593:	72 c6                	jb     10955b <draw_vga_text_terminal+0xec>
  for(size_t i = 0; i < entries_to_draw; i++){
  109595:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10959a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10959e:	48 3b 45 e0          	cmp    rax,QWORD PTR [rbp-0x20]
  1095a2:	0f 82 35 ff ff ff    	jb     1094dd <draw_vga_text_terminal+0x6e>
    }
  }

  size_t input_buffer_to_write = min(VGA_TEXT_COLUMN_COUNT, log->input_buffer_count);
  1095a8:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1095ac:	48 8b 90 18 05 01 00 	mov    rdx,QWORD PTR [rax+0x10518]
  1095b3:	0f b6 05 b6 ec ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffecb6]        # 108270 <VGA_TEXT_COLUMN_COUNT.4119>
  1095ba:	0f b6 c0             	movzx  eax,al
  1095bd:	48 39 c2             	cmp    rdx,rax
  1095c0:	48 0f 46 c2          	cmovbe rax,rdx
  1095c4:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
  for(size_t i = 0; i < input_buffer_to_write; i++){
  1095c8:	48 c7 45 e8 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0
  1095cf:	00 
  1095d0:	eb 3f                	jmp    109611 <draw_vga_text_terminal+0x1a2>
    vga_set_char(log->input_buffer[i], VGAColor_RED, i, VGA_TEXT_ROW_COUNT - 1); 
  1095d2:	0f b6 05 98 ec ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffec98]        # 108271 <VGA_TEXT_ROW_COUNT.4120>
  1095d9:	0f b6 c0             	movzx  eax,al
  1095dc:	8d 50 ff             	lea    edx,[rax-0x1]
  1095df:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  1095e3:	89 c6                	mov    esi,eax
  1095e5:	48 8b 4d a8          	mov    rcx,QWORD PTR [rbp-0x58]
  1095e9:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  1095ed:	48 01 c8             	add    rax,rcx
  1095f0:	48 05 18 04 01 00    	add    rax,0x10418
  1095f6:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  1095f9:	0f be c0             	movsx  eax,al
  1095fc:	89 d1                	mov    ecx,edx
  1095fe:	89 f2                	mov    edx,esi
  109600:	be 04 00 00 00       	mov    esi,0x4
  109605:	89 c7                	mov    edi,eax
  109607:	e8 00 fe ff ff       	call   10940c <vga_set_char>
  for(size_t i = 0; i < input_buffer_to_write; i++){
  10960c:	48 83 45 e8 01       	add    QWORD PTR [rbp-0x18],0x1
  109611:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  109615:	48 3b 45 b8          	cmp    rax,QWORD PTR [rbp-0x48]
  109619:	72 b7                	jb     1095d2 <draw_vga_text_terminal+0x163>
  } 
}
  10961b:	90                   	nop
  10961c:	c9                   	leave  
  10961d:	c3                   	ret    

000000000010961e <kgfx_draw_log_if_dirty>:
    VGA_TEXT_BUFFER[vga_index+1] = 0x00; 
  }
}
#endif

void kgfx_draw_log_if_dirty(Circular_Log *log){
  10961e:	55                   	push   rbp
  10961f:	48 89 e5             	mov    rbp,rsp
  109622:	48 83 ec 70          	sub    rsp,0x70
  109626:	48 89 7d 98          	mov    QWORD PTR [rbp-0x68],rdi
  if(log->is_dirty == false) return;
  10962a:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  10962e:	0f b6 80 24 05 01 00 	movzx  eax,BYTE PTR [rax+0x10524]
  109635:	83 f0 01             	xor    eax,0x1
  109638:	84 c0                	test   al,al
  10963a:	0f 85 fd 01 00 00    	jne    10983d <kgfx_draw_log_if_dirty+0x21f>
  log->is_dirty = false;
  109640:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  109644:	c6 80 24 05 01 00 00 	mov    BYTE PTR [rax+0x10524],0x0

  if(globals.framebuffer.buffer != 0){
  10964b:	48 8b 05 06 51 01 00 	mov    rax,QWORD PTR [rip+0x15106]        # 11e758 <globals+0x10758>
  109652:	48 85 c0             	test   rax,rax
  109655:	0f 84 d4 01 00 00    	je     10982f <kgfx_draw_log_if_dirty+0x211>
    static const uint32_t FONT_SIZE = 16;
    static const uint32_t ROW_SPACING = 0;
    static const uint32_t CHARACTER_SPACING = 10;
    Framebuffer *fb = &globals.framebuffer;
  10965b:	48 c7 45 e0 48 e7 11 	mov    QWORD PTR [rbp-0x20],0x11e748
  109662:	00 
    kgfx_clear_framebuffer(fb);
  109663:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  109667:	48 89 c7             	mov    rdi,rax
  10966a:	e8 11 fd ff ff       	call   109380 <kgfx_clear_framebuffer>
    const uint32_t total_column_count = fb->width / CHARACTER_SPACING;
  10966f:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  109673:	8b 00                	mov    eax,DWORD PTR [rax]
  109675:	8b 35 e9 eb ff ff    	mov    esi,DWORD PTR [rip+0xffffffffffffebe9]        # 108264 <CHARACTER_SPACING.4145>
  10967b:	ba 00 00 00 00       	mov    edx,0x0
  109680:	f7 f6                	div    esi
  109682:	89 45 dc             	mov    DWORD PTR [rbp-0x24],eax
    const uint32_t max_row_count = fb->height / (FONT_SIZE + ROW_SPACING);
  109685:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  109689:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
  10968c:	8b 0d d6 eb ff ff    	mov    ecx,DWORD PTR [rip+0xffffffffffffebd6]        # 108268 <FONT_SIZE.4143>
  109692:	8b 15 d4 eb ff ff    	mov    edx,DWORD PTR [rip+0xffffffffffffebd4]        # 10826c <ROW_SPACING.4144>
  109698:	8d 3c 0a             	lea    edi,[rdx+rcx*1]
  10969b:	ba 00 00 00 00       	mov    edx,0x0
  1096a0:	f7 f7                	div    edi
  1096a2:	89 45 d8             	mov    DWORD PTR [rbp-0x28],eax
    const uint32_t total_lines_to_draw = min(log->current_entry_count, max_row_count - 1); 
  1096a5:	8b 45 d8             	mov    eax,DWORD PTR [rbp-0x28]
  1096a8:	83 e8 01             	sub    eax,0x1
  1096ab:	89 c2                	mov    edx,eax
  1096ad:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  1096b1:	48 8b 80 08 04 01 00 	mov    rax,QWORD PTR [rax+0x10408]
  1096b8:	48 39 c2             	cmp    rdx,rax
  1096bb:	48 0f 46 c2          	cmovbe rax,rdx
  1096bf:	89 45 d4             	mov    DWORD PTR [rbp-0x2c],eax
    for(size_t i = 0; i < total_lines_to_draw; i++){
  1096c2:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  1096c9:	00 
  1096ca:	e9 ce 00 00 00       	jmp    10979d <kgfx_draw_log_if_dirty+0x17f>
      size_t entry_offset = total_lines_to_draw - i; 
  1096cf:	8b 45 d4             	mov    eax,DWORD PTR [rbp-0x2c]
  1096d2:	48 2b 45 f8          	sub    rax,QWORD PTR [rbp-0x8]
  1096d6:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
      size_t entry_index = (log->entry_write_position - entry_offset - log->scroll_offset) % CIRCULAR_LOG_ENTRY_COUNT;
  1096da:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  1096de:	48 8b 80 00 04 01 00 	mov    rax,QWORD PTR [rax+0x10400]
  1096e5:	48 2b 45 c8          	sub    rax,QWORD PTR [rbp-0x38]
  1096e9:	48 89 c2             	mov    rdx,rax
  1096ec:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  1096f0:	48 8b 80 10 04 01 00 	mov    rax,QWORD PTR [rax+0x10410]
  1096f7:	48 29 c2             	sub    rdx,rax
  1096fa:	48 89 d0             	mov    rax,rdx
  1096fd:	25 ff 00 00 00       	and    eax,0xff
  109702:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
      Circular_Log_Entry *entry = &log->entries[entry_index];  
  109706:	48 8b 55 c0          	mov    rdx,QWORD PTR [rbp-0x40]
  10970a:	48 89 d0             	mov    rax,rdx
  10970d:	48 c1 e0 06          	shl    rax,0x6
  109711:	48 01 d0             	add    rax,rdx
  109714:	48 c1 e0 02          	shl    rax,0x2
  109718:	48 8b 55 98          	mov    rdx,QWORD PTR [rbp-0x68]
  10971c:	48 01 d0             	add    rax,rdx
  10971f:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
      size_t chars_to_write = min(entry->length, total_column_count);
  109723:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  109727:	8b 90 00 01 00 00    	mov    edx,DWORD PTR [rax+0x100]
  10972d:	8b 45 dc             	mov    eax,DWORD PTR [rbp-0x24]
  109730:	39 c2                	cmp    edx,eax
  109732:	0f 46 c2             	cmovbe eax,edx
  109735:	89 c0                	mov    eax,eax
  109737:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
      for(size_t j = 0; j < chars_to_write; j++){
  10973b:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
  109742:	00 
  109743:	eb 49                	jmp    10978e <kgfx_draw_log_if_dirty+0x170>
        kgfx_draw_character(entry->message[j], j*CHARACTER_SPACING, i*(FONT_SIZE + ROW_SPACING), fb);
  109745:	8b 15 1d eb ff ff    	mov    edx,DWORD PTR [rip+0xffffffffffffeb1d]        # 108268 <FONT_SIZE.4143>
  10974b:	8b 05 1b eb ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffeb1b]        # 10826c <ROW_SPACING.4144>
  109751:	01 d0                	add    eax,edx
  109753:	89 c0                	mov    eax,eax
  109755:	48 0f af 45 f8       	imul   rax,QWORD PTR [rbp-0x8]
  10975a:	48 89 c2             	mov    rdx,rax
  10975d:	8b 05 01 eb ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffeb01]        # 108264 <CHARACTER_SPACING.4145>
  109763:	89 c0                	mov    eax,eax
  109765:	48 0f af 45 f0       	imul   rax,QWORD PTR [rbp-0x10]
  10976a:	48 89 c6             	mov    rsi,rax
  10976d:	48 8b 4d b8          	mov    rcx,QWORD PTR [rbp-0x48]
  109771:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109775:	48 01 c8             	add    rax,rcx
  109778:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10977b:	0f be c0             	movsx  eax,al
  10977e:	48 8b 4d e0          	mov    rcx,QWORD PTR [rbp-0x20]
  109782:	89 c7                	mov    edi,eax
  109784:	e8 db fa ff ff       	call   109264 <kgfx_draw_character>
      for(size_t j = 0; j < chars_to_write; j++){
  109789:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  10978e:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109792:	48 3b 45 b0          	cmp    rax,QWORD PTR [rbp-0x50]
  109796:	72 ad                	jb     109745 <kgfx_draw_log_if_dirty+0x127>
    for(size_t i = 0; i < total_lines_to_draw; i++){
  109798:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10979d:	8b 45 d4             	mov    eax,DWORD PTR [rbp-0x2c]
  1097a0:	48 3b 45 f8          	cmp    rax,QWORD PTR [rbp-0x8]
  1097a4:	0f 87 25 ff ff ff    	ja     1096cf <kgfx_draw_log_if_dirty+0xb1>
      }
    }

    size_t input_buffer_to_write = min(total_column_count, log->input_buffer_count);
  1097aa:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  1097ae:	48 8b 90 18 05 01 00 	mov    rdx,QWORD PTR [rax+0x10518]
  1097b5:	8b 45 dc             	mov    eax,DWORD PTR [rbp-0x24]
  1097b8:	48 39 c2             	cmp    rdx,rax
  1097bb:	48 0f 46 c2          	cmovbe rax,rdx
  1097bf:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
    for(size_t i = 0; i < input_buffer_to_write; i++){
  1097c3:	48 c7 45 e8 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0
  1097ca:	00 
  1097cb:	eb 56                	jmp    109823 <kgfx_draw_log_if_dirty+0x205>
      kgfx_draw_character(log->input_buffer[i], i*CHARACTER_SPACING, (FONT_SIZE+ROW_SPACING)*(max_row_count - 1), fb); 
  1097cd:	8b 15 95 ea ff ff    	mov    edx,DWORD PTR [rip+0xffffffffffffea95]        # 108268 <FONT_SIZE.4143>
  1097d3:	8b 05 93 ea ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffea93]        # 10826c <ROW_SPACING.4144>
  1097d9:	01 c2                	add    edx,eax
  1097db:	8b 45 d8             	mov    eax,DWORD PTR [rbp-0x28]
  1097de:	83 e8 01             	sub    eax,0x1
  1097e1:	0f af c2             	imul   eax,edx
  1097e4:	89 c7                	mov    edi,eax
  1097e6:	8b 05 78 ea ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffea78]        # 108264 <CHARACTER_SPACING.4145>
  1097ec:	89 c0                	mov    eax,eax
  1097ee:	48 0f af 45 e8       	imul   rax,QWORD PTR [rbp-0x18]
  1097f3:	48 89 c6             	mov    rsi,rax
  1097f6:	48 8b 55 98          	mov    rdx,QWORD PTR [rbp-0x68]
  1097fa:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  1097fe:	48 01 d0             	add    rax,rdx
  109801:	48 05 18 04 01 00    	add    rax,0x10418
  109807:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10980a:	0f be c0             	movsx  eax,al
  10980d:	48 8b 55 e0          	mov    rdx,QWORD PTR [rbp-0x20]
  109811:	48 89 d1             	mov    rcx,rdx
  109814:	48 89 fa             	mov    rdx,rdi
  109817:	89 c7                	mov    edi,eax
  109819:	e8 46 fa ff ff       	call   109264 <kgfx_draw_character>
    for(size_t i = 0; i < input_buffer_to_write; i++){
  10981e:	48 83 45 e8 01       	add    QWORD PTR [rbp-0x18],0x1
  109823:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  109827:	48 3b 45 a8          	cmp    rax,QWORD PTR [rbp-0x58]
  10982b:	72 a0                	jb     1097cd <kgfx_draw_log_if_dirty+0x1af>
  10982d:	eb 0f                	jmp    10983e <kgfx_draw_log_if_dirty+0x220>
    }

  } else {
    draw_vga_text_terminal(log);
  10982f:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  109833:	48 89 c7             	mov    rdi,rax
  109836:	e8 34 fc ff ff       	call   10946f <draw_vga_text_terminal>
  10983b:	eb 01                	jmp    10983e <kgfx_draw_log_if_dirty+0x220>
  if(log->is_dirty == false) return;
  10983d:	90                   	nop
  }
  10983e:	c9                   	leave  
  10983f:	c3                   	ret    

0000000000109840 <parse_root_system_descriptor>:
//=======================================

static inline
void acpi_parse_rsdt(ACPI_SDT_Header *rsdt, System_Info *info);

void parse_root_system_descriptor(const RSDP_Descriptor_1 *rsdp, System_Info *sys) {
  109840:	55                   	push   rbp
  109841:	48 89 e5             	mov    rbp,rsp
  109844:	48 81 ec 90 00 00 00 	sub    rsp,0x90
  10984b:	48 89 bd 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],rdi
  109852:	48 89 b5 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],rsi
	if((rsdp->signature[0] == 'R' && rsdp->signature[1] == 'S' &&
  109859:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  109860:	0f b6 00             	movzx  eax,BYTE PTR [rax]
      rsdp->signature[2] == 'D' && rsdp->signature[3] == ' ' &&
      rsdp->signature[4] == 'P' && rsdp->signature[5] == 'T' &&
      rsdp->signature[6] == 'R' && rsdp->signature[7] == ' ') == 0) {
  109863:	3c 52                	cmp    al,0x52
  109865:	75 70                	jne    1098d7 <parse_root_system_descriptor+0x97>
	if((rsdp->signature[0] == 'R' && rsdp->signature[1] == 'S' &&
  109867:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  10986e:	0f b6 40 01          	movzx  eax,BYTE PTR [rax+0x1]
  109872:	3c 53                	cmp    al,0x53
  109874:	75 61                	jne    1098d7 <parse_root_system_descriptor+0x97>
      rsdp->signature[2] == 'D' && rsdp->signature[3] == ' ' &&
  109876:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  10987d:	0f b6 40 02          	movzx  eax,BYTE PTR [rax+0x2]
	if((rsdp->signature[0] == 'R' && rsdp->signature[1] == 'S' &&
  109881:	3c 44                	cmp    al,0x44
  109883:	75 52                	jne    1098d7 <parse_root_system_descriptor+0x97>
      rsdp->signature[2] == 'D' && rsdp->signature[3] == ' ' &&
  109885:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  10988c:	0f b6 40 03          	movzx  eax,BYTE PTR [rax+0x3]
  109890:	3c 20                	cmp    al,0x20
  109892:	75 43                	jne    1098d7 <parse_root_system_descriptor+0x97>
      rsdp->signature[4] == 'P' && rsdp->signature[5] == 'T' &&
  109894:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  10989b:	0f b6 40 04          	movzx  eax,BYTE PTR [rax+0x4]
      rsdp->signature[2] == 'D' && rsdp->signature[3] == ' ' &&
  10989f:	3c 50                	cmp    al,0x50
  1098a1:	75 34                	jne    1098d7 <parse_root_system_descriptor+0x97>
      rsdp->signature[4] == 'P' && rsdp->signature[5] == 'T' &&
  1098a3:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  1098aa:	0f b6 40 05          	movzx  eax,BYTE PTR [rax+0x5]
  1098ae:	3c 54                	cmp    al,0x54
  1098b0:	75 25                	jne    1098d7 <parse_root_system_descriptor+0x97>
      rsdp->signature[6] == 'R' && rsdp->signature[7] == ' ') == 0) {
  1098b2:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  1098b9:	0f b6 40 06          	movzx  eax,BYTE PTR [rax+0x6]
      rsdp->signature[4] == 'P' && rsdp->signature[5] == 'T' &&
  1098bd:	3c 52                	cmp    al,0x52
  1098bf:	75 16                	jne    1098d7 <parse_root_system_descriptor+0x97>
      rsdp->signature[6] == 'R' && rsdp->signature[7] == ' ') == 0) {
  1098c1:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  1098c8:	0f b6 40 07          	movzx  eax,BYTE PTR [rax+0x7]
  1098cc:	3c 20                	cmp    al,0x20
  1098ce:	75 07                	jne    1098d7 <parse_root_system_descriptor+0x97>
  1098d0:	b8 01 00 00 00       	mov    eax,0x1
  1098d5:	eb 05                	jmp    1098dc <parse_root_system_descriptor+0x9c>
  1098d7:	b8 00 00 00 00       	mov    eax,0x0
	if((rsdp->signature[0] == 'R' && rsdp->signature[1] == 'S' &&
  1098dc:	85 c0                	test   eax,eax
  1098de:	75 19                	jne    1098f9 <parse_root_system_descriptor+0xb9>
    klog_error("RSDP is invalid!");
  1098e0:	be 40 60 10 00       	mov    esi,0x106040
  1098e5:	bf 00 e0 10 00       	mov    edi,0x10e000
  1098ea:	b8 00 00 00 00       	mov    eax,0x0
  1098ef:	e8 03 34 00 00       	call   10ccf7 <klog_write_fmt>
    return;
  1098f4:	e9 51 02 00 00       	jmp    109b4a <parse_root_system_descriptor+0x30a>
  } 

  //TODO(Torin) This should be a temporary page!
  uintptr_t virtual_address = 0x0C600000;
  1098f9:	48 c7 45 e8 00 00 60 	mov    QWORD PTR [rbp-0x18],0xc600000
  109900:	0c 
  uintptr_t page_offset = kmem_map_unaligned_physical_to_aligned_virtual_2MB(rsdp->rsdt_address, virtual_address); 
  109901:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  109908:	8b 40 10             	mov    eax,DWORD PTR [rax+0x10]
  10990b:	89 c2                	mov    edx,eax
  10990d:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  109911:	48 89 c6             	mov    rsi,rax
  109914:	48 89 d7             	mov    rdi,rdx
  109917:	e8 71 12 00 00       	call   10ab8d <kmem_map_unaligned_physical_to_aligned_virtual_2MB>
  10991c:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
  ACPI_SDT_Header *rsdt = (ACPI_SDT_Header *)(virtual_address + page_offset);
  109920:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  109924:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  109928:	48 01 d0             	add    rax,rdx
  10992b:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
  uint32_t entry_count = (rsdt->length - sizeof(ACPI_SDT_Header)) / 4;
  10992f:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109933:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
  109936:	89 c0                	mov    eax,eax
  109938:	48 83 e8 24          	sub    rax,0x24
  10993c:	48 c1 e8 02          	shr    rax,0x2
  109940:	89 45 d4             	mov    DWORD PTR [rbp-0x2c],eax
  uint32_t *entries = (uint32_t *)(rsdt + 1);
  109943:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109947:	48 83 c0 24          	add    rax,0x24
  10994b:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
  for(size_t i = 0; i < entry_count; i++){
  10994f:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  109956:	00 
  109957:	e9 e1 01 00 00       	jmp    109b3d <parse_root_system_descriptor+0x2fd>
    uintptr_t header_physical_addr = (uintptr_t)entries[i];
  10995c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109960:	48 8d 14 85 00 00 00 	lea    rdx,[rax*4+0x0]
  109967:	00 
  109968:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  10996c:	48 01 d0             	add    rax,rdx
  10996f:	8b 00                	mov    eax,DWORD PTR [rax]
  109971:	89 c0                	mov    eax,eax
  109973:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
    int64_t physical_offset = header_physical_addr - rsdp->rsdt_address;
  109977:	48 8b 85 78 ff ff ff 	mov    rax,QWORD PTR [rbp-0x88]
  10997e:	8b 40 10             	mov    eax,DWORD PTR [rax+0x10]
  109981:	89 c2                	mov    edx,eax
  109983:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  109987:	48 29 d0             	sub    rax,rdx
  10998a:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
    uintptr_t entry_address = virtual_address + page_offset + physical_offset;
  10998e:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  109992:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  109996:	48 01 c2             	add    rdx,rax
  109999:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10999d:	48 01 d0             	add    rax,rdx
  1099a0:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
    ACPI_SDT_Header *header = (ACPI_SDT_Header *)entry_address;
  1099a4:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  1099a8:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax

    static const uint32_t ACPI_MADT_SIGNATURE = ('C' << 24) | ('I' << 16) | ('P' << 8) | ('A');
    static const uint32_t ACPI_MCFG_SIGNATURE = ('G' << 24) | ('F' << 16) | ('C' << 8) | ('M');
    
    if(header->signature == ACPI_MADT_SIGNATURE) {
  1099ac:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1099b0:	8b 10                	mov    edx,DWORD PTR [rax]
  1099b2:	8b 05 bc e8 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe8bc]        # 108274 <ACPI_MADT_SIGNATURE.4209>
  1099b8:	39 c2                	cmp    edx,eax
  1099ba:	0f 85 54 01 00 00    	jne    109b14 <parse_root_system_descriptor+0x2d4>
      typedef struct {
        ACPI_SDT_Header header;
        uint32_t local_controler_address;
        uint32_t flags;
      } __attribute__((packed)) MADT;
      MADT *madt = (MADT *)header;
  1099c0:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  1099c4:	48 89 45 a0          	mov    QWORD PTR [rbp-0x60],rax
      typedef struct {
        uint8_t entry_type;
        uint8_t entry_length;
      } MADT_Entry_Header;

      sys->lapic_physical_address = madt->local_controler_address;
  1099c8:	48 8b 45 a0          	mov    rax,QWORD PTR [rbp-0x60]
  1099cc:	8b 40 24             	mov    eax,DWORD PTR [rax+0x24]
  1099cf:	89 c2                	mov    edx,eax
  1099d1:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  1099d8:	48 89 10             	mov    QWORD PTR [rax],rdx

      MADT_Entry_Header *madt_entry = (MADT_Entry_Header *)(madt + 1);
  1099db:	48 8b 45 a0          	mov    rax,QWORD PTR [rbp-0x60]
  1099df:	48 83 c0 2c          	add    rax,0x2c
  1099e3:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
      while(((uintptr_t)madt_entry - (uintptr_t)madt) < madt->header.length) 
  1099e7:	e9 09 01 00 00       	jmp    109af5 <parse_root_system_descriptor+0x2b5>
          PROCESSOR_LOCAL_APIC = 0,
          IO_APIC = 1,
          INTERRUPT_SOURCE_OVERRIDE = 2,
        };
        
        switch(madt_entry->entry_type){
  1099ec:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  1099f0:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  1099f3:	0f b6 c0             	movzx  eax,al
  1099f6:	83 f8 01             	cmp    eax,0x1
  1099f9:	0f 84 9b 00 00 00    	je     109a9a <parse_root_system_descriptor+0x25a>
  1099ff:	83 f8 02             	cmp    eax,0x2
  109a02:	0f 84 d6 00 00 00    	je     109ade <parse_root_system_descriptor+0x29e>
  109a08:	85 c0                	test   eax,eax
  109a0a:	0f 85 cf 00 00 00    	jne    109adf <parse_root_system_descriptor+0x29f>
          case PROCESSOR_LOCAL_APIC: {
            MADT_Entry_Processor_Local_APIC * local_apic = (MADT_Entry_Processor_Local_APIC *)madt_entry; 
  109a10:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109a14:	48 89 45 98          	mov    QWORD PTR [rbp-0x68],rax
            bool is_apic_enabled = local_apic->flags & 0b1;
  109a18:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  109a1c:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
  109a1f:	83 e0 01             	and    eax,0x1
  109a22:	85 c0                	test   eax,eax
  109a24:	0f 95 c0             	setne  al
  109a27:	88 45 97             	mov    BYTE PTR [rbp-0x69],al
            //klog_debug("[acpi] lapic: processor_id: %u apic_id: %u is %s", local_apic->processor_id, local_apic->apic_id, is_apic_enabled ? "enabled" : "disabled");

            if(sys->cpu_count < ARRAY_COUNT(sys->cpu_lapic_ids)){
  109a2a:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  109a31:	8b 80 a8 00 00 00    	mov    eax,DWORD PTR [rax+0xa8]
  109a37:	83 f8 1f             	cmp    eax,0x1f
  109a3a:	77 48                	ja     109a84 <parse_root_system_descriptor+0x244>
              sys->cpu_lapic_ids[sys->cpu_count] = local_apic->apic_id;
  109a3c:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  109a43:	8b 88 a8 00 00 00    	mov    ecx,DWORD PTR [rax+0xa8]
  109a49:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
  109a4d:	0f b6 40 03          	movzx  eax,BYTE PTR [rax+0x3]
  109a51:	0f b6 d0             	movzx  edx,al
  109a54:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  109a5b:	89 c9                	mov    ecx,ecx
  109a5d:	48 83 c1 08          	add    rcx,0x8
  109a61:	89 54 88 08          	mov    DWORD PTR [rax+rcx*4+0x8],edx
              sys->cpu_count++;
  109a65:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  109a6c:	8b 80 a8 00 00 00    	mov    eax,DWORD PTR [rax+0xa8]
  109a72:	8d 50 01             	lea    edx,[rax+0x1]
  109a75:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  109a7c:	89 90 a8 00 00 00    	mov    DWORD PTR [rax+0xa8],edx
            } else {
              klog_warning("only 32 cpus are currently supported!");
            }
          } break;
  109a82:	eb 5b                	jmp    109adf <parse_root_system_descriptor+0x29f>
              klog_warning("only 32 cpus are currently supported!");
  109a84:	be 58 60 10 00       	mov    esi,0x106058
  109a89:	bf 00 e0 10 00       	mov    edi,0x10e000
  109a8e:	b8 00 00 00 00       	mov    eax,0x0
  109a93:	e8 5f 32 00 00       	call   10ccf7 <klog_write_fmt>
          } break;
  109a98:	eb 45                	jmp    109adf <parse_root_system_descriptor+0x29f>
              uint32_t io_apic_address;
              uint32_t global_system_interrupt_base;
            } MADT_Entry_IO_APIC;

            
            MADT_Entry_IO_APIC *ioapic = (MADT_Entry_IO_APIC *)madt_entry;
  109a9a:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109a9e:	48 89 45 88          	mov    QWORD PTR [rbp-0x78],rax
            //klog_info("[acpi] ioapic id: %u", (uint32_t)ioapic->io_apic_id);
            //klog_info("[acpi] ioapic physical address: %u", ioapic->io_apic_address);

            if(sys->ioapic_physical_address != 0){
  109aa2:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  109aa9:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  109aad:	48 85 c0             	test   rax,rax
  109ab0:	74 16                	je     109ac8 <parse_root_system_descriptor+0x288>
              klog_warning("[acpi] system contains multiple ioapics");
  109ab2:	be 80 60 10 00       	mov    esi,0x106080
  109ab7:	bf 00 e0 10 00       	mov    edi,0x10e000
  109abc:	b8 00 00 00 00       	mov    eax,0x0
  109ac1:	e8 31 32 00 00       	call   10ccf7 <klog_write_fmt>
            } else {
              sys->ioapic_physical_address = ioapic->io_apic_address;
            }


          }break;
  109ac6:	eb 17                	jmp    109adf <parse_root_system_descriptor+0x29f>
              sys->ioapic_physical_address = ioapic->io_apic_address;
  109ac8:	48 8b 45 88          	mov    rax,QWORD PTR [rbp-0x78]
  109acc:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
  109acf:	89 c2                	mov    edx,eax
  109ad1:	48 8b 85 70 ff ff ff 	mov    rax,QWORD PTR [rbp-0x90]
  109ad8:	48 89 50 08          	mov    QWORD PTR [rax+0x8],rdx
          }break;
  109adc:	eb 01                	jmp    109adf <parse_root_system_descriptor+0x29f>
          case INTERRUPT_SOURCE_OVERRIDE:{
          }break;
  109ade:	90                   	nop
        }

        madt_entry = (MADT_Entry_Header *)((uintptr_t)madt_entry + madt_entry->entry_length); 
  109adf:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109ae3:	0f b6 40 01          	movzx  eax,BYTE PTR [rax+0x1]
  109ae7:	0f b6 d0             	movzx  edx,al
  109aea:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  109aee:	48 01 d0             	add    rax,rdx
  109af1:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
      while(((uintptr_t)madt_entry - (uintptr_t)madt) < madt->header.length) 
  109af5:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  109af9:	48 8b 45 a0          	mov    rax,QWORD PTR [rbp-0x60]
  109afd:	48 29 c2             	sub    rdx,rax
  109b00:	48 8b 45 a0          	mov    rax,QWORD PTR [rbp-0x60]
  109b04:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
  109b07:	89 c0                	mov    eax,eax
  109b09:	48 39 c2             	cmp    rdx,rax
  109b0c:	0f 82 da fe ff ff    	jb     1099ec <parse_root_system_descriptor+0x1ac>
  109b12:	eb 24                	jmp    109b38 <parse_root_system_descriptor+0x2f8>
      }
    } 

    else if (header->signature == ACPI_MCFG_SIGNATURE){
  109b14:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  109b18:	8b 10                	mov    edx,DWORD PTR [rax]
  109b1a:	8b 05 58 e7 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe758]        # 108278 <ACPI_MCFG_SIGNATURE.4210>
  109b20:	39 c2                	cmp    edx,eax
  109b22:	75 14                	jne    109b38 <parse_root_system_descriptor+0x2f8>
      klog_debug("found MCFG ACPI table");
  109b24:	be a8 60 10 00       	mov    esi,0x1060a8
  109b29:	bf 00 e0 10 00       	mov    edi,0x10e000
  109b2e:	b8 00 00 00 00       	mov    eax,0x0
  109b33:	e8 bf 31 00 00       	call   10ccf7 <klog_write_fmt>
  for(size_t i = 0; i < entry_count; i++){
  109b38:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  109b3d:	8b 45 d4             	mov    eax,DWORD PTR [rbp-0x2c]
  109b40:	48 3b 45 f8          	cmp    rax,QWORD PTR [rbp-0x8]
  109b44:	0f 87 12 fe ff ff    	ja     10995c <parse_root_system_descriptor+0x11c>
    }


  }  
}
  109b4a:	c9                   	leave  
  109b4b:	c3                   	ret    

0000000000109b4c <ioapic_write_register>:
typedef struct IOAPIC_IRQR_LOW_STRUCT IOAPIC_IRQR_LOW;
typedef struct IOAPIC_IRQR_HIGH_STRUCT IOAPIC_IRQR_HIGH;


static inline
void ioapic_write_register(const uintptr_t ioapic_base, const uint8_t offset, const uint32_t value){
  109b4c:	55                   	push   rbp
  109b4d:	48 89 e5             	mov    rbp,rsp
  109b50:	48 83 ec 20          	sub    rsp,0x20
  109b54:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  109b58:	89 f0                	mov    eax,esi
  109b5a:	89 55 e0             	mov    DWORD PTR [rbp-0x20],edx
  109b5d:	88 45 e4             	mov    BYTE PTR [rbp-0x1c],al
  uint32_t volatile *ioapic = (uint32_t volatile *)ioapic_base;
  109b60:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  109b64:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  ioapic[0] = offset;
  109b68:	0f b6 55 e4          	movzx  edx,BYTE PTR [rbp-0x1c]
  109b6c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109b70:	89 10                	mov    DWORD PTR [rax],edx
  ioapic[4] = value;
  109b72:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109b76:	48 8d 50 10          	lea    rdx,[rax+0x10]
  109b7a:	8b 45 e0             	mov    eax,DWORD PTR [rbp-0x20]
  109b7d:	89 02                	mov    DWORD PTR [rdx],eax
}
  109b7f:	90                   	nop
  109b80:	c9                   	leave  
  109b81:	c3                   	ret    

0000000000109b82 <ioapic_read_register>:

static inline
uint32_t ioapic_read_register(const uintptr_t ioapic_base, const uint8_t offset){
  109b82:	55                   	push   rbp
  109b83:	48 89 e5             	mov    rbp,rsp
  109b86:	48 83 ec 20          	sub    rsp,0x20
  109b8a:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  109b8e:	89 f0                	mov    eax,esi
  109b90:	88 45 e4             	mov    BYTE PTR [rbp-0x1c],al
  uint32_t volatile *ioapic = (uint32_t volatile*)ioapic_base;
  109b93:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  109b97:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  ioapic[0] = offset;
  109b9b:	0f b6 55 e4          	movzx  edx,BYTE PTR [rbp-0x1c]
  109b9f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109ba3:	89 10                	mov    DWORD PTR [rax],edx
  return ioapic[4];
  109ba5:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109ba9:	48 83 c0 10          	add    rax,0x10
  109bad:	8b 00                	mov    eax,DWORD PTR [rax]
}
  109baf:	c9                   	leave  
  109bb0:	c3                   	ret    

0000000000109bb1 <lapic_write_register>:

static inline
void lapic_write_register(uintptr_t lapic_base, uintptr_t register_offset, uint32_t value){
  109bb1:	55                   	push   rbp
  109bb2:	48 89 e5             	mov    rbp,rsp
  109bb5:	48 83 ec 28          	sub    rsp,0x28
  109bb9:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  109bbd:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  109bc1:	89 55 dc             	mov    DWORD PTR [rbp-0x24],edx
  uint32_t volatile *lapic = (uint32_t volatile *)(lapic_base + register_offset);
  109bc4:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  109bc8:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  109bcc:	48 01 d0             	add    rax,rdx
  109bcf:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  lapic[0] = value;
  109bd3:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109bd7:	8b 55 dc             	mov    edx,DWORD PTR [rbp-0x24]
  109bda:	89 10                	mov    DWORD PTR [rax],edx
}
  109bdc:	90                   	nop
  109bdd:	c9                   	leave  
  109bde:	c3                   	ret    

0000000000109bdf <ioapic_initalize>:

static void
ioapic_initalize(uintptr_t ioapic_register_base) {
  109bdf:	55                   	push   rbp
  109be0:	48 89 e5             	mov    rbp,rsp
  109be3:	48 83 ec 28          	sub    rsp,0x28
  109be7:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  asm volatile("cli");
  109beb:	fa                   	cli    
  static const uint8_t DELIVERY_MODE_FIXED = 0x00;
  //NOTE(Torin) Keyboard
  IOAPIC_IRQR_LOW low = {};
  109bec:	c7 45 f0 00 00 00 00 	mov    DWORD PTR [rbp-0x10],0x0
  IOAPIC_IRQR_HIGH high = {};
  109bf3:	c7 45 e0 00 00 00 00 	mov    DWORD PTR [rbp-0x20],0x0
  low.vector = 0x21;
  109bfa:	c6 45 f0 21          	mov    BYTE PTR [rbp-0x10],0x21
  ioapic_write_register(ioapic_register_base, 0x12, low.packed);
  109bfe:	8b 55 f0             	mov    edx,DWORD PTR [rbp-0x10]
  109c01:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109c05:	be 12 00 00 00       	mov    esi,0x12
  109c0a:	48 89 c7             	mov    rdi,rax
  109c0d:	e8 3a ff ff ff       	call   109b4c <ioapic_write_register>
  ioapic_write_register(ioapic_register_base, 0x13, high.packed);
  109c12:	8b 55 e0             	mov    edx,DWORD PTR [rbp-0x20]
  109c15:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109c19:	be 13 00 00 00       	mov    esi,0x13
  109c1e:	48 89 c7             	mov    rdi,rax
  109c21:	e8 26 ff ff ff       	call   109b4c <ioapic_write_register>
  asm volatile("sti");
  109c26:	fb                   	sti    
}
  109c27:	90                   	nop
  109c28:	c9                   	leave  
  109c29:	c3                   	ret    

0000000000109c2a <lapic_initalize>:

static void
lapic_initalize(uintptr_t apic_register_base) {
  109c2a:	55                   	push   rbp
  109c2b:	48 89 e5             	mov    rbp,rsp
  109c2e:	48 83 ec 08          	sub    rsp,0x8
  109c32:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
	asm volatile ("cli");
  109c36:	fa                   	cli    
  //enable it fully using the other legacy routine.  Should simplify code
  //and keep everything nice an compact since we will never support a cpu
  //that does not have an APIC
  static const uint8_t PIC1_DATA_PORT = 0x21;
  static const uint8_t PIC2_DATA_PORT = 0xA1;
  write_port_uint8(PIC1_DATA_PORT, 0b11111111);
  109c37:	0f b6 05 3f e6 ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffe63f]        # 10827d <PIC1_DATA_PORT.4323>
  109c3e:	0f b6 c0             	movzx  eax,al
  109c41:	be ff 00 00 00       	mov    esi,0xff
  109c46:	89 c7                	mov    edi,eax
  109c48:	e8 bc f5 ff ff       	call   109209 <write_port_uint8>
  write_port_uint8(PIC2_DATA_PORT, 0b11111111);
  109c4d:	0f b6 05 2a e6 ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffe62a]        # 10827e <PIC2_DATA_PORT.4324>
  109c54:	0f b6 c0             	movzx  eax,al
  109c57:	be ff 00 00 00       	mov    esi,0xff
  109c5c:	89 c7                	mov    edi,eax
  109c5e:	e8 a6 f5 ff ff       	call   109209 <write_port_uint8>
  //NOTE(Torin) Configure lapic spuritous interput vector
  //TODO(Torin) I dont think that this is configured correctly
  static const uint64_t APIC_SIVR_OFFSET = 0xF0;
  static const uint32_t SIVR_ENABLE = 1 << 8;
  static const uint32_t SIVR_FOCUS_CHECKING = 1 << 9;
  lapic_write_register(apic_register_base, APIC_SIVR_OFFSET, 0xFF);
  109c63:	48 8b 0d 16 e6 ff ff 	mov    rcx,QWORD PTR [rip+0xffffffffffffe616]        # 108280 <APIC_SIVR_OFFSET.4325>
  109c6a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109c6e:	ba ff 00 00 00       	mov    edx,0xff
  109c73:	48 89 ce             	mov    rsi,rcx
  109c76:	48 89 c7             	mov    rdi,rax
  109c79:	e8 33 ff ff ff       	call   109bb1 <lapic_write_register>
	asm volatile("sti");
  109c7e:	fb                   	sti    
}
  109c7f:	90                   	nop
  109c80:	c9                   	leave  
  109c81:	c3                   	ret    

0000000000109c82 <lapic_enable_timer>:

//TODO(Torin 2016-08-29) Change this to an lapic_configure_timer procedure
static void
lapic_enable_timer(uintptr_t lapic_base){
  109c82:	55                   	push   rbp
  109c83:	48 89 e5             	mov    rbp,rsp
  109c86:	48 83 ec 08          	sub    rsp,0x8
  109c8a:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  static const uint32_t TIMER_DIVIDE_BY_16 = 0b11;

  //NOTE(Torin) Without this flag the timer is in one-shot mode 
  static const uint32_t TIMER_PERIODIC_MODE = 0x20000;

  lapic_write_register(lapic_base, TIMER_INITAL_COUNT_REGISTER, 0xFFFFF);
  109c8e:	8b 05 fc e5 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe5fc]        # 108290 <TIMER_INITAL_COUNT_REGISTER.4332>
  109c94:	89 c1                	mov    ecx,eax
  109c96:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109c9a:	ba ff ff 0f 00       	mov    edx,0xfffff
  109c9f:	48 89 ce             	mov    rsi,rcx
  109ca2:	48 89 c7             	mov    rdi,rax
  109ca5:	e8 07 ff ff ff       	call   109bb1 <lapic_write_register>
  lapic_write_register(lapic_base, TIMER_DIVIDE_CONFIG_REGISTER, TIMER_DIVIDE_BY_16);
  109caa:	8b 15 e4 e5 ff ff    	mov    edx,DWORD PTR [rip+0xffffffffffffe5e4]        # 108294 <TIMER_DIVIDE_BY_16.4338>
  109cb0:	8b 05 e2 e5 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe5e2]        # 108298 <TIMER_DIVIDE_CONFIG_REGISTER.4334>
  109cb6:	89 c1                	mov    ecx,eax
  109cb8:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109cbc:	48 89 ce             	mov    rsi,rcx
  109cbf:	48 89 c7             	mov    rdi,rax
  109cc2:	e8 ea fe ff ff       	call   109bb1 <lapic_write_register>
  lapic_write_register(lapic_base, TIMER_IRQ_REGISTER, 0x20 | TIMER_PERIODIC_MODE);
  109cc7:	8b 05 cf e5 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe5cf]        # 10829c <TIMER_PERIODIC_MODE.4339>
  109ccd:	83 c8 20             	or     eax,0x20
  109cd0:	89 c2                	mov    edx,eax
  109cd2:	8b 05 c8 e5 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffe5c8]        # 1082a0 <TIMER_IRQ_REGISTER.4331>
  109cd8:	89 c1                	mov    ecx,eax
  109cda:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  109cde:	48 89 ce             	mov    rsi,rcx
  109ce1:	48 89 c7             	mov    rdi,rax
  109ce4:	e8 c8 fe ff ff       	call   109bb1 <lapic_write_register>
  bochs_magic_breakpoint;
  109ce9:	66 87 db             	xchg   bx,bx
}
  109cec:	90                   	nop
  109ced:	c9                   	leave  
  109cee:	c3                   	ret    

0000000000109cef <lapic_startup_ap>:

//NOTE(Torin) Called from the bootstrap processor to send A SIPI signal to the target application processor 
static void 
lapic_startup_ap(uintptr_t apic_register_base, uint8_t target_apic_id, uint8_t target_page_number){
  109cef:	55                   	push   rbp
  109cf0:	48 89 e5             	mov    rbp,rsp
  109cf3:	48 83 ec 40          	sub    rsp,0x40
  109cf7:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  109cfb:	89 f1                	mov    ecx,esi
  109cfd:	89 d0                	mov    eax,edx
  109cff:	88 4d c4             	mov    BYTE PTR [rbp-0x3c],cl
  109d02:	88 45 c0             	mov    BYTE PTR [rbp-0x40],al
  } __attribute((packed));

  typedef struct ICR1_STRUCT ICR1_Register;
  typedef struct ICR2_STRUCT ICR2_Register;

  ICR1_Register icr1 = {};
  109d05:	c7 45 e0 00 00 00 00 	mov    DWORD PTR [rbp-0x20],0x0
  icr1.delivery_mode = DELIVERY_MODE_INIT;
  109d0c:	0f b6 05 a1 e5 ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffe5a1]        # 1082b4 <DELIVERY_MODE_INIT.4351>
  109d13:	83 e0 07             	and    eax,0x7
  109d16:	83 e0 07             	and    eax,0x7
  109d19:	89 c2                	mov    edx,eax
  109d1b:	0f b6 45 e1          	movzx  eax,BYTE PTR [rbp-0x1f]
  109d1f:	83 e0 f8             	and    eax,0xfffffff8
  109d22:	09 d0                	or     eax,edx
  109d24:	88 45 e1             	mov    BYTE PTR [rbp-0x1f],al
  ICR2_Register icr2 = {};
  109d27:	c7 45 d0 00 00 00 00 	mov    DWORD PTR [rbp-0x30],0x0
  icr2.destination_field = target_apic_id;
  109d2e:	0f b6 45 c4          	movzx  eax,BYTE PTR [rbp-0x3c]
  109d32:	88 45 d3             	mov    BYTE PTR [rbp-0x2d],al

  //NOTE(Torin) Writing to the ICR1 causues a IPI to be generated automaticly so ICR2 is written first
  //Send INIT IPI To set processor to wait for SIPI

  uint32_t icr2_value = *(uint32_t *)&icr2;
  109d35:	48 8d 45 d0          	lea    rax,[rbp-0x30]
  109d39:	8b 00                	mov    eax,DWORD PTR [rax]
  109d3b:	89 45 ec             	mov    DWORD PTR [rbp-0x14],eax
  uint32_t icr1_value = *(uint32_t *)&icr1;
  109d3e:	48 8d 45 e0          	lea    rax,[rbp-0x20]
  109d42:	8b 00                	mov    eax,DWORD PTR [rax]
  109d44:	89 45 e8             	mov    DWORD PTR [rbp-0x18],eax
  klog_debug("icr2_value: %u", icr2_value);
  109d47:	8b 45 ec             	mov    eax,DWORD PTR [rbp-0x14]
  109d4a:	89 c2                	mov    edx,eax
  109d4c:	be be 60 10 00       	mov    esi,0x1060be
  109d51:	bf 00 e0 10 00       	mov    edi,0x10e000
  109d56:	b8 00 00 00 00       	mov    eax,0x0
  109d5b:	e8 97 2f 00 00       	call   10ccf7 <klog_write_fmt>
  klog_debug("icr1_value: %u", icr1_value);
  109d60:	8b 45 e8             	mov    eax,DWORD PTR [rbp-0x18]
  109d63:	89 c2                	mov    edx,eax
  109d65:	be cd 60 10 00       	mov    esi,0x1060cd
  109d6a:	bf 00 e0 10 00       	mov    edi,0x10e000
  109d6f:	b8 00 00 00 00       	mov    eax,0x0
  109d74:	e8 7e 2f 00 00       	call   10ccf7 <klog_write_fmt>

  lapic_write_register(apic_register_base, APIC_ICR2_OFFSET, *(uint32_t *)&icr2);
  109d79:	48 8d 45 d0          	lea    rax,[rbp-0x30]
  109d7d:	8b 10                	mov    edx,DWORD PTR [rax]
  109d7f:	48 8b 0d 32 e5 ff ff 	mov    rcx,QWORD PTR [rip+0xffffffffffffe532]        # 1082b8 <APIC_ICR2_OFFSET.4346>
  109d86:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  109d8a:	48 89 ce             	mov    rsi,rcx
  109d8d:	48 89 c7             	mov    rdi,rax
  109d90:	e8 1c fe ff ff       	call   109bb1 <lapic_write_register>
  lapic_write_register(apic_register_base, APIC_ICR1_OFFSET, *(uint32_t *)&icr1);
  109d95:	48 8d 45 e0          	lea    rax,[rbp-0x20]
  109d99:	8b 10                	mov    edx,DWORD PTR [rax]
  109d9b:	48 8b 0d 1e e5 ff ff 	mov    rcx,QWORD PTR [rip+0xffffffffffffe51e]        # 1082c0 <APIC_ICR1_OFFSET.4345>
  109da2:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  109da6:	48 89 ce             	mov    rsi,rcx
  109da9:	48 89 c7             	mov    rdi,rax
  109dac:	e8 00 fe ff ff       	call   109bb1 <lapic_write_register>
  while(icr1.delivery_status == 1){
  109db1:	eb 14                	jmp    109dc7 <lapic_startup_ap+0xd8>
    klog_debug("waiting for icr1 to get delivered!");
  109db3:	be e0 60 10 00       	mov    esi,0x1060e0
  109db8:	bf 00 e0 10 00       	mov    edi,0x10e000
  109dbd:	b8 00 00 00 00       	mov    eax,0x0
  109dc2:	e8 30 2f 00 00       	call   10ccf7 <klog_write_fmt>
  while(icr1.delivery_status == 1){
  109dc7:	0f b6 45 e1          	movzx  eax,BYTE PTR [rbp-0x1f]
  109dcb:	83 e0 10             	and    eax,0x10
  109dce:	84 c0                	test   al,al
  109dd0:	75 e1                	jne    109db3 <lapic_startup_ap+0xc4>
  }

  for(size_t i = 0; i < 0xFFFFF; i++) { asm volatile ( "nop" ); }
  109dd2:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  109dd9:	00 
  109dda:	eb 06                	jmp    109de2 <lapic_startup_ap+0xf3>
  109ddc:	90                   	nop
  109ddd:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  109de2:	48 81 7d f8 fe ff 0f 	cmp    QWORD PTR [rbp-0x8],0xffffe
  109de9:	00 
  109dea:	76 f0                	jbe    109ddc <lapic_startup_ap+0xed>

  //Setup and send SIPI
  icr1.vector = target_page_number; 
  109dec:	0f b6 45 c0          	movzx  eax,BYTE PTR [rbp-0x40]
  109df0:	88 45 e0             	mov    BYTE PTR [rbp-0x20],al
  icr1.delivery_mode = DELIVERY_MODE_SIPI;
  109df3:	0f b6 05 ce e4 ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffe4ce]        # 1082c8 <DELIVERY_MODE_SIPI.4352>
  109dfa:	83 e0 07             	and    eax,0x7
  109dfd:	83 e0 07             	and    eax,0x7
  109e00:	89 c2                	mov    edx,eax
  109e02:	0f b6 45 e1          	movzx  eax,BYTE PTR [rbp-0x1f]
  109e06:	83 e0 f8             	and    eax,0xfffffff8
  109e09:	09 d0                	or     eax,edx
  109e0b:	88 45 e1             	mov    BYTE PTR [rbp-0x1f],al
  lapic_write_register(apic_register_base, APIC_ICR2_OFFSET, *(uint32_t *)&icr2);
  109e0e:	48 8d 45 d0          	lea    rax,[rbp-0x30]
  109e12:	8b 10                	mov    edx,DWORD PTR [rax]
  109e14:	48 8b 0d 9d e4 ff ff 	mov    rcx,QWORD PTR [rip+0xffffffffffffe49d]        # 1082b8 <APIC_ICR2_OFFSET.4346>
  109e1b:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  109e1f:	48 89 ce             	mov    rsi,rcx
  109e22:	48 89 c7             	mov    rdi,rax
  109e25:	e8 87 fd ff ff       	call   109bb1 <lapic_write_register>
  lapic_write_register(apic_register_base, APIC_ICR1_OFFSET, *(uint32_t *)&icr1);
  109e2a:	48 8d 45 e0          	lea    rax,[rbp-0x20]
  109e2e:	8b 10                	mov    edx,DWORD PTR [rax]
  109e30:	48 8b 0d 89 e4 ff ff 	mov    rcx,QWORD PTR [rip+0xffffffffffffe489]        # 1082c0 <APIC_ICR1_OFFSET.4345>
  109e37:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  109e3b:	48 89 ce             	mov    rsi,rcx
  109e3e:	48 89 c7             	mov    rdi,rax
  109e41:	e8 6b fd ff ff       	call   109bb1 <lapic_write_register>
  for(size_t i = 0; i < 0xFFFFF; i++) { asm volatile ( "nop" ); }
  109e46:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
  109e4d:	00 
  109e4e:	eb 06                	jmp    109e56 <lapic_startup_ap+0x167>
  109e50:	90                   	nop
  109e51:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  109e56:	48 81 7d f0 fe ff 0f 	cmp    QWORD PTR [rbp-0x10],0xffffe
  109e5d:	00 
  109e5e:	76 f0                	jbe    109e50 <lapic_startup_ap+0x161>
  lapic_write_register(apic_register_base, APIC_ICR2_OFFSET, *(uint32_t *)&icr2);
  109e60:	48 8d 45 d0          	lea    rax,[rbp-0x30]
  109e64:	8b 10                	mov    edx,DWORD PTR [rax]
  109e66:	48 8b 0d 4b e4 ff ff 	mov    rcx,QWORD PTR [rip+0xffffffffffffe44b]        # 1082b8 <APIC_ICR2_OFFSET.4346>
  109e6d:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  109e71:	48 89 ce             	mov    rsi,rcx
  109e74:	48 89 c7             	mov    rdi,rax
  109e77:	e8 35 fd ff ff       	call   109bb1 <lapic_write_register>
  lapic_write_register(apic_register_base, APIC_ICR1_OFFSET, *(uint32_t *)&icr1);
  109e7c:	48 8d 45 e0          	lea    rax,[rbp-0x20]
  109e80:	8b 10                	mov    edx,DWORD PTR [rax]
  109e82:	48 8b 0d 37 e4 ff ff 	mov    rcx,QWORD PTR [rip+0xffffffffffffe437]        # 1082c0 <APIC_ICR1_OFFSET.4345>
  109e89:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  109e8d:	48 89 ce             	mov    rsi,rcx
  109e90:	48 89 c7             	mov    rdi,rax
  109e93:	e8 19 fd ff ff       	call   109bb1 <lapic_write_register>
  109e98:	90                   	nop
  109e99:	c9                   	leave  
  109e9a:	c3                   	ret    

0000000000109e9b <gdt_encode_system_descriptor>:

#define GDT_DESCRIPTOR_TYPE_LDT (0b0010)
#define GDT_DESCRIPTOR_TYPE_TSS (0b1001)

static inline
void gdt_encode_system_descriptor(uintptr_t base_address, uint32_t segment_limit, uint8_t type, uint8_t privlege_level, uintptr_t out){
  109e9b:	55                   	push   rbp
  109e9c:	48 89 e5             	mov    rbp,rsp
  109e9f:	48 83 ec 40          	sub    rsp,0x40
  109ea3:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  109ea7:	89 75 d4             	mov    DWORD PTR [rbp-0x2c],esi
  109eaa:	89 c8                	mov    eax,ecx
  109eac:	4c 89 45 c0          	mov    QWORD PTR [rbp-0x40],r8
  109eb0:	88 55 d0             	mov    BYTE PTR [rbp-0x30],dl
  109eb3:	88 45 cc             	mov    BYTE PTR [rbp-0x34],al
  kassert(segment_limit < (1 << 19));
  109eb6:	81 7d d4 ff ff 07 00 	cmp    DWORD PTR [rbp-0x2c],0x7ffff
  109ebd:	76 30                	jbe    109eef <gdt_encode_system_descriptor+0x54>
  109ebf:	41 b8 03 61 10 00    	mov    r8d,0x106103
  109ec5:	b9 3d 00 00 00       	mov    ecx,0x3d
  109eca:	ba 1b 61 10 00       	mov    edx,0x10611b
  109ecf:	be 38 61 10 00       	mov    esi,0x106138
  109ed4:	bf 00 e0 10 00       	mov    edi,0x10e000
  109ed9:	b8 00 00 00 00       	mov    eax,0x0
  109ede:	e8 14 2e 00 00       	call   10ccf7 <klog_write_fmt>
  109ee3:	bf 00 e0 10 00       	mov    edi,0x10e000
  109ee8:	e8 31 f7 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  109eed:	fa                   	cli    
  109eee:	f4                   	hlt    
  kassert(type < (1 << 4));
  109eef:	80 7d d0 0f          	cmp    BYTE PTR [rbp-0x30],0xf
  109ef3:	76 30                	jbe    109f25 <gdt_encode_system_descriptor+0x8a>
  109ef5:	41 b8 03 61 10 00    	mov    r8d,0x106103
  109efb:	b9 3e 00 00 00       	mov    ecx,0x3e
  109f00:	ba 63 61 10 00       	mov    edx,0x106163
  109f05:	be 38 61 10 00       	mov    esi,0x106138
  109f0a:	bf 00 e0 10 00       	mov    edi,0x10e000
  109f0f:	b8 00 00 00 00       	mov    eax,0x0
  109f14:	e8 de 2d 00 00       	call   10ccf7 <klog_write_fmt>
  109f19:	bf 00 e0 10 00       	mov    edi,0x10e000
  109f1e:	e8 fb f6 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  109f23:	fa                   	cli    
  109f24:	f4                   	hlt    
  kassert(privlege_level < (1 << 2));
  109f25:	80 7d cc 03          	cmp    BYTE PTR [rbp-0x34],0x3
  109f29:	76 30                	jbe    109f5b <gdt_encode_system_descriptor+0xc0>
  109f2b:	41 b8 03 61 10 00    	mov    r8d,0x106103
  109f31:	b9 3f 00 00 00       	mov    ecx,0x3f
  109f36:	ba 73 61 10 00       	mov    edx,0x106173
  109f3b:	be 38 61 10 00       	mov    esi,0x106138
  109f40:	bf 00 e0 10 00       	mov    edi,0x10e000
  109f45:	b8 00 00 00 00       	mov    eax,0x0
  109f4a:	e8 a8 2d 00 00       	call   10ccf7 <klog_write_fmt>
  109f4f:	bf 00 e0 10 00       	mov    edi,0x10e000
  109f54:	e8 c5 f6 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  109f59:	fa                   	cli    
  109f5a:	f4                   	hlt    
    uint16_t base_address_24_31;
    uint32_t base_address_32_63;
    uint32_t reserved1;
  } __attribute__((packed));

  struct GDT_System_Descriptor descriptor = {};
  109f5b:	48 c7 45 e0 00 00 00 	mov    QWORD PTR [rbp-0x20],0x0
  109f62:	00 
  109f63:	48 c7 45 e8 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0
  109f6a:	00 
  109f6b:	c6 45 f0 00          	mov    BYTE PTR [rbp-0x10],0x0
  descriptor.base_address_0_15  = (base_address >> 0) & 0xFFFF;
  109f6f:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109f73:	66 89 45 e2          	mov    WORD PTR [rbp-0x1e],ax
  descriptor.base_address_16_23 = (base_address >> 16) & 0xFF;
  109f77:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109f7b:	48 c1 e8 10          	shr    rax,0x10
  109f7f:	88 45 e4             	mov    BYTE PTR [rbp-0x1c],al
  descriptor.base_address_24_31 = (base_address >> 24) & 0xFF;
  109f82:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109f86:	48 c1 e8 18          	shr    rax,0x18
  109f8a:	0f b6 c0             	movzx  eax,al
  109f8d:	66 89 45 e7          	mov    WORD PTR [rbp-0x19],ax
  descriptor.base_address_32_63 = (base_address >> 32) & 0xFFFFFFFF;
  109f91:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  109f95:	48 c1 e8 20          	shr    rax,0x20
  109f99:	89 45 e9             	mov    DWORD PTR [rbp-0x17],eax

  descriptor.segment_limit_0_15 = (segment_limit >> 0) & 0xFFFF;
  109f9c:	8b 45 d4             	mov    eax,DWORD PTR [rbp-0x2c]
  109f9f:	66 89 45 e0          	mov    WORD PTR [rbp-0x20],ax
  descriptor.segment_limit_16_19 = (segment_limit >> 16) & 0b1111;
  109fa3:	8b 45 d4             	mov    eax,DWORD PTR [rbp-0x2c]
  109fa6:	c1 e8 10             	shr    eax,0x10
  109fa9:	83 e0 0f             	and    eax,0xf
  109fac:	83 e0 0f             	and    eax,0xf
  109faf:	89 c2                	mov    edx,eax
  109fb1:	0f b6 45 e6          	movzx  eax,BYTE PTR [rbp-0x1a]
  109fb5:	83 e0 f0             	and    eax,0xfffffff0
  109fb8:	09 d0                	or     eax,edx
  109fba:	88 45 e6             	mov    BYTE PTR [rbp-0x1a],al

  descriptor.present = 1;
  109fbd:	0f b6 45 e5          	movzx  eax,BYTE PTR [rbp-0x1b]
  109fc1:	83 c8 80             	or     eax,0xffffff80
  109fc4:	88 45 e5             	mov    BYTE PTR [rbp-0x1b],al
  descriptor.available = 1;
  109fc7:	0f b6 45 e6          	movzx  eax,BYTE PTR [rbp-0x1a]
  109fcb:	83 c8 10             	or     eax,0x10
  109fce:	88 45 e6             	mov    BYTE PTR [rbp-0x1a],al
  descriptor.type = type;
  109fd1:	0f b6 45 d0          	movzx  eax,BYTE PTR [rbp-0x30]
  109fd5:	83 e0 0f             	and    eax,0xf
  109fd8:	83 e0 0f             	and    eax,0xf
  109fdb:	89 c2                	mov    edx,eax
  109fdd:	0f b6 45 e5          	movzx  eax,BYTE PTR [rbp-0x1b]
  109fe1:	83 e0 f0             	and    eax,0xfffffff0
  109fe4:	09 d0                	or     eax,edx
  109fe6:	88 45 e5             	mov    BYTE PTR [rbp-0x1b],al
  descriptor.privlege_level = privlege_level;
  109fe9:	0f b6 45 cc          	movzx  eax,BYTE PTR [rbp-0x34]
  109fed:	83 e0 03             	and    eax,0x3
  109ff0:	83 e0 03             	and    eax,0x3
  109ff3:	c1 e0 05             	shl    eax,0x5
  109ff6:	89 c2                	mov    edx,eax
  109ff8:	0f b6 45 e5          	movzx  eax,BYTE PTR [rbp-0x1b]
  109ffc:	83 e0 9f             	and    eax,0xffffff9f
  109fff:	09 d0                	or     eax,edx
  10a001:	88 45 e5             	mov    BYTE PTR [rbp-0x1b],al
  memcpy(out, &descriptor, sizeof(struct GDT_System_Descriptor));
  10a004:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10a008:	48 8d 4d e0          	lea    rcx,[rbp-0x20]
  10a00c:	ba 11 00 00 00       	mov    edx,0x11
  10a011:	48 89 ce             	mov    rsi,rcx
  10a014:	48 89 c7             	mov    rdi,rax
  10a017:	e8 26 f0 ff ff       	call   109042 <__memcpy>

  klog_debug("tss base address: 0x%X", base_address);
  10a01c:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10a020:	48 89 c2             	mov    rdx,rax
  10a023:	be 8d 61 10 00       	mov    esi,0x10618d
  10a028:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a02d:	b8 00 00 00 00       	mov    eax,0x0
  10a032:	e8 c0 2c 00 00       	call   10ccf7 <klog_write_fmt>
  klog_debug("tss limit: 0x%X", segment_limit);
  10a037:	8b 45 d4             	mov    eax,DWORD PTR [rbp-0x2c]
  10a03a:	89 c2                	mov    edx,eax
  10a03c:	be a4 61 10 00       	mov    esi,0x1061a4
  10a041:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a046:	b8 00 00 00 00       	mov    eax,0x0
  10a04b:	e8 a7 2c 00 00       	call   10ccf7 <klog_write_fmt>
}
  10a050:	90                   	nop
  10a051:	c9                   	leave  
  10a052:	c3                   	ret    

000000000010a053 <idt_encode_entry>:

static void
idt_encode_entry(const uintptr_t entry_addr, const uintptr_t handler_addr, const bool is_user_accessible){
  10a053:	55                   	push   rbp
  10a054:	48 89 e5             	mov    rbp,rsp
  10a057:	48 83 ec 28          	sub    rsp,0x28
  10a05b:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10a05f:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  10a063:	89 d0                	mov    eax,edx
  10a065:	88 45 dc             	mov    BYTE PTR [rbp-0x24],al
	
	static const uint64_t TYPE_TASK_GATE_64 = 0x5;
	static const uint64_t TYPE_INTERRUPT_GATE_64 = 0xE;
	static const uint64_t TYPE_TRAP_GATE_64 = 0xF;

  IDT_Entry *entry = (IDT_Entry *)entry_addr;
  10a068:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10a06c:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
	entry->offset_0_15 = (uint16_t)(handler_addr & 0xFFFF);
  10a070:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10a074:	89 c2                	mov    edx,eax
  10a076:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a07a:	66 89 10             	mov    WORD PTR [rax],dx
	entry->offset_16_31 = (uint16_t)((handler_addr >> 16) & 0xFFFF);
  10a07d:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10a081:	48 c1 e8 10          	shr    rax,0x10
  10a085:	89 c2                	mov    edx,eax
  10a087:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a08b:	66 89 50 06          	mov    WORD PTR [rax+0x6],dx
	entry->offset_32_63 = (uint32_t)((handler_addr >> 32) & 0xFFFFFFFF);
  10a08f:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10a093:	48 c1 e8 20          	shr    rax,0x20
  10a097:	89 c2                	mov    edx,eax
  10a099:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a09d:	89 50 08             	mov    DWORD PTR [rax+0x8],edx
	entry->type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | (is_user_accessible ?  PRIVILEGE_LEVEL_3 : PRIVILEGE_LEVEL_0); 
  10a0a0:	48 8b 05 31 e2 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffe231]        # 1082d8 <PRESENT_BIT.4448>
  10a0a7:	89 c2                	mov    edx,eax
  10a0a9:	48 8b 05 30 e2 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffe230]        # 1082e0 <TYPE_INTERRUPT_GATE_64.4450>
  10a0b0:	09 c2                	or     edx,eax
  10a0b2:	80 7d dc 00          	cmp    BYTE PTR [rbp-0x24],0x0
  10a0b6:	74 09                	je     10a0c1 <idt_encode_entry+0x6e>
  10a0b8:	48 8b 05 29 e2 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffe229]        # 1082e8 <PRIVILEGE_LEVEL_3.4447>
  10a0bf:	eb 07                	jmp    10a0c8 <idt_encode_entry+0x75>
  10a0c1:	48 8b 05 28 e2 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffe228]        # 1082f0 <PRIVILEGE_LEVEL_0.4446>
  10a0c8:	09 c2                	or     edx,eax
  10a0ca:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a0ce:	88 50 05             	mov    BYTE PTR [rax+0x5],dl
	entry->code_segment_selector = GDT_RING0_CODE;
  10a0d1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a0d5:	66 c7 40 02 18 00    	mov    WORD PTR [rax+0x2],0x18
	entry->ist = 0;
  10a0db:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a0df:	c6 40 04 00          	mov    BYTE PTR [rax+0x4],0x0
}
  10a0e3:	90                   	nop
  10a0e4:	c9                   	leave  
  10a0e5:	c3                   	ret    

000000000010a0e6 <tss_ldr>:
void gdt_gdtr(uintptr_t base_address, size_t size){

}

static inline
void tss_ldr(const uint16_t selector_index){
  10a0e6:	55                   	push   rbp
  10a0e7:	48 89 e5             	mov    rbp,rsp
  10a0ea:	48 83 ec 20          	sub    rsp,0x20
  10a0ee:	89 f8                	mov    eax,edi
  10a0f0:	66 89 45 ec          	mov    WORD PTR [rbp-0x14],ax
  asm volatile("cli");
  10a0f4:	fa                   	cli    
  } task_register;
  
  //@Research
  //TODO(Torin: 2016-08-24) AMD64 system manual has the task_register with the above structure
  //It appears that is incorrect and its just a flat selector_index.  Make sure this is the case!
  uint16_t value = selector_index | 0b00; //This is probably what was ment?
  10a0f5:	0f b7 45 ec          	movzx  eax,WORD PTR [rbp-0x14]
  10a0f9:	66 89 45 fe          	mov    WORD PTR [rbp-0x2],ax
  klog_debug("task_register selector_index: 0x%X", (uint32_t)value);
  10a0fd:	0f b7 45 fe          	movzx  eax,WORD PTR [rbp-0x2]
  10a101:	89 c2                	mov    edx,eax
  10a103:	be b8 61 10 00       	mov    esi,0x1061b8
  10a108:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a10d:	b8 00 00 00 00       	mov    eax,0x0
  10a112:	e8 e0 2b 00 00       	call   10ccf7 <klog_write_fmt>
  //asm volatile ("ltr %0" : : "a"(task_register.packed));
  asm volatile ("ltr %0" : : "a"(value));
  10a117:	0f b7 45 fe          	movzx  eax,WORD PTR [rbp-0x2]
  10a11b:	0f 00 d8             	ltr    ax
  asm volatile("sti");
  10a11e:	fb                   	sti    
}
  10a11f:	90                   	nop
  10a120:	c9                   	leave  
  10a121:	c3                   	ret    

000000000010a122 <isr_handler_general_protection_fault>:
  "Reserved",                     //31 0x1F
};


static void
isr_handler_general_protection_fault(Interrupt_Stack_Frame stack_frame) {
  10a122:	55                   	push   rbp
  10a123:	48 89 e5             	mov    rbp,rsp
  10a126:	48 83 ec 10          	sub    rsp,0x10
    "IDT",
    "LDT",
    "IDT",
  };

  error_code.packed = stack_frame.error_code;
  10a12a:	48 8b 45 30          	mov    rax,QWORD PTR [rbp+0x30]
  10a12e:	89 45 f0             	mov    DWORD PTR [rbp-0x10],eax
  if(error_code.packed != 0){
  10a131:	8b 45 f0             	mov    eax,DWORD PTR [rbp-0x10]
  10a134:	85 c0                	test   eax,eax
  10a136:	0f 84 9e 00 00 00    	je     10a1da <isr_handler_general_protection_fault+0xb8>
    klog_error("GPF caused by segment error: ");
  10a13c:	be 68 63 10 00       	mov    esi,0x106368
  10a141:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a146:	b8 00 00 00 00       	mov    eax,0x0
  10a14b:	e8 a7 2b 00 00       	call   10ccf7 <klog_write_fmt>
    klog_error(" external_to_cpu: %s", error_code.is_external_to_cpu ? "true" : "false");
  10a150:	0f b6 45 f0          	movzx  eax,BYTE PTR [rbp-0x10]
  10a154:	83 e0 01             	and    eax,0x1
  10a157:	84 c0                	test   al,al
  10a159:	74 07                	je     10a162 <isr_handler_general_protection_fault+0x40>
  10a15b:	b8 86 63 10 00       	mov    eax,0x106386
  10a160:	eb 05                	jmp    10a167 <isr_handler_general_protection_fault+0x45>
  10a162:	b8 8b 63 10 00       	mov    eax,0x10638b
  10a167:	48 89 c2             	mov    rdx,rax
  10a16a:	be 91 63 10 00       	mov    esi,0x106391
  10a16f:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a174:	b8 00 00 00 00       	mov    eax,0x0
  10a179:	e8 79 2b 00 00       	call   10ccf7 <klog_write_fmt>
    klog_error(" table_name: %s", TABLE_NAMES[error_code.table_index]);
  10a17e:	0f b6 45 f0          	movzx  eax,BYTE PTR [rbp-0x10]
  10a182:	d0 e8                	shr    al,1
  10a184:	83 e0 03             	and    eax,0x3
  10a187:	0f b6 c0             	movzx  eax,al
  10a18a:	48 98                	cdqe   
  10a18c:	48 8b 04 c5 a0 d8 10 	mov    rax,QWORD PTR [rax*8+0x10d8a0]
  10a193:	00 
  10a194:	48 89 c2             	mov    rdx,rax
  10a197:	be a6 63 10 00       	mov    esi,0x1063a6
  10a19c:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a1a1:	b8 00 00 00 00       	mov    eax,0x0
  10a1a6:	e8 4c 2b 00 00       	call   10ccf7 <klog_write_fmt>
    klog_error(" selector_index: 0x%X", error_code.selector_index);
  10a1ab:	0f b7 45 f0          	movzx  eax,WORD PTR [rbp-0x10]
  10a1af:	66 c1 e8 03          	shr    ax,0x3
  10a1b3:	0f b7 c0             	movzx  eax,ax
  10a1b6:	89 c2                	mov    edx,eax
  10a1b8:	be b6 63 10 00       	mov    esi,0x1063b6
  10a1bd:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a1c2:	b8 00 00 00 00       	mov    eax,0x0
  10a1c7:	e8 2b 2b 00 00       	call   10ccf7 <klog_write_fmt>
    kpanic();
  10a1cc:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a1d1:	e8 48 f4 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10a1d6:	fa                   	cli    
  10a1d7:	f4                   	hlt    
    //TODO(Torin: 2016-08-24) Need to determine if the exception was caused in usermode or kernelmode
    //And then attempt to recover from the error.  This can happen if usermode code attemps
    //to execute a privleged instruction!
    kpanic();
  }
}
  10a1d8:	eb 0c                	jmp    10a1e6 <isr_handler_general_protection_fault+0xc4>
    kpanic();
  10a1da:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a1df:	e8 3a f4 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10a1e4:	fa                   	cli    
  10a1e5:	f4                   	hlt    
}
  10a1e6:	90                   	nop
  10a1e7:	c9                   	leave  
  10a1e8:	c3                   	ret    

000000000010a1e9 <isr_handler_page_fault>:

static void 
isr_handler_page_fault(Interrupt_Stack_Frame stack_frame) {
  10a1e9:	55                   	push   rbp
  10a1ea:	48 89 e5             	mov    rbp,rsp
  10a1ed:	48 83 ec 30          	sub    rsp,0x30
	static const uint64_t CAUSE_USER_OR_KERNEL = (1 << 2);
	static const uint64_t CAUSE_RESERVED_BIT_SET = (1 << 3);
	static const uint64_t CAUSE_INSTRUCTION_FETCH = (1 << 4);

	uintptr_t faulting_address;
	asm volatile ("movq %%cr2, %0" : "=r"(faulting_address));
  10a1f1:	0f 20 d0             	mov    rax,cr2
  10a1f4:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
	uint64_t is_protection_voloation_else_not_present = stack_frame.error_code & CAUSE_PROTECTION_VIOLATION_OR_NOT_PRESENT;
  10a1f8:	48 8b 55 30          	mov    rdx,QWORD PTR [rbp+0x30]
  10a1fc:	48 8b 05 15 e1 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffe115]        # 108318 <CAUSE_PROTECTION_VIOLATION_OR_NOT_PRESENT.4491>
  10a203:	48 21 d0             	and    rax,rdx
  10a206:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
	uint64_t is_write_else_read = stack_frame.error_code & CAUSE_WRITE_OR_READ;
  10a20a:	48 8b 55 30          	mov    rdx,QWORD PTR [rbp+0x30]
  10a20e:	48 8b 05 0b e1 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffe10b]        # 108320 <CAUSE_WRITE_OR_READ.4492>
  10a215:	48 21 d0             	and    rax,rdx
  10a218:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
	uint64_t is_usermode_else_kernel = stack_frame.error_code & CAUSE_USER_OR_KERNEL;
  10a21c:	48 8b 55 30          	mov    rdx,QWORD PTR [rbp+0x30]
  10a220:	48 8b 05 01 e1 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffe101]        # 108328 <CAUSE_USER_OR_KERNEL.4493>
  10a227:	48 21 d0             	and    rax,rdx
  10a22a:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
	uint64_t is_reserved_bit_overwritten = stack_frame.error_code & CAUSE_RESERVED_BIT_SET;
  10a22e:	48 8b 55 30          	mov    rdx,QWORD PTR [rbp+0x30]
  10a232:	48 8b 05 f7 e0 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffe0f7]        # 108330 <CAUSE_RESERVED_BIT_SET.4494>
  10a239:	48 21 d0             	and    rax,rdx
  10a23c:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
	uint64_t is_instruction_else_data = stack_frame.error_code & CAUSE_INSTRUCTION_FETCH;
  10a240:	48 8b 55 30          	mov    rdx,QWORD PTR [rbp+0x30]
  10a244:	48 8b 05 ed e0 ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffe0ed]        # 108338 <CAUSE_INSTRUCTION_FETCH.4495>
  10a24b:	48 21 d0             	and    rax,rdx
  10a24e:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
	
	klog_error("Page Fault (%s%s%s%s%s, faulting_address: 0x%X)", 
  10a252:	48 83 7d d0 00       	cmp    QWORD PTR [rbp-0x30],0x0
  10a257:	74 07                	je     10a260 <isr_handler_page_fault+0x77>
  10a259:	b9 cc 63 10 00       	mov    ecx,0x1063cc
  10a25e:	eb 05                	jmp    10a265 <isr_handler_page_fault+0x7c>
  10a260:	b9 e8 63 10 00       	mov    ecx,0x1063e8
  10a265:	48 83 7d d8 00       	cmp    QWORD PTR [rbp-0x28],0x0
  10a26a:	74 07                	je     10a273 <isr_handler_page_fault+0x8a>
  10a26c:	bf 00 64 10 00       	mov    edi,0x106400
  10a271:	eb 05                	jmp    10a278 <isr_handler_page_fault+0x8f>
  10a273:	bf 21 64 10 00       	mov    edi,0x106421
  10a278:	48 83 7d e0 00       	cmp    QWORD PTR [rbp-0x20],0x0
  10a27d:	74 07                	je     10a286 <isr_handler_page_fault+0x9d>
  10a27f:	be 3a 64 10 00       	mov    esi,0x10643a
  10a284:	eb 05                	jmp    10a28b <isr_handler_page_fault+0xa2>
  10a286:	be 52 64 10 00       	mov    esi,0x106452
  10a28b:	48 83 7d e8 00       	cmp    QWORD PTR [rbp-0x18],0x0
  10a290:	74 07                	je     10a299 <isr_handler_page_fault+0xb0>
  10a292:	ba 6c 64 10 00       	mov    edx,0x10646c
  10a297:	eb 05                	jmp    10a29e <isr_handler_page_fault+0xb5>
  10a299:	ba 82 64 10 00       	mov    edx,0x106482
  10a29e:	48 83 7d f0 00       	cmp    QWORD PTR [rbp-0x10],0x0
  10a2a3:	74 07                	je     10a2ac <isr_handler_page_fault+0xc3>
  10a2a5:	b8 98 64 10 00       	mov    eax,0x106498
  10a2aa:	eb 05                	jmp    10a2b1 <isr_handler_page_fault+0xc8>
  10a2ac:	b8 b9 64 10 00       	mov    eax,0x1064b9
  10a2b1:	ff 75 f8             	push   QWORD PTR [rbp-0x8]
  10a2b4:	51                   	push   rcx
  10a2b5:	49 89 f9             	mov    r9,rdi
  10a2b8:	49 89 f0             	mov    r8,rsi
  10a2bb:	48 89 d1             	mov    rcx,rdx
  10a2be:	48 89 c2             	mov    rdx,rax
  10a2c1:	be d0 64 10 00       	mov    esi,0x1064d0
  10a2c6:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a2cb:	b8 00 00 00 00       	mov    eax,0x0
  10a2d0:	e8 22 2a 00 00       	call   10ccf7 <klog_write_fmt>
  10a2d5:	48 83 c4 10          	add    rsp,0x10
    (is_write_else_read ? "cause by page write, " : "caused by page read, "),
    (is_usermode_else_kernel ? "happened in user-mode, " : "happened in kernel-mode, "),
    (is_reserved_bit_overwritten ? "a reserved bit was overrwriten, " : "reserved bits are fine, "),
    (is_instruction_else_data ? "caused by instruction fetch" : "caused by data access"),
    (faulting_address));
  kdebug_log_virtual_address_info_2MB(faulting_address);
  10a2d9:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a2dd:	48 89 c7             	mov    rdi,rax
  10a2e0:	e8 e8 17 00 00       	call   10bacd <kdebug_log_virtual_address_info_2MB>

	if (is_usermode_else_kernel == false) {
  10a2e5:	48 83 7d e0 00       	cmp    QWORD PTR [rbp-0x20],0x0
  10a2ea:	75 18                	jne    10a304 <isr_handler_page_fault+0x11b>
		//This is a serious bug there should never be a page-fault in the kernel
		//TODO(Torin) Need better painic mechanisim that handles this sort of thing manualy
		//and mabye drops back into real mode to go back to old-school vga text buffer and
		//does a blue-screen of death type of deal to insure that the error is reported properly

    kdebug_log_page_info();
  10a2ec:	b8 00 00 00 00       	mov    eax,0x0
  10a2f1:	e8 39 19 00 00       	call   10bc2f <kdebug_log_page_info>
    kpanic();
  10a2f6:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a2fb:	e8 1e f3 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10a300:	fa                   	cli    
  10a301:	f4                   	hlt    
	} else {
		//TODO(TORIN) This was the userspace application lets kill it
    klog_error("UNHANDLED USERSPACE VIOLATION!!!");
    kpanic();
	}
  10a302:	eb 20                	jmp    10a324 <isr_handler_page_fault+0x13b>
    klog_error("UNHANDLED USERSPACE VIOLATION!!!");
  10a304:	be 00 65 10 00       	mov    esi,0x106500
  10a309:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a30e:	b8 00 00 00 00       	mov    eax,0x0
  10a313:	e8 df 29 00 00       	call   10ccf7 <klog_write_fmt>
    kpanic();
  10a318:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a31d:	e8 fc f2 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10a322:	fa                   	cli    
  10a323:	f4                   	hlt    
  10a324:	90                   	nop
  10a325:	c9                   	leave  
  10a326:	c3                   	ret    

000000000010a327 <legacy_pic8259_initalize>:
static const uint8_t TEST_PROGRAM_ELF[] = {
#include "test_program.txt" 
};

static void
legacy_pic8259_initalize(void) {
  10a327:	55                   	push   rbp
  10a328:	48 89 e5             	mov    rbp,rsp
	static const uint8_t ICW3_PIC1_IRQ_LINE_2 = 0x4;
	static const uint8_t ICW3_PIC2_IRQ_LINE_2 = 0x2;
	static const uint8_t ICW4_8068 = 0x01;

	//ICW1 Tells PIC to wait for 3 more words
	write_port_uint8(PIC1_COMMAND_PORT, ICW1_INIT_CASCADED);
  10a32b:	0f b6 05 0e e0 ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffe00e]        # 108340 <ICW1_INIT_CASCADED.4513>
  10a332:	0f b6 d0             	movzx  edx,al
  10a335:	0f b6 05 05 e0 ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffe005]        # 108341 <PIC1_COMMAND_PORT.4509>
  10a33c:	0f b6 c0             	movzx  eax,al
  10a33f:	89 d6                	mov    esi,edx
  10a341:	89 c7                	mov    edi,eax
  10a343:	e8 c1 ee ff ff       	call   109209 <write_port_uint8>
	write_port_uint8(PIC2_COMMAND_PORT, ICW1_INIT_CASCADED);
  10a348:	0f b6 05 f1 df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdff1]        # 108340 <ICW1_INIT_CASCADED.4513>
  10a34f:	0f b6 d0             	movzx  edx,al
  10a352:	0f b6 05 e9 df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdfe9]        # 108342 <PIC2_COMMAND_PORT.4510>
  10a359:	0f b6 c0             	movzx  eax,al
  10a35c:	89 d6                	mov    esi,edx
  10a35e:	89 c7                	mov    edi,eax
  10a360:	e8 a4 ee ff ff       	call   109209 <write_port_uint8>
	//ICW2 Set PIC Offset Values
	write_port_uint8(PIC1_DATA_PORT, ICW2_PIC1_IRQ_NUMBER_BEGIN);
  10a365:	0f b6 05 d7 df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdfd7]        # 108343 <ICW2_PIC1_IRQ_NUMBER_BEGIN.4514>
  10a36c:	0f b6 d0             	movzx  edx,al
  10a36f:	0f b6 05 ce df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdfce]        # 108344 <PIC1_DATA_PORT.4511>
  10a376:	0f b6 c0             	movzx  eax,al
  10a379:	89 d6                	mov    esi,edx
  10a37b:	89 c7                	mov    edi,eax
  10a37d:	e8 87 ee ff ff       	call   109209 <write_port_uint8>
	write_port_uint8(PIC2_DATA_PORT, ICW2_PIC2_IRQ_NUMBER_BEGIN);
  10a382:	0f b6 05 bc df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdfbc]        # 108345 <ICW2_PIC2_IRQ_NUMBER_BEGIN.4515>
  10a389:	0f b6 d0             	movzx  edx,al
  10a38c:	0f b6 05 b3 df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdfb3]        # 108346 <PIC2_DATA_PORT.4512>
  10a393:	0f b6 c0             	movzx  eax,al
  10a396:	89 d6                	mov    esi,edx
  10a398:	89 c7                	mov    edi,eax
  10a39a:	e8 6a ee ff ff       	call   109209 <write_port_uint8>
	//ICW3 PIC Cascading Info
	write_port_uint8(PIC1_DATA_PORT, ICW3_PIC1_IRQ_LINE_2);
  10a39f:	0f b6 05 a1 df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdfa1]        # 108347 <ICW3_PIC1_IRQ_LINE_2.4516>
  10a3a6:	0f b6 d0             	movzx  edx,al
  10a3a9:	0f b6 05 94 df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdf94]        # 108344 <PIC1_DATA_PORT.4511>
  10a3b0:	0f b6 c0             	movzx  eax,al
  10a3b3:	89 d6                	mov    esi,edx
  10a3b5:	89 c7                	mov    edi,eax
  10a3b7:	e8 4d ee ff ff       	call   109209 <write_port_uint8>
	write_port_uint8(PIC2_DATA_PORT, ICW3_PIC2_IRQ_LINE_2);
  10a3bc:	0f b6 05 85 df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdf85]        # 108348 <ICW3_PIC2_IRQ_LINE_2.4517>
  10a3c3:	0f b6 d0             	movzx  edx,al
  10a3c6:	0f b6 05 79 df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdf79]        # 108346 <PIC2_DATA_PORT.4512>
  10a3cd:	0f b6 c0             	movzx  eax,al
  10a3d0:	89 d6                	mov    esi,edx
  10a3d2:	89 c7                	mov    edi,eax
  10a3d4:	e8 30 ee ff ff       	call   109209 <write_port_uint8>
	//ICW4 Additional Enviroment Info
	//NOTE(Torin) Currently set to 80x86
	write_port_uint8(PIC1_DATA_PORT, ICW4_8068);
  10a3d9:	0f b6 05 69 df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdf69]        # 108349 <ICW4_8068.4518>
  10a3e0:	0f b6 d0             	movzx  edx,al
  10a3e3:	0f b6 05 5a df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdf5a]        # 108344 <PIC1_DATA_PORT.4511>
  10a3ea:	0f b6 c0             	movzx  eax,al
  10a3ed:	89 d6                	mov    esi,edx
  10a3ef:	89 c7                	mov    edi,eax
  10a3f1:	e8 13 ee ff ff       	call   109209 <write_port_uint8>
	write_port_uint8(PIC2_DATA_PORT, ICW4_8068);
  10a3f6:	0f b6 05 4c df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdf4c]        # 108349 <ICW4_8068.4518>
  10a3fd:	0f b6 d0             	movzx  edx,al
  10a400:	0f b6 05 3f df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdf3f]        # 108346 <PIC2_DATA_PORT.4512>
  10a407:	0f b6 c0             	movzx  eax,al
  10a40a:	89 d6                	mov    esi,edx
  10a40c:	89 c7                	mov    edi,eax
  10a40e:	e8 f6 ed ff ff       	call   109209 <write_port_uint8>

  //Write EndOfInterupt and set interrupt enabled mask 
	write_port_uint8(PIC1_DATA_PORT, 0x20);
  10a413:	0f b6 05 2a df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdf2a]        # 108344 <PIC1_DATA_PORT.4511>
  10a41a:	0f b6 c0             	movzx  eax,al
  10a41d:	be 20 00 00 00       	mov    esi,0x20
  10a422:	89 c7                	mov    edi,eax
  10a424:	e8 e0 ed ff ff       	call   109209 <write_port_uint8>
	write_port_uint8(PIC2_DATA_PORT, 0x20);
  10a429:	0f b6 05 16 df ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdf16]        # 108346 <PIC2_DATA_PORT.4512>
  10a430:	0f b6 c0             	movzx  eax,al
  10a433:	be 20 00 00 00       	mov    esi,0x20
  10a438:	89 c7                	mov    edi,eax
  10a43a:	e8 ca ed ff ff       	call   109209 <write_port_uint8>
	write_port_uint8(PIC1_DATA_PORT, 0b11111101);
  10a43f:	0f b6 05 fe de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdefe]        # 108344 <PIC1_DATA_PORT.4511>
  10a446:	0f b6 c0             	movzx  eax,al
  10a449:	be fd 00 00 00       	mov    esi,0xfd
  10a44e:	89 c7                	mov    edi,eax
  10a450:	e8 b4 ed ff ff       	call   109209 <write_port_uint8>
	write_port_uint8(PIC2_DATA_PORT, 0b11111111);
  10a455:	0f b6 05 ea de ff ff 	movzx  eax,BYTE PTR [rip+0xffffffffffffdeea]        # 108346 <PIC2_DATA_PORT.4512>
  10a45c:	0f b6 c0             	movzx  eax,al
  10a45f:	be ff 00 00 00       	mov    esi,0xff
  10a464:	89 c7                	mov    edi,eax
  10a466:	e8 9e ed ff ff       	call   109209 <write_port_uint8>
	klog_info("PIC8259 Initialized");
  10a46b:	be 68 6b 10 00       	mov    esi,0x106b68
  10a470:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a475:	b8 00 00 00 00       	mov    eax,0x0
  10a47a:	e8 78 28 00 00       	call   10ccf7 <klog_write_fmt>
}
  10a47f:	90                   	nop
  10a480:	5d                   	pop    rbp
  10a481:	c3                   	ret    

000000000010a482 <idt_install_interrupt>:
}
#endif

//TODO(Torin) Remove IDT Global variable
static void
idt_install_interrupt(const uint32_t irq_number, const uint64_t irq_handler_addr) {
  10a482:	55                   	push   rbp
  10a483:	48 89 e5             	mov    rbp,rsp
  10a486:	48 83 ec 10          	sub    rsp,0x10
  10a48a:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
  10a48d:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
	
	static const uint64_t TYPE_TASK_GATE_64 = 0x5;
	static const uint64_t TYPE_INTERRUPT_GATE_64 = 0xE;
	static const uint64_t TYPE_TRAP_GATE_64 = 0xF;

	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10a491:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10a495:	89 c2                	mov    edx,eax
  10a497:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a49a:	48 c1 e0 04          	shl    rax,0x4
  10a49e:	48 05 00 e8 11 00    	add    rax,0x11e800
  10a4a4:	66 89 10             	mov    WORD PTR [rax],dx
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10a4a7:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10a4ab:	48 c1 e8 10          	shr    rax,0x10
  10a4af:	89 c2                	mov    edx,eax
  10a4b1:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a4b4:	48 c1 e0 04          	shl    rax,0x4
  10a4b8:	48 05 06 e8 11 00    	add    rax,0x11e806
  10a4be:	66 89 10             	mov    WORD PTR [rax],dx
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10a4c1:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10a4c5:	48 c1 e8 20          	shr    rax,0x20
  10a4c9:	89 c2                	mov    edx,eax
  10a4cb:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a4ce:	48 c1 e0 04          	shl    rax,0x4
  10a4d2:	48 05 08 e8 11 00    	add    rax,0x11e808
  10a4d8:	89 10                	mov    DWORD PTR [rax],edx
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10a4da:	48 8b 05 6f de ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffde6f]        # 108350 <PRESENT_BIT.4525>
  10a4e1:	89 c2                	mov    edx,eax
  10a4e3:	48 8b 05 6e de ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffde6e]        # 108358 <TYPE_INTERRUPT_GATE_64.4527>
  10a4ea:	09 c2                	or     edx,eax
  10a4ec:	48 8b 05 6d de ff ff 	mov    rax,QWORD PTR [rip+0xffffffffffffde6d]        # 108360 <PRIVILEGE_LEVEL_0.4523>
  10a4f3:	09 c2                	or     edx,eax
  10a4f5:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a4f8:	48 c1 e0 04          	shl    rax,0x4
  10a4fc:	48 05 05 e8 11 00    	add    rax,0x11e805
  10a502:	88 10                	mov    BYTE PTR [rax],dl
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10a504:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a507:	48 c1 e0 04          	shl    rax,0x4
  10a50b:	48 05 02 e8 11 00    	add    rax,0x11e802
  10a511:	66 c7 00 18 00       	mov    WORD PTR [rax],0x18
	_idt[irq_number].ist = 0;
  10a516:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a519:	48 c1 e0 04          	shl    rax,0x4
  10a51d:	48 05 04 e8 11 00    	add    rax,0x11e804
  10a523:	c6 00 00             	mov    BYTE PTR [rax],0x0
}
  10a526:	90                   	nop
  10a527:	c9                   	leave  
  10a528:	c3                   	ret    

000000000010a529 <x86_64_idt_initalize>:

static void
x86_64_idt_initalize(){
  10a529:	55                   	push   rbp
  10a52a:	48 89 e5             	mov    rbp,rsp
  10a52d:	48 83 ec 10          	sub    rsp,0x10
  extern void asm_double_fault_handler();
  extern void asm_debug_handler();
  
	for (uint32_t i = 0; i < 256; i++) {
  10a531:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
  10a538:	eb 25                	jmp    10a55f <x86_64_idt_initalize+0x36>
		idt_install_interrupt(i, (uintptr_t)asm_debug_handler);
  10a53a:	ba 75 d3 10 00       	mov    edx,0x10d375
  10a53f:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a542:	48 89 d6             	mov    rsi,rdx
  10a545:	89 c7                	mov    edi,eax
  10a547:	e8 36 ff ff ff       	call   10a482 <idt_install_interrupt>
		_interrupt_handlers[i] = 0x00;
  10a54c:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
  10a54f:	48 c7 04 c5 00 f8 11 	mov    QWORD PTR [rax*8+0x11f800],0x0
  10a556:	00 00 00 00 00 
	for (uint32_t i = 0; i < 256; i++) {
  10a55b:	83 45 fc 01          	add    DWORD PTR [rbp-0x4],0x1
  10a55f:	81 7d fc ff 00 00 00 	cmp    DWORD PTR [rbp-0x4],0xff
  10a566:	76 d2                	jbe    10a53a <x86_64_idt_initalize+0x11>
		extern void asm_isr28(void);
		extern void asm_isr29(void);
		extern void asm_isr30(void);
		extern void asm_isr31(void);

		idt_install_interrupt(0, (uintptr_t)asm_isr0);
  10a568:	b8 ca d3 10 00       	mov    eax,0x10d3ca
  10a56d:	48 89 c6             	mov    rsi,rax
  10a570:	bf 00 00 00 00       	mov    edi,0x0
  10a575:	e8 08 ff ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(1, (uintptr_t)asm_isr1);
  10a57a:	b8 d1 d3 10 00       	mov    eax,0x10d3d1
  10a57f:	48 89 c6             	mov    rsi,rax
  10a582:	bf 01 00 00 00       	mov    edi,0x1
  10a587:	e8 f6 fe ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(2, (uintptr_t)asm_isr2);
  10a58c:	b8 d8 d3 10 00       	mov    eax,0x10d3d8
  10a591:	48 89 c6             	mov    rsi,rax
  10a594:	bf 02 00 00 00       	mov    edi,0x2
  10a599:	e8 e4 fe ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(3, (uintptr_t)asm_isr3);
  10a59e:	b8 df d3 10 00       	mov    eax,0x10d3df
  10a5a3:	48 89 c6             	mov    rsi,rax
  10a5a6:	bf 03 00 00 00       	mov    edi,0x3
  10a5ab:	e8 d2 fe ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(4, (uintptr_t)asm_isr4);
  10a5b0:	b8 e6 d3 10 00       	mov    eax,0x10d3e6
  10a5b5:	48 89 c6             	mov    rsi,rax
  10a5b8:	bf 04 00 00 00       	mov    edi,0x4
  10a5bd:	e8 c0 fe ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(5, (uintptr_t)asm_isr5);
  10a5c2:	b8 ed d3 10 00       	mov    eax,0x10d3ed
  10a5c7:	48 89 c6             	mov    rsi,rax
  10a5ca:	bf 05 00 00 00       	mov    edi,0x5
  10a5cf:	e8 ae fe ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(6, (uintptr_t)asm_isr6);
  10a5d4:	b8 f4 d3 10 00       	mov    eax,0x10d3f4
  10a5d9:	48 89 c6             	mov    rsi,rax
  10a5dc:	bf 06 00 00 00       	mov    edi,0x6
  10a5e1:	e8 9c fe ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(7, (uintptr_t)asm_isr7);
  10a5e6:	b8 fb d3 10 00       	mov    eax,0x10d3fb
  10a5eb:	48 89 c6             	mov    rsi,rax
  10a5ee:	bf 07 00 00 00       	mov    edi,0x7
  10a5f3:	e8 8a fe ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(8, (uintptr_t)asm_double_fault_handler);
  10a5f8:	b8 50 d3 10 00       	mov    eax,0x10d350
  10a5fd:	48 89 c6             	mov    rsi,rax
  10a600:	bf 08 00 00 00       	mov    edi,0x8
  10a605:	e8 78 fe ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(9, (uintptr_t)asm_isr9);
  10a60a:	b8 07 d4 10 00       	mov    eax,0x10d407
  10a60f:	48 89 c6             	mov    rsi,rax
  10a612:	bf 09 00 00 00       	mov    edi,0x9
  10a617:	e8 66 fe ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(10, (uintptr_t)asm_isr10);
  10a61c:	b8 0e d4 10 00       	mov    eax,0x10d40e
  10a621:	48 89 c6             	mov    rsi,rax
  10a624:	bf 0a 00 00 00       	mov    edi,0xa
  10a629:	e8 54 fe ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(11, (uintptr_t)asm_isr11);
  10a62e:	b8 13 d4 10 00       	mov    eax,0x10d413
  10a633:	48 89 c6             	mov    rsi,rax
  10a636:	bf 0b 00 00 00       	mov    edi,0xb
  10a63b:	e8 42 fe ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(12, (uintptr_t)asm_isr12);
  10a640:	b8 18 d4 10 00       	mov    eax,0x10d418
  10a645:	48 89 c6             	mov    rsi,rax
  10a648:	bf 0c 00 00 00       	mov    edi,0xc
  10a64d:	e8 30 fe ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(13, (uintptr_t)asm_isr13);
  10a652:	b8 1d d4 10 00       	mov    eax,0x10d41d
  10a657:	48 89 c6             	mov    rsi,rax
  10a65a:	bf 0d 00 00 00       	mov    edi,0xd
  10a65f:	e8 1e fe ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(14, (uintptr_t)asm_isr14);
  10a664:	b8 22 d4 10 00       	mov    eax,0x10d422
  10a669:	48 89 c6             	mov    rsi,rax
  10a66c:	bf 0e 00 00 00       	mov    edi,0xe
  10a671:	e8 0c fe ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(15, (uintptr_t)asm_isr15);
  10a676:	b8 27 d4 10 00       	mov    eax,0x10d427
  10a67b:	48 89 c6             	mov    rsi,rax
  10a67e:	bf 0f 00 00 00       	mov    edi,0xf
  10a683:	e8 fa fd ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(16, (uintptr_t)asm_isr16);
  10a688:	b8 31 d4 10 00       	mov    eax,0x10d431
  10a68d:	48 89 c6             	mov    rsi,rax
  10a690:	bf 10 00 00 00       	mov    edi,0x10
  10a695:	e8 e8 fd ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(17, (uintptr_t)asm_isr17);
  10a69a:	b8 3b d4 10 00       	mov    eax,0x10d43b
  10a69f:	48 89 c6             	mov    rsi,rax
  10a6a2:	bf 11 00 00 00       	mov    edi,0x11
  10a6a7:	e8 d6 fd ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(18, (uintptr_t)asm_isr18);
  10a6ac:	b8 43 d4 10 00       	mov    eax,0x10d443
  10a6b1:	48 89 c6             	mov    rsi,rax
  10a6b4:	bf 12 00 00 00       	mov    edi,0x12
  10a6b9:	e8 c4 fd ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(19, (uintptr_t)asm_isr19);
  10a6be:	b8 4d d4 10 00       	mov    eax,0x10d44d
  10a6c3:	48 89 c6             	mov    rsi,rax
  10a6c6:	bf 13 00 00 00       	mov    edi,0x13
  10a6cb:	e8 b2 fd ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(20, (uintptr_t)asm_isr20);
  10a6d0:	b8 57 d4 10 00       	mov    eax,0x10d457
  10a6d5:	48 89 c6             	mov    rsi,rax
  10a6d8:	bf 14 00 00 00       	mov    edi,0x14
  10a6dd:	e8 a0 fd ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(21, (uintptr_t)asm_isr21);
  10a6e2:	b8 61 d4 10 00       	mov    eax,0x10d461
  10a6e7:	48 89 c6             	mov    rsi,rax
  10a6ea:	bf 15 00 00 00       	mov    edi,0x15
  10a6ef:	e8 8e fd ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(22, (uintptr_t)asm_isr22);
  10a6f4:	b8 6b d4 10 00       	mov    eax,0x10d46b
  10a6f9:	48 89 c6             	mov    rsi,rax
  10a6fc:	bf 16 00 00 00       	mov    edi,0x16
  10a701:	e8 7c fd ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(23, (uintptr_t)asm_isr23);
  10a706:	b8 75 d4 10 00       	mov    eax,0x10d475
  10a70b:	48 89 c6             	mov    rsi,rax
  10a70e:	bf 17 00 00 00       	mov    edi,0x17
  10a713:	e8 6a fd ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(24, (uintptr_t)asm_isr24);
  10a718:	b8 7f d4 10 00       	mov    eax,0x10d47f
  10a71d:	48 89 c6             	mov    rsi,rax
  10a720:	bf 18 00 00 00       	mov    edi,0x18
  10a725:	e8 58 fd ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(25, (uintptr_t)asm_isr25);
  10a72a:	b8 89 d4 10 00       	mov    eax,0x10d489
  10a72f:	48 89 c6             	mov    rsi,rax
  10a732:	bf 19 00 00 00       	mov    edi,0x19
  10a737:	e8 46 fd ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(26, (uintptr_t)asm_isr26);
  10a73c:	b8 93 d4 10 00       	mov    eax,0x10d493
  10a741:	48 89 c6             	mov    rsi,rax
  10a744:	bf 1a 00 00 00       	mov    edi,0x1a
  10a749:	e8 34 fd ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(27, (uintptr_t)asm_isr27);
  10a74e:	b8 9d d4 10 00       	mov    eax,0x10d49d
  10a753:	48 89 c6             	mov    rsi,rax
  10a756:	bf 1b 00 00 00       	mov    edi,0x1b
  10a75b:	e8 22 fd ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(28, (uintptr_t)asm_isr28);
  10a760:	b8 a7 d4 10 00       	mov    eax,0x10d4a7
  10a765:	48 89 c6             	mov    rsi,rax
  10a768:	bf 1c 00 00 00       	mov    edi,0x1c
  10a76d:	e8 10 fd ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(29, (uintptr_t)asm_isr29);
  10a772:	b8 b1 d4 10 00       	mov    eax,0x10d4b1
  10a777:	48 89 c6             	mov    rsi,rax
  10a77a:	bf 1d 00 00 00       	mov    edi,0x1d
  10a77f:	e8 fe fc ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(30, (uintptr_t)asm_isr30);
  10a784:	b8 bb d4 10 00       	mov    eax,0x10d4bb
  10a789:	48 89 c6             	mov    rsi,rax
  10a78c:	bf 1e 00 00 00       	mov    edi,0x1e
  10a791:	e8 ec fc ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(31, (uintptr_t)asm_isr31);
  10a796:	b8 c5 d4 10 00       	mov    eax,0x10d4c5
  10a79b:	48 89 c6             	mov    rsi,rax
  10a79e:	bf 1f 00 00 00       	mov    edi,0x1f
  10a7a3:	e8 da fc ff ff       	call   10a482 <idt_install_interrupt>
		extern void asm_irq1(void);
    extern void asm_irq128(void);

    extern void asm_syscall_handler(void);

		_interrupt_handlers[0] = (uintptr_t)irq_handler_pit;
  10a7a8:	b8 9f c4 10 00       	mov    eax,0x10c49f
  10a7ad:	48 89 05 4c 50 01 00 	mov    QWORD PTR [rip+0x1504c],rax        # 11f800 <_interrupt_handlers>
		_interrupt_handlers[1] = (uintptr_t)irq_handler_keyboard;
  10a7b4:	b8 64 c2 10 00       	mov    eax,0x10c264
  10a7b9:	48 89 05 48 50 01 00 	mov    QWORD PTR [rip+0x15048],rax        # 11f808 <_interrupt_handlers+0x8>
		idt_install_interrupt(IRQ_PIT, (uintptr_t)asm_irq0);
  10a7c0:	ba cf d4 10 00       	mov    edx,0x10d4cf
  10a7c5:	8b 05 b5 db ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffdbb5]        # 108380 <IRQ_PIT.4630>
  10a7cb:	48 89 d6             	mov    rsi,rdx
  10a7ce:	89 c7                	mov    edi,eax
  10a7d0:	e8 ad fc ff ff       	call   10a482 <idt_install_interrupt>
		idt_install_interrupt(IRQ_KEYBOARD, (uintptr_t)asm_irq1);
  10a7d5:	ba d7 d4 10 00       	mov    edx,0x10d4d7
  10a7da:	8b 05 a4 db ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffdba4]        # 108384 <IRQ_KEYBOARD.4631>
  10a7e0:	48 89 d6             	mov    rsi,rdx
  10a7e3:	89 c7                	mov    edi,eax
  10a7e5:	e8 98 fc ff ff       	call   10a482 <idt_install_interrupt>
    idt_encode_entry((uintptr_t)&_idt[0x80], (uintptr_t)asm_syscall_handler, true);
  10a7ea:	b9 bc d3 10 00       	mov    ecx,0x10d3bc
  10a7ef:	b8 00 f0 11 00       	mov    eax,0x11f000
  10a7f4:	ba 01 00 00 00       	mov    edx,0x1
  10a7f9:	48 89 ce             	mov    rsi,rcx
  10a7fc:	48 89 c7             	mov    rdi,rax
  10a7ff:	e8 4f f8 ff ff       	call   10a053 <idt_encode_entry>
#endif

	struct {
			uint16_t limit;
			uintptr_t address;
	} __attribute__((packed)) idtr = { sizeof(_idt) - 1, (uintptr_t)_idt };
  10a804:	66 c7 45 f0 ff 0f    	mov    WORD PTR [rbp-0x10],0xfff
  10a80a:	b8 00 e8 11 00       	mov    eax,0x11e800
  10a80f:	48 89 45 f2          	mov    QWORD PTR [rbp-0xe],rax
	asm volatile ("lidt %0" : : "m"(idtr));
  10a813:	0f 01 5d f0          	lidt   [rbp-0x10]
	asm volatile ("sti");
  10a817:	fb                   	sti    
  klog_info("IDT initialized");
  10a818:	be 7c 6b 10 00       	mov    esi,0x106b7c
  10a81d:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a822:	b8 00 00 00 00       	mov    eax,0x0
  10a827:	e8 cb 24 00 00       	call   10ccf7 <klog_write_fmt>
}
  10a82c:	90                   	nop
  10a82d:	c9                   	leave  
  10a82e:	c3                   	ret    

000000000010a82f <serial_debug_init>:

#define HW_SERIAL_DIVISOR_LATCH_ACCESS_BIT (1 << 7)

#define PORT 0x3F8
void serial_debug_init() 
{
  10a82f:	55                   	push   rbp
  10a830:	48 89 e5             	mov    rbp,rsp
   write_port_uint8(PORT + 1, 0x00);    // Disable all interrupts
  10a833:	be 00 00 00 00       	mov    esi,0x0
  10a838:	bf f9 03 00 00       	mov    edi,0x3f9
  10a83d:	e8 c7 e9 ff ff       	call   109209 <write_port_uint8>
   write_port_uint8(PORT + 3, 0x80);    // Enable DLAB (set baud rate divisor)
  10a842:	be 80 00 00 00       	mov    esi,0x80
  10a847:	bf fb 03 00 00       	mov    edi,0x3fb
  10a84c:	e8 b8 e9 ff ff       	call   109209 <write_port_uint8>
   write_port_uint8(PORT + 0, 0x01);    // Set divisor to 3 (lo byte) 38400 baud
  10a851:	be 01 00 00 00       	mov    esi,0x1
  10a856:	bf f8 03 00 00       	mov    edi,0x3f8
  10a85b:	e8 a9 e9 ff ff       	call   109209 <write_port_uint8>
   write_port_uint8(PORT + 1, 0x00);    //                  (hi byte)
  10a860:	be 00 00 00 00       	mov    esi,0x0
  10a865:	bf f9 03 00 00       	mov    edi,0x3f9
  10a86a:	e8 9a e9 ff ff       	call   109209 <write_port_uint8>
   write_port_uint8(PORT + 3, 0x03);    // 8 bits, no parity, one stop bit
  10a86f:	be 03 00 00 00       	mov    esi,0x3
  10a874:	bf fb 03 00 00       	mov    edi,0x3fb
  10a879:	e8 8b e9 ff ff       	call   109209 <write_port_uint8>
   write_port_uint8(PORT + 2, 0xC7);    // Enable FIFO, clear them, with 14-byte threshold
  10a87e:	be c7 00 00 00       	mov    esi,0xc7
  10a883:	bf fa 03 00 00       	mov    edi,0x3fa
  10a888:	e8 7c e9 ff ff       	call   109209 <write_port_uint8>
   write_port_uint8(PORT + 4, 0x0B);    // IRQs enabled, RTS/DSR set
  10a88d:	be 0b 00 00 00       	mov    esi,0xb
  10a892:	bf fc 03 00 00       	mov    edi,0x3fc
  10a897:	e8 6d e9 ff ff       	call   109209 <write_port_uint8>
}
  10a89c:	90                   	nop
  10a89d:	5d                   	pop    rbp
  10a89e:	c3                   	ret    

000000000010a89f <is_transmit_empty>:

int is_transmit_empty() {
  10a89f:	55                   	push   rbp
  10a8a0:	48 89 e5             	mov    rbp,rsp
   return read_port_uint8(PORT + 5) & 0x20;
  10a8a3:	bf fd 03 00 00       	mov    edi,0x3fd
  10a8a8:	e8 7b e9 ff ff       	call   109228 <read_port_uint8>
  10a8ad:	0f b6 c0             	movzx  eax,al
  10a8b0:	83 e0 20             	and    eax,0x20
}
  10a8b3:	5d                   	pop    rbp
  10a8b4:	c3                   	ret    

000000000010a8b5 <write_serial>:
   while (is_transmit_empty() == 0);
   write_port(PORT,a);
}
#endif

void write_serial(const char *src, size_t length){
  10a8b5:	55                   	push   rbp
  10a8b6:	48 89 e5             	mov    rbp,rsp
  10a8b9:	48 83 ec 20          	sub    rsp,0x20
  10a8bd:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10a8c1:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  for(size_t i = 0; i < length; i++){
  10a8c5:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10a8cc:	00 
  10a8cd:	eb 31                	jmp    10a900 <write_serial+0x4b>
    while(is_transmit_empty() == 0) {}
  10a8cf:	90                   	nop
  10a8d0:	b8 00 00 00 00       	mov    eax,0x0
  10a8d5:	e8 c5 ff ff ff       	call   10a89f <is_transmit_empty>
  10a8da:	85 c0                	test   eax,eax
  10a8dc:	74 f2                	je     10a8d0 <write_serial+0x1b>
    write_port_uint8(PORT, src[i]);
  10a8de:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  10a8e2:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a8e6:	48 01 d0             	add    rax,rdx
  10a8e9:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10a8ec:	0f b6 c0             	movzx  eax,al
  10a8ef:	89 c6                	mov    esi,eax
  10a8f1:	bf f8 03 00 00       	mov    edi,0x3f8
  10a8f6:	e8 0e e9 ff ff       	call   109209 <write_port_uint8>
  for(size_t i = 0; i < length; i++){
  10a8fb:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10a900:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10a904:	48 3b 45 e0          	cmp    rax,QWORD PTR [rbp-0x20]
  10a908:	72 c5                	jb     10a8cf <write_serial+0x1a>
  }
}
  10a90a:	90                   	nop
  10a90b:	c9                   	leave  
  10a90c:	c3                   	ret    

000000000010a90d <kmem_map_physical_to_virtual_2MB_ext>:
static const uint64_t PAGE_GLOBAL_BIT             = 1L << 8;
static const uint64_t PAGE_NO_EXECUTE_BIT         = 1L << 63;

//=============================================================================================

void kmem_map_physical_to_virtual_2MB_ext(uintptr_t physical_address, uintptr_t virtual_address, uint64_t flags){
  10a90d:	55                   	push   rbp
  10a90e:	48 89 e5             	mov    rbp,rsp
  10a911:	48 83 ec 50          	sub    rsp,0x50
  10a915:	48 89 7d c8          	mov    QWORD PTR [rbp-0x38],rdi
  10a919:	48 89 75 c0          	mov    QWORD PTR [rbp-0x40],rsi
  10a91d:	48 89 55 b8          	mov    QWORD PTR [rbp-0x48],rdx
  kassert((virtual_address & 0x1FFFFF) == 0);
  10a921:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10a925:	25 ff ff 1f 00       	and    eax,0x1fffff
  10a92a:	48 85 c0             	test   rax,rax
  10a92d:	74 30                	je     10a95f <kmem_map_physical_to_virtual_2MB_ext+0x52>
  10a92f:	41 b8 e0 6b 10 00    	mov    r8d,0x106be0
  10a935:	b9 26 00 00 00       	mov    ecx,0x26
  10a93a:	ba f8 6b 10 00       	mov    edx,0x106bf8
  10a93f:	be 38 61 10 00       	mov    esi,0x106138
  10a944:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a949:	b8 00 00 00 00       	mov    eax,0x0
  10a94e:	e8 a4 23 00 00       	call   10ccf7 <klog_write_fmt>
  10a953:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a958:	e8 c1 ec ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10a95d:	fa                   	cli    
  10a95e:	f4                   	hlt    
  kassert((physical_address & 0x1FFFFF) == 0);
  10a95f:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  10a963:	25 ff ff 1f 00       	and    eax,0x1fffff
  10a968:	48 85 c0             	test   rax,rax
  10a96b:	74 30                	je     10a99d <kmem_map_physical_to_virtual_2MB_ext+0x90>
  10a96d:	41 b8 e0 6b 10 00    	mov    r8d,0x106be0
  10a973:	b9 27 00 00 00       	mov    ecx,0x27
  10a978:	ba 20 6c 10 00       	mov    edx,0x106c20
  10a97d:	be 38 61 10 00       	mov    esi,0x106138
  10a982:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a987:	b8 00 00 00 00       	mov    eax,0x0
  10a98c:	e8 66 23 00 00       	call   10ccf7 <klog_write_fmt>
  10a991:	bf 00 e0 10 00       	mov    edi,0x10e000
  10a996:	e8 83 ec ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10a99b:	fa                   	cli    
  10a99c:	f4                   	hlt    
  uintptr_t p4_index = (virtual_address >> 39) & 0x1FF;
  10a99d:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10a9a1:	48 c1 e8 27          	shr    rax,0x27
  10a9a5:	25 ff 01 00 00       	and    eax,0x1ff
  10a9aa:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  uintptr_t p3_index = (virtual_address >> 30) & 0x1FF;
  10a9ae:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10a9b2:	48 c1 e8 1e          	shr    rax,0x1e
  10a9b6:	25 ff 01 00 00       	and    eax,0x1ff
  10a9bb:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
  uintptr_t p2_index = (virtual_address >> 21) & 0x1FF;
  10a9bf:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10a9c3:	48 c1 e8 15          	shr    rax,0x15
  10a9c7:	25 ff 01 00 00       	and    eax,0x1ff
  10a9cc:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
  PageTable *p4_table = (PageTable *)&g_p4_table;
  10a9d0:	48 c7 45 e0 00 20 12 	mov    QWORD PTR [rbp-0x20],0x122000
  10a9d7:	00 
  PageTable *p3_table = (PageTable *)p4_table->entries[p4_index]; 
  10a9d8:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10a9dc:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10a9e0:	48 8b 04 d0          	mov    rax,QWORD PTR [rax+rdx*8]
  10a9e4:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
  PageTable *p2_table = (PageTable *)p3_table->entries[p3_index];
  10a9e8:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10a9ec:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  10a9f0:	48 8b 04 d0          	mov    rax,QWORD PTR [rax+rdx*8]
  10a9f4:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
  g_p2_table.entries[p2_index] = physical_address | PAGE_PRESENT_BIT | PAGE_HUGE_BIT | PAGE_WRITEABLE_BIT | flags;
  10a9f8:	b8 01 00 00 00       	mov    eax,0x1
  10a9fd:	48 0b 45 c8          	or     rax,QWORD PTR [rbp-0x38]
  10aa01:	ba 80 00 00 00       	mov    edx,0x80
  10aa06:	48 09 d0             	or     rax,rdx
  10aa09:	ba 02 00 00 00       	mov    edx,0x2
  10aa0e:	48 09 d0             	or     rax,rdx
  10aa11:	48 0b 45 b8          	or     rax,QWORD PTR [rbp-0x48]
  10aa15:	48 89 c2             	mov    rdx,rax
  10aa18:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10aa1c:	48 89 14 c5 00 40 12 	mov    QWORD PTR [rax*8+0x124000],rdx
  10aa23:	00 
}
  10aa24:	90                   	nop
  10aa25:	c9                   	leave  
  10aa26:	c3                   	ret    

000000000010aa27 <kmem_map_physical_to_virtual_2MB>:

void kmem_map_physical_to_virtual_2MB(uintptr_t physical_address, uintptr_t virtual_address){
  10aa27:	55                   	push   rbp
  10aa28:	48 89 e5             	mov    rbp,rsp
  10aa2b:	48 83 ec 30          	sub    rsp,0x30
  10aa2f:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  10aa33:	48 89 75 d0          	mov    QWORD PTR [rbp-0x30],rsi
  kassert((virtual_address & 0x1FFFFF) == 0);
  10aa37:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10aa3b:	25 ff ff 1f 00       	and    eax,0x1fffff
  10aa40:	48 85 c0             	test   rax,rax
  10aa43:	74 30                	je     10aa75 <kmem_map_physical_to_virtual_2MB+0x4e>
  10aa45:	41 b8 e0 6b 10 00    	mov    r8d,0x106be0
  10aa4b:	b9 32 00 00 00       	mov    ecx,0x32
  10aa50:	ba f8 6b 10 00       	mov    edx,0x106bf8
  10aa55:	be 38 61 10 00       	mov    esi,0x106138
  10aa5a:	bf 00 e0 10 00       	mov    edi,0x10e000
  10aa5f:	b8 00 00 00 00       	mov    eax,0x0
  10aa64:	e8 8e 22 00 00       	call   10ccf7 <klog_write_fmt>
  10aa69:	bf 00 e0 10 00       	mov    edi,0x10e000
  10aa6e:	e8 ab eb ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10aa73:	fa                   	cli    
  10aa74:	f4                   	hlt    
  kassert((physical_address & 0x1FFFFF) == 0);
  10aa75:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10aa79:	25 ff ff 1f 00       	and    eax,0x1fffff
  10aa7e:	48 85 c0             	test   rax,rax
  10aa81:	74 30                	je     10aab3 <kmem_map_physical_to_virtual_2MB+0x8c>
  10aa83:	41 b8 e0 6b 10 00    	mov    r8d,0x106be0
  10aa89:	b9 33 00 00 00       	mov    ecx,0x33
  10aa8e:	ba 20 6c 10 00       	mov    edx,0x106c20
  10aa93:	be 38 61 10 00       	mov    esi,0x106138
  10aa98:	bf 00 e0 10 00       	mov    edi,0x10e000
  10aa9d:	b8 00 00 00 00       	mov    eax,0x0
  10aaa2:	e8 50 22 00 00       	call   10ccf7 <klog_write_fmt>
  10aaa7:	bf 00 e0 10 00       	mov    edi,0x10e000
  10aaac:	e8 6d eb ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10aab1:	fa                   	cli    
  10aab2:	f4                   	hlt    
  uintptr_t p4_index = (virtual_address >> 39) & 0x1FF;
  10aab3:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10aab7:	48 c1 e8 27          	shr    rax,0x27
  10aabb:	25 ff 01 00 00       	and    eax,0x1ff
  10aac0:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  uintptr_t p3_index = (virtual_address >> 30) & 0x1FF;
  10aac4:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10aac8:	48 c1 e8 1e          	shr    rax,0x1e
  10aacc:	25 ff 01 00 00       	and    eax,0x1ff
  10aad1:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
  uintptr_t p2_index = (virtual_address >> 21) & 0x1FF;
  10aad5:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10aad9:	48 c1 e8 15          	shr    rax,0x15
  10aadd:	25 ff 01 00 00       	and    eax,0x1ff
  10aae2:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
  kassert(p4_index == 0 && p3_index == 0);
  10aae6:	48 83 7d f8 00       	cmp    QWORD PTR [rbp-0x8],0x0
  10aaeb:	75 07                	jne    10aaf4 <kmem_map_physical_to_virtual_2MB+0xcd>
  10aaed:	48 83 7d f0 00       	cmp    QWORD PTR [rbp-0x10],0x0
  10aaf2:	74 30                	je     10ab24 <kmem_map_physical_to_virtual_2MB+0xfd>
  10aaf4:	41 b8 e0 6b 10 00    	mov    r8d,0x106be0
  10aafa:	b9 37 00 00 00       	mov    ecx,0x37
  10aaff:	ba 48 6c 10 00       	mov    edx,0x106c48
  10ab04:	be 38 61 10 00       	mov    esi,0x106138
  10ab09:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ab0e:	b8 00 00 00 00       	mov    eax,0x0
  10ab13:	e8 df 21 00 00       	call   10ccf7 <klog_write_fmt>
  10ab18:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ab1d:	e8 fc ea ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10ab22:	fa                   	cli    
  10ab23:	f4                   	hlt    
  kassert(g_p2_table.entries[p2_index] == 0);
  10ab24:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10ab28:	48 8b 04 c5 00 40 12 	mov    rax,QWORD PTR [rax*8+0x124000]
  10ab2f:	00 
  10ab30:	48 85 c0             	test   rax,rax
  10ab33:	74 30                	je     10ab65 <kmem_map_physical_to_virtual_2MB+0x13e>
  10ab35:	41 b8 e0 6b 10 00    	mov    r8d,0x106be0
  10ab3b:	b9 38 00 00 00       	mov    ecx,0x38
  10ab40:	ba 68 6c 10 00       	mov    edx,0x106c68
  10ab45:	be 38 61 10 00       	mov    esi,0x106138
  10ab4a:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ab4f:	b8 00 00 00 00       	mov    eax,0x0
  10ab54:	e8 9e 21 00 00       	call   10ccf7 <klog_write_fmt>
  10ab59:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ab5e:	e8 bb ea ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10ab63:	fa                   	cli    
  10ab64:	f4                   	hlt    
  g_p2_table.entries[p2_index] = physical_address | PAGE_PRESENT_BIT | PAGE_HUGE_BIT | PAGE_WRITEABLE_BIT;
  10ab65:	b8 01 00 00 00       	mov    eax,0x1
  10ab6a:	48 0b 45 d8          	or     rax,QWORD PTR [rbp-0x28]
  10ab6e:	ba 80 00 00 00       	mov    edx,0x80
  10ab73:	48 09 d0             	or     rax,rdx
  10ab76:	ba 02 00 00 00       	mov    edx,0x2
  10ab7b:	48 09 c2             	or     rdx,rax
  10ab7e:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10ab82:	48 89 14 c5 00 40 12 	mov    QWORD PTR [rax*8+0x124000],rdx
  10ab89:	00 
}
  10ab8a:	90                   	nop
  10ab8b:	c9                   	leave  
  10ab8c:	c3                   	ret    

000000000010ab8d <kmem_map_unaligned_physical_to_aligned_virtual_2MB>:

uintptr_t kmem_map_unaligned_physical_to_aligned_virtual_2MB(uintptr_t requested_physical_address, uintptr_t virtual_address){
  10ab8d:	55                   	push   rbp
  10ab8e:	48 89 e5             	mov    rbp,rsp
  10ab91:	48 83 ec 20          	sub    rsp,0x20
  10ab95:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10ab99:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  uint64_t physical_address_to_map = requested_physical_address;
  10ab9d:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10aba1:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
	uint64_t displacement_from_page_boundray = requested_physical_address & 0x1FFFFF;
  10aba5:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10aba9:	25 ff ff 1f 00       	and    eax,0x1fffff
  10abae:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
  physical_address_to_map -= displacement_from_page_boundray;
  10abb2:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10abb6:	48 29 45 f8          	sub    QWORD PTR [rbp-0x8],rax
  kmem_map_physical_to_virtual_2MB(physical_address_to_map, virtual_address);
  10abba:	48 8b 55 e0          	mov    rdx,QWORD PTR [rbp-0x20]
  10abbe:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10abc2:	48 89 d6             	mov    rsi,rdx
  10abc5:	48 89 c7             	mov    rdi,rax
  10abc8:	e8 5a fe ff ff       	call   10aa27 <kmem_map_physical_to_virtual_2MB>
  return displacement_from_page_boundray;
  10abcd:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
}
  10abd1:	c9                   	leave  
  10abd2:	c3                   	ret    

000000000010abd3 <kmem_initalize>:

void kmem_initalize(){
  10abd3:	55                   	push   rbp
  10abd4:	48 89 e5             	mov    rbp,rsp
  g_p2_table.entries[1] = (uintptr_t)&g_p1_table.entries[0] | PAGE_WRITEABLE_BIT | PAGE_PRESENT_BIT;
  10abd7:	ba 02 00 00 00       	mov    edx,0x2
  10abdc:	b8 01 00 00 00       	mov    eax,0x1
  10abe1:	48 09 d0             	or     rax,rdx
  10abe4:	ba 00 10 12 00       	mov    edx,0x121000
  10abe9:	48 09 d0             	or     rax,rdx
  10abec:	48 89 05 15 94 01 00 	mov    QWORD PTR [rip+0x19415],rax        # 124008 <g_p2_table+0x8>
	g_current_page_index = 2;
  10abf3:	c7 05 03 54 01 00 02 	mov    DWORD PTR [rip+0x15403],0x2        # 120000 <g_current_page_index>
  10abfa:	00 00 00 
}
  10abfd:	90                   	nop
  10abfe:	5d                   	pop    rbp
  10abff:	c3                   	ret    

000000000010ac00 <ap_entry_procedure>:
#include "multiboot2.h"
#include "hardware_serial.c"
#include "kernel_memory.c"

extern void
ap_entry_procedure(void){
  10ac00:	55                   	push   rbp
  10ac01:	48 89 e5             	mov    rbp,rsp
  asm volatile("hlt");
  10ac04:	f4                   	hlt    
}
  10ac05:	90                   	nop
  10ac06:	5d                   	pop    rbp
  10ac07:	c3                   	ret    

000000000010ac08 <dw_get_tag_string>:
#define _(attrib_name, attrib_value) \
else if (attrib_value == value) { \
  return #attrib_name; \
}

const char *dw_get_tag_string(uint32_t value) {
  10ac08:	55                   	push   rbp
  10ac09:	48 89 e5             	mov    rbp,rsp
  10ac0c:	48 83 ec 08          	sub    rsp,0x8
  10ac10:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
  if (0) {} DW_TAG_META_LIST
  10ac13:	83 7d fc 01          	cmp    DWORD PTR [rbp-0x4],0x1
  10ac17:	75 0a                	jne    10ac23 <dw_get_tag_string+0x1b>
  10ac19:	b8 60 6f 10 00       	mov    eax,0x106f60
  10ac1e:	e9 c0 03 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ac23:	83 7d fc 02          	cmp    DWORD PTR [rbp-0x4],0x2
  10ac27:	75 0a                	jne    10ac33 <dw_get_tag_string+0x2b>
  10ac29:	b8 72 6f 10 00       	mov    eax,0x106f72
  10ac2e:	e9 b0 03 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ac33:	83 7d fc 03          	cmp    DWORD PTR [rbp-0x4],0x3
  10ac37:	75 0a                	jne    10ac43 <dw_get_tag_string+0x3b>
  10ac39:	b8 84 6f 10 00       	mov    eax,0x106f84
  10ac3e:	e9 a0 03 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ac43:	83 7d fc 04          	cmp    DWORD PTR [rbp-0x4],0x4
  10ac47:	75 0a                	jne    10ac53 <dw_get_tag_string+0x4b>
  10ac49:	b8 97 6f 10 00       	mov    eax,0x106f97
  10ac4e:	e9 90 03 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ac53:	83 7d fc 05          	cmp    DWORD PTR [rbp-0x4],0x5
  10ac57:	75 0a                	jne    10ac63 <dw_get_tag_string+0x5b>
  10ac59:	b8 af 6f 10 00       	mov    eax,0x106faf
  10ac5e:	e9 80 03 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ac63:	83 7d fc 08          	cmp    DWORD PTR [rbp-0x4],0x8
  10ac67:	75 0a                	jne    10ac73 <dw_get_tag_string+0x6b>
  10ac69:	b8 c7 6f 10 00       	mov    eax,0x106fc7
  10ac6e:	e9 70 03 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ac73:	83 7d fc 0a          	cmp    DWORD PTR [rbp-0x4],0xa
  10ac77:	75 0a                	jne    10ac83 <dw_get_tag_string+0x7b>
  10ac79:	b8 e3 6f 10 00       	mov    eax,0x106fe3
  10ac7e:	e9 60 03 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ac83:	83 7d fc 0b          	cmp    DWORD PTR [rbp-0x4],0xb
  10ac87:	75 0a                	jne    10ac93 <dw_get_tag_string+0x8b>
  10ac89:	b8 f0 6f 10 00       	mov    eax,0x106ff0
  10ac8e:	e9 50 03 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ac93:	83 7d fc 0d          	cmp    DWORD PTR [rbp-0x4],0xd
  10ac97:	75 0a                	jne    10aca3 <dw_get_tag_string+0x9b>
  10ac99:	b8 05 70 10 00       	mov    eax,0x107005
  10ac9e:	e9 40 03 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10aca3:	83 7d fc 0f          	cmp    DWORD PTR [rbp-0x4],0xf
  10aca7:	75 0a                	jne    10acb3 <dw_get_tag_string+0xab>
  10aca9:	b8 13 70 10 00       	mov    eax,0x107013
  10acae:	e9 30 03 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10acb3:	83 7d fc 10          	cmp    DWORD PTR [rbp-0x4],0x10
  10acb7:	75 0a                	jne    10acc3 <dw_get_tag_string+0xbb>
  10acb9:	b8 27 70 10 00       	mov    eax,0x107027
  10acbe:	e9 20 03 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10acc3:	83 7d fc 11          	cmp    DWORD PTR [rbp-0x4],0x11
  10acc7:	75 0a                	jne    10acd3 <dw_get_tag_string+0xcb>
  10acc9:	b8 3d 70 10 00       	mov    eax,0x10703d
  10acce:	e9 10 03 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10acd3:	83 7d fc 12          	cmp    DWORD PTR [rbp-0x4],0x12
  10acd7:	75 0a                	jne    10ace3 <dw_get_tag_string+0xdb>
  10acd9:	b8 51 70 10 00       	mov    eax,0x107051
  10acde:	e9 00 03 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ace3:	83 7d fc 13          	cmp    DWORD PTR [rbp-0x4],0x13
  10ace7:	75 0a                	jne    10acf3 <dw_get_tag_string+0xeb>
  10ace9:	b8 64 70 10 00       	mov    eax,0x107064
  10acee:	e9 f0 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10acf3:	83 7d fc 15          	cmp    DWORD PTR [rbp-0x4],0x15
  10acf7:	75 0a                	jne    10ad03 <dw_get_tag_string+0xfb>
  10acf9:	b8 7a 70 10 00       	mov    eax,0x10707a
  10acfe:	e9 e0 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ad03:	83 7d fc 16          	cmp    DWORD PTR [rbp-0x4],0x16
  10ad07:	75 0a                	jne    10ad13 <dw_get_tag_string+0x10b>
  10ad09:	b8 91 70 10 00       	mov    eax,0x107091
  10ad0e:	e9 d0 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ad13:	83 7d fc 17          	cmp    DWORD PTR [rbp-0x4],0x17
  10ad17:	75 0a                	jne    10ad23 <dw_get_tag_string+0x11b>
  10ad19:	b8 a0 70 10 00       	mov    eax,0x1070a0
  10ad1e:	e9 c0 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ad23:	83 7d fc 18          	cmp    DWORD PTR [rbp-0x4],0x18
  10ad27:	75 0a                	jne    10ad33 <dw_get_tag_string+0x12b>
  10ad29:	b8 b2 70 10 00       	mov    eax,0x1070b2
  10ad2e:	e9 b0 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ad33:	83 7d fc 19          	cmp    DWORD PTR [rbp-0x4],0x19
  10ad37:	75 0a                	jne    10ad43 <dw_get_tag_string+0x13b>
  10ad39:	b8 d0 70 10 00       	mov    eax,0x1070d0
  10ad3e:	e9 a0 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ad43:	83 7d fc 1a          	cmp    DWORD PTR [rbp-0x4],0x1a
  10ad47:	75 0a                	jne    10ad53 <dw_get_tag_string+0x14b>
  10ad49:	b8 df 70 10 00       	mov    eax,0x1070df
  10ad4e:	e9 90 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ad53:	83 7d fc 1b          	cmp    DWORD PTR [rbp-0x4],0x1b
  10ad57:	75 0a                	jne    10ad63 <dw_get_tag_string+0x15b>
  10ad59:	b8 f3 70 10 00       	mov    eax,0x1070f3
  10ad5e:	e9 80 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ad63:	83 7d fc 1c          	cmp    DWORD PTR [rbp-0x4],0x1c
  10ad67:	75 0a                	jne    10ad73 <dw_get_tag_string+0x16b>
  10ad69:	b8 0b 71 10 00       	mov    eax,0x10710b
  10ad6e:	e9 70 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ad73:	83 7d fc 1d          	cmp    DWORD PTR [rbp-0x4],0x1d
  10ad77:	75 0a                	jne    10ad83 <dw_get_tag_string+0x17b>
  10ad79:	b8 1e 71 10 00       	mov    eax,0x10711e
  10ad7e:	e9 60 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ad83:	83 7d fc 1e          	cmp    DWORD PTR [rbp-0x4],0x1e
  10ad87:	75 0a                	jne    10ad93 <dw_get_tag_string+0x18b>
  10ad89:	b8 38 71 10 00       	mov    eax,0x107138
  10ad8e:	e9 50 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ad93:	83 7d fc 1f          	cmp    DWORD PTR [rbp-0x4],0x1f
  10ad97:	75 0a                	jne    10ada3 <dw_get_tag_string+0x19b>
  10ad99:	b8 46 71 10 00       	mov    eax,0x107146
  10ad9e:	e9 40 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ada3:	83 7d fc 20          	cmp    DWORD PTR [rbp-0x4],0x20
  10ada7:	75 0a                	jne    10adb3 <dw_get_tag_string+0x1ab>
  10ada9:	b8 60 71 10 00       	mov    eax,0x107160
  10adae:	e9 30 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10adb3:	83 7d fc 21          	cmp    DWORD PTR [rbp-0x4],0x21
  10adb7:	75 0a                	jne    10adc3 <dw_get_tag_string+0x1bb>
  10adb9:	b8 70 71 10 00       	mov    eax,0x107170
  10adbe:	e9 20 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10adc3:	83 7d fc 22          	cmp    DWORD PTR [rbp-0x4],0x22
  10adc7:	75 0a                	jne    10add3 <dw_get_tag_string+0x1cb>
  10adc9:	b8 85 71 10 00       	mov    eax,0x107185
  10adce:	e9 10 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10add3:	83 7d fc 23          	cmp    DWORD PTR [rbp-0x4],0x23
  10add7:	75 0a                	jne    10ade3 <dw_get_tag_string+0x1db>
  10add9:	b8 96 71 10 00       	mov    eax,0x107196
  10adde:	e9 00 02 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ade3:	83 7d fc 24          	cmp    DWORD PTR [rbp-0x4],0x24
  10ade7:	75 0a                	jne    10adf3 <dw_get_tag_string+0x1eb>
  10ade9:	b8 b0 71 10 00       	mov    eax,0x1071b0
  10adee:	e9 f0 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10adf3:	83 7d fc 25          	cmp    DWORD PTR [rbp-0x4],0x25
  10adf7:	75 0a                	jne    10ae03 <dw_get_tag_string+0x1fb>
  10adf9:	b8 c1 71 10 00       	mov    eax,0x1071c1
  10adfe:	e9 e0 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ae03:	83 7d fc 26          	cmp    DWORD PTR [rbp-0x4],0x26
  10ae07:	75 0a                	jne    10ae13 <dw_get_tag_string+0x20b>
  10ae09:	b8 d4 71 10 00       	mov    eax,0x1071d4
  10ae0e:	e9 d0 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ae13:	83 7d fc 27          	cmp    DWORD PTR [rbp-0x4],0x27
  10ae17:	75 0a                	jne    10ae23 <dw_get_tag_string+0x21b>
  10ae19:	b8 e6 71 10 00       	mov    eax,0x1071e6
  10ae1e:	e9 c0 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ae23:	83 7d fc 28          	cmp    DWORD PTR [rbp-0x4],0x28
  10ae27:	75 0a                	jne    10ae33 <dw_get_tag_string+0x22b>
  10ae29:	b8 f6 71 10 00       	mov    eax,0x1071f6
  10ae2e:	e9 b0 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ae33:	83 7d fc 29          	cmp    DWORD PTR [rbp-0x4],0x29
  10ae37:	75 0a                	jne    10ae43 <dw_get_tag_string+0x23b>
  10ae39:	b8 08 72 10 00       	mov    eax,0x107208
  10ae3e:	e9 a0 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ae43:	83 7d fc 2a          	cmp    DWORD PTR [rbp-0x4],0x2a
  10ae47:	75 0a                	jne    10ae53 <dw_get_tag_string+0x24b>
  10ae49:	b8 19 72 10 00       	mov    eax,0x107219
  10ae4e:	e9 90 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ae53:	83 7d fc 2b          	cmp    DWORD PTR [rbp-0x4],0x2b
  10ae57:	75 0a                	jne    10ae63 <dw_get_tag_string+0x25b>
  10ae59:	b8 27 72 10 00       	mov    eax,0x107227
  10ae5e:	e9 80 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ae63:	83 7d fc 2c          	cmp    DWORD PTR [rbp-0x4],0x2c
  10ae67:	75 0a                	jne    10ae73 <dw_get_tag_string+0x26b>
  10ae69:	b8 37 72 10 00       	mov    eax,0x107237
  10ae6e:	e9 70 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ae73:	83 7d fc 2d          	cmp    DWORD PTR [rbp-0x4],0x2d
  10ae77:	75 0a                	jne    10ae83 <dw_get_tag_string+0x27b>
  10ae79:	b8 4c 72 10 00       	mov    eax,0x10724c
  10ae7e:	e9 60 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ae83:	83 7d fc 2e          	cmp    DWORD PTR [rbp-0x4],0x2e
  10ae87:	75 0a                	jne    10ae93 <dw_get_tag_string+0x28b>
  10ae89:	b8 5f 72 10 00       	mov    eax,0x10725f
  10ae8e:	e9 50 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10ae93:	83 7d fc 2f          	cmp    DWORD PTR [rbp-0x4],0x2f
  10ae97:	75 0a                	jne    10aea3 <dw_get_tag_string+0x29b>
  10ae99:	b8 78 72 10 00       	mov    eax,0x107278
  10ae9e:	e9 40 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10aea3:	83 7d fc 30          	cmp    DWORD PTR [rbp-0x4],0x30
  10aea7:	75 0a                	jne    10aeb3 <dw_get_tag_string+0x2ab>
  10aea9:	b8 98 72 10 00       	mov    eax,0x107298
  10aeae:	e9 30 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10aeb3:	83 7d fc 31          	cmp    DWORD PTR [rbp-0x4],0x31
  10aeb7:	75 0a                	jne    10aec3 <dw_get_tag_string+0x2bb>
  10aeb9:	b8 b8 72 10 00       	mov    eax,0x1072b8
  10aebe:	e9 20 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10aec3:	83 7d fc 32          	cmp    DWORD PTR [rbp-0x4],0x32
  10aec7:	75 0a                	jne    10aed3 <dw_get_tag_string+0x2cb>
  10aec9:	b8 cb 72 10 00       	mov    eax,0x1072cb
  10aece:	e9 10 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10aed3:	83 7d fc 33          	cmp    DWORD PTR [rbp-0x4],0x33
  10aed7:	75 0a                	jne    10aee3 <dw_get_tag_string+0x2db>
  10aed9:	b8 dc 72 10 00       	mov    eax,0x1072dc
  10aede:	e9 00 01 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10aee3:	83 7d fc 34          	cmp    DWORD PTR [rbp-0x4],0x34
  10aee7:	75 0a                	jne    10aef3 <dw_get_tag_string+0x2eb>
  10aee9:	b8 f0 72 10 00       	mov    eax,0x1072f0
  10aeee:	e9 f0 00 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10aef3:	83 7d fc 35          	cmp    DWORD PTR [rbp-0x4],0x35
  10aef7:	75 0a                	jne    10af03 <dw_get_tag_string+0x2fb>
  10aef9:	b8 00 73 10 00       	mov    eax,0x107300
  10aefe:	e9 e0 00 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10af03:	83 7d fc 36          	cmp    DWORD PTR [rbp-0x4],0x36
  10af07:	75 0a                	jne    10af13 <dw_get_tag_string+0x30b>
  10af09:	b8 15 73 10 00       	mov    eax,0x107315
  10af0e:	e9 d0 00 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10af13:	83 7d fc 37          	cmp    DWORD PTR [rbp-0x4],0x37
  10af17:	75 0a                	jne    10af23 <dw_get_tag_string+0x31b>
  10af19:	b8 2c 73 10 00       	mov    eax,0x10732c
  10af1e:	e9 c0 00 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10af23:	83 7d fc 38          	cmp    DWORD PTR [rbp-0x4],0x38
  10af27:	75 0a                	jne    10af33 <dw_get_tag_string+0x32b>
  10af29:	b8 41 73 10 00       	mov    eax,0x107341
  10af2e:	e9 b0 00 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10af33:	83 7d fc 39          	cmp    DWORD PTR [rbp-0x4],0x39
  10af37:	75 0a                	jne    10af43 <dw_get_tag_string+0x33b>
  10af39:	b8 57 73 10 00       	mov    eax,0x107357
  10af3e:	e9 a0 00 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10af43:	83 7d fc 3a          	cmp    DWORD PTR [rbp-0x4],0x3a
  10af47:	75 0a                	jne    10af53 <dw_get_tag_string+0x34b>
  10af49:	b8 68 73 10 00       	mov    eax,0x107368
  10af4e:	e9 90 00 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10af53:	83 7d fc 3b          	cmp    DWORD PTR [rbp-0x4],0x3b
  10af57:	75 0a                	jne    10af63 <dw_get_tag_string+0x35b>
  10af59:	b8 7f 73 10 00       	mov    eax,0x10737f
  10af5e:	e9 80 00 00 00       	jmp    10afe3 <dw_get_tag_string+0x3db>
  10af63:	83 7d fc 3c          	cmp    DWORD PTR [rbp-0x4],0x3c
  10af67:	75 07                	jne    10af70 <dw_get_tag_string+0x368>
  10af69:	b8 97 73 10 00       	mov    eax,0x107397
  10af6e:	eb 73                	jmp    10afe3 <dw_get_tag_string+0x3db>
  10af70:	83 7d fc 3d          	cmp    DWORD PTR [rbp-0x4],0x3d
  10af74:	75 07                	jne    10af7d <dw_get_tag_string+0x375>
  10af76:	b8 ab 73 10 00       	mov    eax,0x1073ab
  10af7b:	eb 66                	jmp    10afe3 <dw_get_tag_string+0x3db>
  10af7d:	83 7d fc 3f          	cmp    DWORD PTR [rbp-0x4],0x3f
  10af81:	75 07                	jne    10af8a <dw_get_tag_string+0x382>
  10af83:	b8 c0 73 10 00       	mov    eax,0x1073c0
  10af88:	eb 59                	jmp    10afe3 <dw_get_tag_string+0x3db>
  10af8a:	83 7d fc 40          	cmp    DWORD PTR [rbp-0x4],0x40
  10af8e:	75 07                	jne    10af97 <dw_get_tag_string+0x38f>
  10af90:	b8 d1 73 10 00       	mov    eax,0x1073d1
  10af95:	eb 4c                	jmp    10afe3 <dw_get_tag_string+0x3db>
  10af97:	83 7d fc 41          	cmp    DWORD PTR [rbp-0x4],0x41
  10af9b:	75 07                	jne    10afa4 <dw_get_tag_string+0x39c>
  10af9d:	b8 e4 73 10 00       	mov    eax,0x1073e4
  10afa2:	eb 3f                	jmp    10afe3 <dw_get_tag_string+0x3db>
  10afa4:	83 7d fc 42          	cmp    DWORD PTR [rbp-0x4],0x42
  10afa8:	75 07                	jne    10afb1 <dw_get_tag_string+0x3a9>
  10afaa:	b8 f5 73 10 00       	mov    eax,0x1073f5
  10afaf:	eb 32                	jmp    10afe3 <dw_get_tag_string+0x3db>
  10afb1:	83 7d fc 43          	cmp    DWORD PTR [rbp-0x4],0x43
  10afb5:	75 07                	jne    10afbe <dw_get_tag_string+0x3b6>
  10afb7:	b8 12 74 10 00       	mov    eax,0x107412
  10afbc:	eb 25                	jmp    10afe3 <dw_get_tag_string+0x3db>
  10afbe:	81 7d fc 80 40 00 00 	cmp    DWORD PTR [rbp-0x4],0x4080
  10afc5:	75 07                	jne    10afce <dw_get_tag_string+0x3c6>
  10afc7:	b8 28 74 10 00       	mov    eax,0x107428
  10afcc:	eb 15                	jmp    10afe3 <dw_get_tag_string+0x3db>
  10afce:	81 7d fc ff ff 00 00 	cmp    DWORD PTR [rbp-0x4],0xffff
  10afd5:	75 07                	jne    10afde <dw_get_tag_string+0x3d6>
  10afd7:	b8 37 74 10 00       	mov    eax,0x107437
  10afdc:	eb 05                	jmp    10afe3 <dw_get_tag_string+0x3db>
  else { return "INVALID!!!"; }
  10afde:	b8 46 74 10 00       	mov    eax,0x107446
}
  10afe3:	c9                   	leave  
  10afe4:	c3                   	ret    

000000000010afe5 <dw_get_attrib_string>:

const char *dw_get_attrib_string(uint32_t value) {
  10afe5:	55                   	push   rbp
  10afe6:	48 89 e5             	mov    rbp,rsp
  10afe9:	48 83 ec 08          	sub    rsp,0x8
  10afed:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
  if (0) {} DW_AT_META_LIST
  10aff0:	83 7d fc 01          	cmp    DWORD PTR [rbp-0x4],0x1
  10aff4:	75 0a                	jne    10b000 <dw_get_attrib_string+0x1b>
  10aff6:	b8 51 74 10 00       	mov    eax,0x107451
  10affb:	e9 c0 05 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b000:	83 7d fc 02          	cmp    DWORD PTR [rbp-0x4],0x2
  10b004:	75 0a                	jne    10b010 <dw_get_attrib_string+0x2b>
  10b006:	b8 5f 74 10 00       	mov    eax,0x10745f
  10b00b:	e9 b0 05 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b010:	83 7d fc 03          	cmp    DWORD PTR [rbp-0x4],0x3
  10b014:	75 0a                	jne    10b020 <dw_get_attrib_string+0x3b>
  10b016:	b8 6e 74 10 00       	mov    eax,0x10746e
  10b01b:	e9 a0 05 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b020:	83 7d fc 09          	cmp    DWORD PTR [rbp-0x4],0x9
  10b024:	75 0a                	jne    10b030 <dw_get_attrib_string+0x4b>
  10b026:	b8 79 74 10 00       	mov    eax,0x107479
  10b02b:	e9 90 05 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b030:	83 7d fc 0b          	cmp    DWORD PTR [rbp-0x4],0xb
  10b034:	75 0a                	jne    10b040 <dw_get_attrib_string+0x5b>
  10b036:	b8 88 74 10 00       	mov    eax,0x107488
  10b03b:	e9 80 05 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b040:	83 7d fc 0c          	cmp    DWORD PTR [rbp-0x4],0xc
  10b044:	75 0a                	jne    10b050 <dw_get_attrib_string+0x6b>
  10b046:	b8 98 74 10 00       	mov    eax,0x107498
  10b04b:	e9 70 05 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b050:	83 7d fc 0d          	cmp    DWORD PTR [rbp-0x4],0xd
  10b054:	75 0a                	jne    10b060 <dw_get_attrib_string+0x7b>
  10b056:	b8 a9 74 10 00       	mov    eax,0x1074a9
  10b05b:	e9 60 05 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b060:	83 7d fc 10          	cmp    DWORD PTR [rbp-0x4],0x10
  10b064:	75 0a                	jne    10b070 <dw_get_attrib_string+0x8b>
  10b066:	b8 b8 74 10 00       	mov    eax,0x1074b8
  10b06b:	e9 50 05 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b070:	83 7d fc 11          	cmp    DWORD PTR [rbp-0x4],0x11
  10b074:	75 0a                	jne    10b080 <dw_get_attrib_string+0x9b>
  10b076:	b8 c8 74 10 00       	mov    eax,0x1074c8
  10b07b:	e9 40 05 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b080:	83 7d fc 12          	cmp    DWORD PTR [rbp-0x4],0x12
  10b084:	75 0a                	jne    10b090 <dw_get_attrib_string+0xab>
  10b086:	b8 d5 74 10 00       	mov    eax,0x1074d5
  10b08b:	e9 30 05 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b090:	83 7d fc 13          	cmp    DWORD PTR [rbp-0x4],0x13
  10b094:	75 0a                	jne    10b0a0 <dw_get_attrib_string+0xbb>
  10b096:	b8 e3 74 10 00       	mov    eax,0x1074e3
  10b09b:	e9 20 05 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b0a0:	83 7d fc 15          	cmp    DWORD PTR [rbp-0x4],0x15
  10b0a4:	75 0a                	jne    10b0b0 <dw_get_attrib_string+0xcb>
  10b0a6:	b8 f2 74 10 00       	mov    eax,0x1074f2
  10b0ab:	e9 10 05 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b0b0:	83 7d fc 16          	cmp    DWORD PTR [rbp-0x4],0x16
  10b0b4:	75 0a                	jne    10b0c0 <dw_get_attrib_string+0xdb>
  10b0b6:	b8 fe 74 10 00       	mov    eax,0x1074fe
  10b0bb:	e9 00 05 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b0c0:	83 7d fc 17          	cmp    DWORD PTR [rbp-0x4],0x17
  10b0c4:	75 0a                	jne    10b0d0 <dw_get_attrib_string+0xeb>
  10b0c6:	b8 10 75 10 00       	mov    eax,0x107510
  10b0cb:	e9 f0 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b0d0:	83 7d fc 18          	cmp    DWORD PTR [rbp-0x4],0x18
  10b0d4:	75 0a                	jne    10b0e0 <dw_get_attrib_string+0xfb>
  10b0d6:	b8 21 75 10 00       	mov    eax,0x107521
  10b0db:	e9 e0 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b0e0:	83 7d fc 19          	cmp    DWORD PTR [rbp-0x4],0x19
  10b0e4:	75 0a                	jne    10b0f0 <dw_get_attrib_string+0x10b>
  10b0e6:	b8 2e 75 10 00       	mov    eax,0x10752e
  10b0eb:	e9 d0 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b0f0:	83 7d fc 1a          	cmp    DWORD PTR [rbp-0x4],0x1a
  10b0f4:	75 0a                	jne    10b100 <dw_get_attrib_string+0x11b>
  10b0f6:	b8 42 75 10 00       	mov    eax,0x107542
  10b0fb:	e9 c0 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b100:	83 7d fc 1b          	cmp    DWORD PTR [rbp-0x4],0x1b
  10b104:	75 0a                	jne    10b110 <dw_get_attrib_string+0x12b>
  10b106:	b8 59 75 10 00       	mov    eax,0x107559
  10b10b:	e9 b0 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b110:	83 7d fc 1c          	cmp    DWORD PTR [rbp-0x4],0x1c
  10b114:	75 0a                	jne    10b120 <dw_get_attrib_string+0x13b>
  10b116:	b8 68 75 10 00       	mov    eax,0x107568
  10b11b:	e9 a0 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b120:	83 7d fc 1d          	cmp    DWORD PTR [rbp-0x4],0x1d
  10b124:	75 0a                	jne    10b130 <dw_get_attrib_string+0x14b>
  10b126:	b8 7a 75 10 00       	mov    eax,0x10757a
  10b12b:	e9 90 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b130:	83 7d fc 1e          	cmp    DWORD PTR [rbp-0x4],0x1e
  10b134:	75 0a                	jne    10b140 <dw_get_attrib_string+0x15b>
  10b136:	b8 90 75 10 00       	mov    eax,0x107590
  10b13b:	e9 80 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b140:	83 7d fc 20          	cmp    DWORD PTR [rbp-0x4],0x20
  10b144:	75 0a                	jne    10b150 <dw_get_attrib_string+0x16b>
  10b146:	b8 a4 75 10 00       	mov    eax,0x1075a4
  10b14b:	e9 70 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b150:	83 7d fc 21          	cmp    DWORD PTR [rbp-0x4],0x21
  10b154:	75 0a                	jne    10b160 <dw_get_attrib_string+0x17b>
  10b156:	b8 b1 75 10 00       	mov    eax,0x1075b1
  10b15b:	e9 60 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b160:	83 7d fc 22          	cmp    DWORD PTR [rbp-0x4],0x22
  10b164:	75 0a                	jne    10b170 <dw_get_attrib_string+0x18b>
  10b166:	b8 c3 75 10 00       	mov    eax,0x1075c3
  10b16b:	e9 50 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b170:	83 7d fc 25          	cmp    DWORD PTR [rbp-0x4],0x25
  10b174:	75 0a                	jne    10b180 <dw_get_attrib_string+0x19b>
  10b176:	b8 d5 75 10 00       	mov    eax,0x1075d5
  10b17b:	e9 40 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b180:	83 7d fc 27          	cmp    DWORD PTR [rbp-0x4],0x27
  10b184:	75 0a                	jne    10b190 <dw_get_attrib_string+0x1ab>
  10b186:	b8 e4 75 10 00       	mov    eax,0x1075e4
  10b18b:	e9 30 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b190:	83 7d fc 2a          	cmp    DWORD PTR [rbp-0x4],0x2a
  10b194:	75 0a                	jne    10b1a0 <dw_get_attrib_string+0x1bb>
  10b196:	b8 f5 75 10 00       	mov    eax,0x1075f5
  10b19b:	e9 20 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b1a0:	83 7d fc 2c          	cmp    DWORD PTR [rbp-0x4],0x2c
  10b1a4:	75 0a                	jne    10b1b0 <dw_get_attrib_string+0x1cb>
  10b1a6:	b8 07 76 10 00       	mov    eax,0x107607
  10b1ab:	e9 10 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b1b0:	83 7d fc 2e          	cmp    DWORD PTR [rbp-0x4],0x2e
  10b1b4:	75 0a                	jne    10b1c0 <dw_get_attrib_string+0x1db>
  10b1b6:	b8 19 76 10 00       	mov    eax,0x107619
  10b1bb:	e9 00 04 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b1c0:	83 7d fc 2f          	cmp    DWORD PTR [rbp-0x4],0x2f
  10b1c4:	75 0a                	jne    10b1d0 <dw_get_attrib_string+0x1eb>
  10b1c6:	b8 2a 76 10 00       	mov    eax,0x10762a
  10b1cb:	e9 f0 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b1d0:	83 7d fc 31          	cmp    DWORD PTR [rbp-0x4],0x31
  10b1d4:	75 0a                	jne    10b1e0 <dw_get_attrib_string+0x1fb>
  10b1d6:	b8 3c 76 10 00       	mov    eax,0x10763c
  10b1db:	e9 e0 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b1e0:	83 7d fc 32          	cmp    DWORD PTR [rbp-0x4],0x32
  10b1e4:	75 0a                	jne    10b1f0 <dw_get_attrib_string+0x20b>
  10b1e6:	b8 52 76 10 00       	mov    eax,0x107652
  10b1eb:	e9 d0 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b1f0:	83 7d fc 33          	cmp    DWORD PTR [rbp-0x4],0x33
  10b1f4:	75 0a                	jne    10b200 <dw_get_attrib_string+0x21b>
  10b1f6:	b8 66 76 10 00       	mov    eax,0x107666
  10b1fb:	e9 c0 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b200:	83 7d fc 34          	cmp    DWORD PTR [rbp-0x4],0x34
  10b204:	75 0a                	jne    10b210 <dw_get_attrib_string+0x22b>
  10b206:	b8 7a 76 10 00       	mov    eax,0x10767a
  10b20b:	e9 b0 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b210:	83 7d fc 35          	cmp    DWORD PTR [rbp-0x4],0x35
  10b214:	75 0a                	jne    10b220 <dw_get_attrib_string+0x23b>
  10b216:	b8 8b 76 10 00       	mov    eax,0x10768b
  10b21b:	e9 a0 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b220:	83 7d fc 36          	cmp    DWORD PTR [rbp-0x4],0x36
  10b224:	75 0a                	jne    10b230 <dw_get_attrib_string+0x24b>
  10b226:	b8 9c 76 10 00       	mov    eax,0x10769c
  10b22b:	e9 90 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b230:	83 7d fc 37          	cmp    DWORD PTR [rbp-0x4],0x37
  10b234:	75 0a                	jne    10b240 <dw_get_attrib_string+0x25b>
  10b236:	b8 b5 76 10 00       	mov    eax,0x1076b5
  10b23b:	e9 80 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b240:	83 7d fc 38          	cmp    DWORD PTR [rbp-0x4],0x38
  10b244:	75 0a                	jne    10b250 <dw_get_attrib_string+0x26b>
  10b246:	b8 c1 76 10 00       	mov    eax,0x1076c1
  10b24b:	e9 70 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b250:	83 7d fc 39          	cmp    DWORD PTR [rbp-0x4],0x39
  10b254:	75 0a                	jne    10b260 <dw_get_attrib_string+0x27b>
  10b256:	b8 dc 76 10 00       	mov    eax,0x1076dc
  10b25b:	e9 60 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b260:	83 7d fc 3a          	cmp    DWORD PTR [rbp-0x4],0x3a
  10b264:	75 0a                	jne    10b270 <dw_get_attrib_string+0x28b>
  10b266:	b8 ee 76 10 00       	mov    eax,0x1076ee
  10b26b:	e9 50 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b270:	83 7d fc 3b          	cmp    DWORD PTR [rbp-0x4],0x3b
  10b274:	75 0a                	jne    10b280 <dw_get_attrib_string+0x29b>
  10b276:	b8 fe 76 10 00       	mov    eax,0x1076fe
  10b27b:	e9 40 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b280:	83 7d fc 3c          	cmp    DWORD PTR [rbp-0x4],0x3c
  10b284:	75 0a                	jne    10b290 <dw_get_attrib_string+0x2ab>
  10b286:	b8 0e 77 10 00       	mov    eax,0x10770e
  10b28b:	e9 30 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b290:	83 7d fc 3d          	cmp    DWORD PTR [rbp-0x4],0x3d
  10b294:	75 0a                	jne    10b2a0 <dw_get_attrib_string+0x2bb>
  10b296:	b8 20 77 10 00       	mov    eax,0x107720
  10b29b:	e9 20 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b2a0:	83 7d fc 3e          	cmp    DWORD PTR [rbp-0x4],0x3e
  10b2a4:	75 0a                	jne    10b2b0 <dw_get_attrib_string+0x2cb>
  10b2a6:	b8 31 77 10 00       	mov    eax,0x107731
  10b2ab:	e9 10 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b2b0:	83 7d fc 3f          	cmp    DWORD PTR [rbp-0x4],0x3f
  10b2b4:	75 0a                	jne    10b2c0 <dw_get_attrib_string+0x2db>
  10b2b6:	b8 40 77 10 00       	mov    eax,0x107740
  10b2bb:	e9 00 03 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b2c0:	83 7d fc 40          	cmp    DWORD PTR [rbp-0x4],0x40
  10b2c4:	75 0a                	jne    10b2d0 <dw_get_attrib_string+0x2eb>
  10b2c6:	b8 4f 77 10 00       	mov    eax,0x10774f
  10b2cb:	e9 f0 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b2d0:	83 7d fc 41          	cmp    DWORD PTR [rbp-0x4],0x41
  10b2d4:	75 0a                	jne    10b2e0 <dw_get_attrib_string+0x2fb>
  10b2d6:	b8 60 77 10 00       	mov    eax,0x107760
  10b2db:	e9 e0 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b2e0:	83 7d fc 42          	cmp    DWORD PTR [rbp-0x4],0x42
  10b2e4:	75 0a                	jne    10b2f0 <dw_get_attrib_string+0x30b>
  10b2e6:	b8 6d 77 10 00       	mov    eax,0x10776d
  10b2eb:	e9 d0 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b2f0:	83 7d fc 43          	cmp    DWORD PTR [rbp-0x4],0x43
  10b2f4:	75 0a                	jne    10b300 <dw_get_attrib_string+0x31b>
  10b2f6:	b8 83 77 10 00       	mov    eax,0x107783
  10b2fb:	e9 c0 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b300:	83 7d fc 44          	cmp    DWORD PTR [rbp-0x4],0x44
  10b304:	75 0a                	jne    10b310 <dw_get_attrib_string+0x32b>
  10b306:	b8 94 77 10 00       	mov    eax,0x107794
  10b30b:	e9 b0 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b310:	83 7d fc 45          	cmp    DWORD PTR [rbp-0x4],0x45
  10b314:	75 0a                	jne    10b320 <dw_get_attrib_string+0x33b>
  10b316:	b8 a8 77 10 00       	mov    eax,0x1077a8
  10b31b:	e9 a0 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b320:	83 7d fc 46          	cmp    DWORD PTR [rbp-0x4],0x46
  10b324:	75 0a                	jne    10b330 <dw_get_attrib_string+0x34b>
  10b326:	b8 b7 77 10 00       	mov    eax,0x1077b7
  10b32b:	e9 90 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b330:	83 7d fc 47          	cmp    DWORD PTR [rbp-0x4],0x47
  10b334:	75 0a                	jne    10b340 <dw_get_attrib_string+0x35b>
  10b336:	b8 c5 77 10 00       	mov    eax,0x1077c5
  10b33b:	e9 80 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b340:	83 7d fc 48          	cmp    DWORD PTR [rbp-0x4],0x48
  10b344:	75 0a                	jne    10b350 <dw_get_attrib_string+0x36b>
  10b346:	b8 d9 77 10 00       	mov    eax,0x1077d9
  10b34b:	e9 70 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b350:	83 7d fc 49          	cmp    DWORD PTR [rbp-0x4],0x49
  10b354:	75 0a                	jne    10b360 <dw_get_attrib_string+0x37b>
  10b356:	b8 eb 77 10 00       	mov    eax,0x1077eb
  10b35b:	e9 60 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b360:	83 7d fc 4a          	cmp    DWORD PTR [rbp-0x4],0x4a
  10b364:	75 0a                	jne    10b370 <dw_get_attrib_string+0x38b>
  10b366:	b8 f6 77 10 00       	mov    eax,0x1077f6
  10b36b:	e9 50 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b370:	83 7d fc 4b          	cmp    DWORD PTR [rbp-0x4],0x4b
  10b374:	75 0a                	jne    10b380 <dw_get_attrib_string+0x39b>
  10b376:	b8 09 78 10 00       	mov    eax,0x107809
  10b37b:	e9 40 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b380:	83 7d fc 4c          	cmp    DWORD PTR [rbp-0x4],0x4c
  10b384:	75 0a                	jne    10b390 <dw_get_attrib_string+0x3ab>
  10b386:	b8 22 78 10 00       	mov    eax,0x107822
  10b38b:	e9 30 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b390:	83 7d fc 4d          	cmp    DWORD PTR [rbp-0x4],0x4d
  10b394:	75 0a                	jne    10b3a0 <dw_get_attrib_string+0x3bb>
  10b396:	b8 33 78 10 00       	mov    eax,0x107833
  10b39b:	e9 20 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b3a0:	83 7d fc 4e          	cmp    DWORD PTR [rbp-0x4],0x4e
  10b3a4:	75 0a                	jne    10b3b0 <dw_get_attrib_string+0x3cb>
  10b3a6:	b8 4e 78 10 00       	mov    eax,0x10784e
  10b3ab:	e9 10 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b3b0:	83 7d fc 4f          	cmp    DWORD PTR [rbp-0x4],0x4f
  10b3b4:	75 0a                	jne    10b3c0 <dw_get_attrib_string+0x3db>
  10b3b6:	b8 5e 78 10 00       	mov    eax,0x10785e
  10b3bb:	e9 00 02 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b3c0:	83 7d fc 50          	cmp    DWORD PTR [rbp-0x4],0x50
  10b3c4:	75 0a                	jne    10b3d0 <dw_get_attrib_string+0x3eb>
  10b3c6:	b8 6f 78 10 00       	mov    eax,0x10786f
  10b3cb:	e9 f0 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b3d0:	83 7d fc 51          	cmp    DWORD PTR [rbp-0x4],0x51
  10b3d4:	75 0a                	jne    10b3e0 <dw_get_attrib_string+0x3fb>
  10b3d6:	b8 83 78 10 00       	mov    eax,0x107883
  10b3db:	e9 e0 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b3e0:	83 7d fc 52          	cmp    DWORD PTR [rbp-0x4],0x52
  10b3e4:	75 0a                	jne    10b3f0 <dw_get_attrib_string+0x40b>
  10b3e6:	b8 95 78 10 00       	mov    eax,0x107895
  10b3eb:	e9 d0 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b3f0:	83 7d fc 53          	cmp    DWORD PTR [rbp-0x4],0x53
  10b3f4:	75 0a                	jne    10b400 <dw_get_attrib_string+0x41b>
  10b3f6:	b8 a4 78 10 00       	mov    eax,0x1078a4
  10b3fb:	e9 c0 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b400:	83 7d fc 54          	cmp    DWORD PTR [rbp-0x4],0x54
  10b404:	75 0a                	jne    10b410 <dw_get_attrib_string+0x42b>
  10b406:	b8 b3 78 10 00       	mov    eax,0x1078b3
  10b40b:	e9 b0 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b410:	83 7d fc 55          	cmp    DWORD PTR [rbp-0x4],0x55
  10b414:	75 0a                	jne    10b420 <dw_get_attrib_string+0x43b>
  10b416:	b8 c3 78 10 00       	mov    eax,0x1078c3
  10b41b:	e9 a0 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b420:	83 7d fc 56          	cmp    DWORD PTR [rbp-0x4],0x56
  10b424:	75 0a                	jne    10b430 <dw_get_attrib_string+0x44b>
  10b426:	b8 d0 78 10 00       	mov    eax,0x1078d0
  10b42b:	e9 90 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b430:	83 7d fc 57          	cmp    DWORD PTR [rbp-0x4],0x57
  10b434:	75 0a                	jne    10b440 <dw_get_attrib_string+0x45b>
  10b436:	b8 e1 78 10 00       	mov    eax,0x1078e1
  10b43b:	e9 80 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b440:	83 7d fc 58          	cmp    DWORD PTR [rbp-0x4],0x58
  10b444:	75 0a                	jne    10b450 <dw_get_attrib_string+0x46b>
  10b446:	b8 f3 78 10 00       	mov    eax,0x1078f3
  10b44b:	e9 70 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b450:	83 7d fc 59          	cmp    DWORD PTR [rbp-0x4],0x59
  10b454:	75 0a                	jne    10b460 <dw_get_attrib_string+0x47b>
  10b456:	b8 03 79 10 00       	mov    eax,0x107903
  10b45b:	e9 60 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b460:	83 7d fc 5a          	cmp    DWORD PTR [rbp-0x4],0x5a
  10b464:	75 0a                	jne    10b470 <dw_get_attrib_string+0x48b>
  10b466:	b8 13 79 10 00       	mov    eax,0x107913
  10b46b:	e9 50 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b470:	83 7d fc 5b          	cmp    DWORD PTR [rbp-0x4],0x5b
  10b474:	75 0a                	jne    10b480 <dw_get_attrib_string+0x49b>
  10b476:	b8 25 79 10 00       	mov    eax,0x107925
  10b47b:	e9 40 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b480:	83 7d fc 5c          	cmp    DWORD PTR [rbp-0x4],0x5c
  10b484:	75 0a                	jne    10b490 <dw_get_attrib_string+0x4ab>
  10b486:	b8 38 79 10 00       	mov    eax,0x107938
  10b48b:	e9 30 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b490:	83 7d fc 5d          	cmp    DWORD PTR [rbp-0x4],0x5d
  10b494:	75 0a                	jne    10b4a0 <dw_get_attrib_string+0x4bb>
  10b496:	b8 4c 79 10 00       	mov    eax,0x10794c
  10b49b:	e9 20 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b4a0:	83 7d fc 5e          	cmp    DWORD PTR [rbp-0x4],0x5e
  10b4a4:	75 0a                	jne    10b4b0 <dw_get_attrib_string+0x4cb>
  10b4a6:	b8 58 79 10 00       	mov    eax,0x107958
  10b4ab:	e9 10 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b4b0:	83 7d fc 5f          	cmp    DWORD PTR [rbp-0x4],0x5f
  10b4b4:	75 0a                	jne    10b4c0 <dw_get_attrib_string+0x4db>
  10b4b6:	b8 6b 79 10 00       	mov    eax,0x10796b
  10b4bb:	e9 00 01 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b4c0:	83 7d fc 60          	cmp    DWORD PTR [rbp-0x4],0x60
  10b4c4:	75 0a                	jne    10b4d0 <dw_get_attrib_string+0x4eb>
  10b4c6:	b8 7d 79 10 00       	mov    eax,0x10797d
  10b4cb:	e9 f0 00 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b4d0:	83 7d fc 61          	cmp    DWORD PTR [rbp-0x4],0x61
  10b4d4:	75 0a                	jne    10b4e0 <dw_get_attrib_string+0x4fb>
  10b4d6:	b8 92 79 10 00       	mov    eax,0x107992
  10b4db:	e9 e0 00 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b4e0:	83 7d fc 62          	cmp    DWORD PTR [rbp-0x4],0x62
  10b4e4:	75 0a                	jne    10b4f0 <dw_get_attrib_string+0x50b>
  10b4e6:	b8 a0 79 10 00       	mov    eax,0x1079a0
  10b4eb:	e9 d0 00 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b4f0:	83 7d fc 63          	cmp    DWORD PTR [rbp-0x4],0x63
  10b4f4:	75 0a                	jne    10b500 <dw_get_attrib_string+0x51b>
  10b4f6:	b8 b5 79 10 00       	mov    eax,0x1079b5
  10b4fb:	e9 c0 00 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b500:	83 7d fc 64          	cmp    DWORD PTR [rbp-0x4],0x64
  10b504:	75 0a                	jne    10b510 <dw_get_attrib_string+0x52b>
  10b506:	b8 c4 79 10 00       	mov    eax,0x1079c4
  10b50b:	e9 b0 00 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b510:	83 7d fc 65          	cmp    DWORD PTR [rbp-0x4],0x65
  10b514:	75 0a                	jne    10b520 <dw_get_attrib_string+0x53b>
  10b516:	b8 d9 79 10 00       	mov    eax,0x1079d9
  10b51b:	e9 a0 00 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b520:	83 7d fc 66          	cmp    DWORD PTR [rbp-0x4],0x66
  10b524:	75 0a                	jne    10b530 <dw_get_attrib_string+0x54b>
  10b526:	b8 e9 79 10 00       	mov    eax,0x1079e9
  10b52b:	e9 90 00 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b530:	83 7d fc 67          	cmp    DWORD PTR [rbp-0x4],0x67
  10b534:	75 0a                	jne    10b540 <dw_get_attrib_string+0x55b>
  10b536:	b8 f9 79 10 00       	mov    eax,0x1079f9
  10b53b:	e9 80 00 00 00       	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b540:	83 7d fc 68          	cmp    DWORD PTR [rbp-0x4],0x68
  10b544:	75 07                	jne    10b54d <dw_get_attrib_string+0x568>
  10b546:	b8 04 7a 10 00       	mov    eax,0x107a04
  10b54b:	eb 73                	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b54d:	83 7d fc 69          	cmp    DWORD PTR [rbp-0x4],0x69
  10b551:	75 07                	jne    10b55a <dw_get_attrib_string+0x575>
  10b553:	b8 14 7a 10 00       	mov    eax,0x107a14
  10b558:	eb 66                	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b55a:	83 7d fc 6a          	cmp    DWORD PTR [rbp-0x4],0x6a
  10b55e:	75 07                	jne    10b567 <dw_get_attrib_string+0x582>
  10b560:	b8 24 7a 10 00       	mov    eax,0x107a24
  10b565:	eb 59                	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b567:	83 7d fc 6b          	cmp    DWORD PTR [rbp-0x4],0x6b
  10b56b:	75 07                	jne    10b574 <dw_get_attrib_string+0x58f>
  10b56d:	b8 3a 7a 10 00       	mov    eax,0x107a3a
  10b572:	eb 4c                	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b574:	83 7d fc 6c          	cmp    DWORD PTR [rbp-0x4],0x6c
  10b578:	75 07                	jne    10b581 <dw_get_attrib_string+0x59c>
  10b57a:	b8 50 7a 10 00       	mov    eax,0x107a50
  10b57f:	eb 3f                	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b581:	83 7d fc 6d          	cmp    DWORD PTR [rbp-0x4],0x6d
  10b585:	75 07                	jne    10b58e <dw_get_attrib_string+0x5a9>
  10b587:	b8 61 7a 10 00       	mov    eax,0x107a61
  10b58c:	eb 32                	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b58e:	83 7d fc 6e          	cmp    DWORD PTR [rbp-0x4],0x6e
  10b592:	75 07                	jne    10b59b <dw_get_attrib_string+0x5b6>
  10b594:	b8 72 7a 10 00       	mov    eax,0x107a72
  10b599:	eb 25                	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b59b:	81 7d fc 00 20 00 00 	cmp    DWORD PTR [rbp-0x4],0x2000
  10b5a2:	75 07                	jne    10b5ab <dw_get_attrib_string+0x5c6>
  10b5a4:	b8 85 7a 10 00       	mov    eax,0x107a85
  10b5a9:	eb 15                	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  10b5ab:	81 7d fc ff 3f 00 00 	cmp    DWORD PTR [rbp-0x4],0x3fff
  10b5b2:	75 07                	jne    10b5bb <dw_get_attrib_string+0x5d6>
  10b5b4:	b8 93 7a 10 00       	mov    eax,0x107a93
  10b5b9:	eb 05                	jmp    10b5c0 <dw_get_attrib_string+0x5db>
  else { return "INVALID!!!"; }
  10b5bb:	b8 46 74 10 00       	mov    eax,0x107446
}
  10b5c0:	c9                   	leave  
  10b5c1:	c3                   	ret    

000000000010b5c2 <dw_get_form_string>:

const char *dw_get_form_string(uint32_t value) {
  10b5c2:	55                   	push   rbp
  10b5c3:	48 89 e5             	mov    rbp,rsp
  10b5c6:	48 83 ec 08          	sub    rsp,0x8
  10b5ca:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
  if (0) {} DW_FORM_META_LIST
  10b5cd:	83 7d fc 01          	cmp    DWORD PTR [rbp-0x4],0x1
  10b5d1:	75 0a                	jne    10b5dd <dw_get_form_string+0x1b>
  10b5d3:	b8 a1 7a 10 00       	mov    eax,0x107aa1
  10b5d8:	e9 67 01 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b5dd:	83 7d fc 03          	cmp    DWORD PTR [rbp-0x4],0x3
  10b5e1:	75 0a                	jne    10b5ed <dw_get_form_string+0x2b>
  10b5e3:	b8 ae 7a 10 00       	mov    eax,0x107aae
  10b5e8:	e9 57 01 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b5ed:	83 7d fc 04          	cmp    DWORD PTR [rbp-0x4],0x4
  10b5f1:	75 0a                	jne    10b5fd <dw_get_form_string+0x3b>
  10b5f3:	b8 bd 7a 10 00       	mov    eax,0x107abd
  10b5f8:	e9 47 01 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b5fd:	83 7d fc 05          	cmp    DWORD PTR [rbp-0x4],0x5
  10b601:	75 0a                	jne    10b60d <dw_get_form_string+0x4b>
  10b603:	b8 cc 7a 10 00       	mov    eax,0x107acc
  10b608:	e9 37 01 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b60d:	83 7d fc 06          	cmp    DWORD PTR [rbp-0x4],0x6
  10b611:	75 0a                	jne    10b61d <dw_get_form_string+0x5b>
  10b613:	b8 da 7a 10 00       	mov    eax,0x107ada
  10b618:	e9 27 01 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b61d:	83 7d fc 07          	cmp    DWORD PTR [rbp-0x4],0x7
  10b621:	75 0a                	jne    10b62d <dw_get_form_string+0x6b>
  10b623:	b8 e8 7a 10 00       	mov    eax,0x107ae8
  10b628:	e9 17 01 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b62d:	83 7d fc 08          	cmp    DWORD PTR [rbp-0x4],0x8
  10b631:	75 0a                	jne    10b63d <dw_get_form_string+0x7b>
  10b633:	b8 f6 7a 10 00       	mov    eax,0x107af6
  10b638:	e9 07 01 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b63d:	83 7d fc 09          	cmp    DWORD PTR [rbp-0x4],0x9
  10b641:	75 0a                	jne    10b64d <dw_get_form_string+0x8b>
  10b643:	b8 05 7b 10 00       	mov    eax,0x107b05
  10b648:	e9 f7 00 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b64d:	83 7d fc 0a          	cmp    DWORD PTR [rbp-0x4],0xa
  10b651:	75 0a                	jne    10b65d <dw_get_form_string+0x9b>
  10b653:	b8 13 7b 10 00       	mov    eax,0x107b13
  10b658:	e9 e7 00 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b65d:	83 7d fc 0b          	cmp    DWORD PTR [rbp-0x4],0xb
  10b661:	75 0a                	jne    10b66d <dw_get_form_string+0xab>
  10b663:	b8 22 7b 10 00       	mov    eax,0x107b22
  10b668:	e9 d7 00 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b66d:	83 7d fc 0c          	cmp    DWORD PTR [rbp-0x4],0xc
  10b671:	75 0a                	jne    10b67d <dw_get_form_string+0xbb>
  10b673:	b8 30 7b 10 00       	mov    eax,0x107b30
  10b678:	e9 c7 00 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b67d:	83 7d fc 0d          	cmp    DWORD PTR [rbp-0x4],0xd
  10b681:	75 0a                	jne    10b68d <dw_get_form_string+0xcb>
  10b683:	b8 3d 7b 10 00       	mov    eax,0x107b3d
  10b688:	e9 b7 00 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b68d:	83 7d fc 0e          	cmp    DWORD PTR [rbp-0x4],0xe
  10b691:	75 0a                	jne    10b69d <dw_get_form_string+0xdb>
  10b693:	b8 4b 7b 10 00       	mov    eax,0x107b4b
  10b698:	e9 a7 00 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b69d:	83 7d fc 0f          	cmp    DWORD PTR [rbp-0x4],0xf
  10b6a1:	75 0a                	jne    10b6ad <dw_get_form_string+0xeb>
  10b6a3:	b8 58 7b 10 00       	mov    eax,0x107b58
  10b6a8:	e9 97 00 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b6ad:	83 7d fc 10          	cmp    DWORD PTR [rbp-0x4],0x10
  10b6b1:	75 0a                	jne    10b6bd <dw_get_form_string+0xfb>
  10b6b3:	b8 66 7b 10 00       	mov    eax,0x107b66
  10b6b8:	e9 87 00 00 00       	jmp    10b744 <dw_get_form_string+0x182>
  10b6bd:	83 7d fc 11          	cmp    DWORD PTR [rbp-0x4],0x11
  10b6c1:	75 07                	jne    10b6ca <dw_get_form_string+0x108>
  10b6c3:	b8 77 7b 10 00       	mov    eax,0x107b77
  10b6c8:	eb 7a                	jmp    10b744 <dw_get_form_string+0x182>
  10b6ca:	83 7d fc 12          	cmp    DWORD PTR [rbp-0x4],0x12
  10b6ce:	75 07                	jne    10b6d7 <dw_get_form_string+0x115>
  10b6d0:	b8 84 7b 10 00       	mov    eax,0x107b84
  10b6d5:	eb 6d                	jmp    10b744 <dw_get_form_string+0x182>
  10b6d7:	83 7d fc 13          	cmp    DWORD PTR [rbp-0x4],0x13
  10b6db:	75 07                	jne    10b6e4 <dw_get_form_string+0x122>
  10b6dd:	b8 91 7b 10 00       	mov    eax,0x107b91
  10b6e2:	eb 60                	jmp    10b744 <dw_get_form_string+0x182>
  10b6e4:	83 7d fc 14          	cmp    DWORD PTR [rbp-0x4],0x14
  10b6e8:	75 07                	jne    10b6f1 <dw_get_form_string+0x12f>
  10b6ea:	b8 9e 7b 10 00       	mov    eax,0x107b9e
  10b6ef:	eb 53                	jmp    10b744 <dw_get_form_string+0x182>
  10b6f1:	83 7d fc 15          	cmp    DWORD PTR [rbp-0x4],0x15
  10b6f5:	75 07                	jne    10b6fe <dw_get_form_string+0x13c>
  10b6f7:	b8 ab 7b 10 00       	mov    eax,0x107bab
  10b6fc:	eb 46                	jmp    10b744 <dw_get_form_string+0x182>
  10b6fe:	83 7d fc 16          	cmp    DWORD PTR [rbp-0x4],0x16
  10b702:	75 07                	jne    10b70b <dw_get_form_string+0x149>
  10b704:	b8 bd 7b 10 00       	mov    eax,0x107bbd
  10b709:	eb 39                	jmp    10b744 <dw_get_form_string+0x182>
  10b70b:	83 7d fc 17          	cmp    DWORD PTR [rbp-0x4],0x17
  10b70f:	75 07                	jne    10b718 <dw_get_form_string+0x156>
  10b711:	b8 ce 7b 10 00       	mov    eax,0x107bce
  10b716:	eb 2c                	jmp    10b744 <dw_get_form_string+0x182>
  10b718:	83 7d fc 18          	cmp    DWORD PTR [rbp-0x4],0x18
  10b71c:	75 07                	jne    10b725 <dw_get_form_string+0x163>
  10b71e:	b8 e1 7b 10 00       	mov    eax,0x107be1
  10b723:	eb 1f                	jmp    10b744 <dw_get_form_string+0x182>
  10b725:	83 7d fc 19          	cmp    DWORD PTR [rbp-0x4],0x19
  10b729:	75 07                	jne    10b732 <dw_get_form_string+0x170>
  10b72b:	b8 f1 7b 10 00       	mov    eax,0x107bf1
  10b730:	eb 12                	jmp    10b744 <dw_get_form_string+0x182>
  10b732:	83 7d fc 20          	cmp    DWORD PTR [rbp-0x4],0x20
  10b736:	75 07                	jne    10b73f <dw_get_form_string+0x17d>
  10b738:	b8 06 7c 10 00       	mov    eax,0x107c06
  10b73d:	eb 05                	jmp    10b744 <dw_get_form_string+0x182>
  else { return "INVALID!!!"; }
  10b73f:	b8 46 74 10 00       	mov    eax,0x107446
}
  10b744:	c9                   	leave  
  10b745:	c3                   	ret    

000000000010b746 <kprocess_load_elf_executable>:

  return header->programEntryOffset;
}

static inline
int kprocess_load_elf_executable(uintptr_t elf_executable){
  10b746:	55                   	push   rbp
  10b747:	48 89 e5             	mov    rbp,rsp
  10b74a:	48 83 ec 30          	sub    rsp,0x30
  10b74e:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  ELF64Header *header = (ELF64Header *)elf_executable;
  10b752:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10b756:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
  if(header->magicNumber != ELF64_MAGIC_NUMBER){
  10b75a:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10b75e:	8b 00                	mov    eax,DWORD PTR [rax]
  10b760:	3d 7f 45 4c 46       	cmp    eax,0x464c457f
  10b765:	74 1e                	je     10b785 <kprocess_load_elf_executable+0x3f>
    klog_error("invalid elf file was provided");
  10b767:	be 17 7c 10 00       	mov    esi,0x107c17
  10b76c:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b771:	b8 00 00 00 00       	mov    eax,0x0
  10b776:	e8 7c 15 00 00       	call   10ccf7 <klog_write_fmt>
    return 0;
  10b77b:	b8 00 00 00 00       	mov    eax,0x0
  10b780:	e9 04 01 00 00       	jmp    10b889 <kprocess_load_elf_executable+0x143>
  }

  klog_debug("program entry offset: 0x%X", header->programEntryOffset);
  10b785:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10b789:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
  10b78d:	48 89 c2             	mov    rdx,rax
  10b790:	be 35 7c 10 00       	mov    esi,0x107c35
  10b795:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b79a:	b8 00 00 00 00       	mov    eax,0x0
  10b79f:	e8 53 15 00 00       	call   10ccf7 <klog_write_fmt>
  for(size_t i = 0; i < header->programHeaderEntryCount; i++){
  10b7a4:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10b7ab:	00 
  10b7ac:	e9 bb 00 00 00       	jmp    10b86c <kprocess_load_elf_executable+0x126>
    ELF64ProgramHeader *program_header = (ELF64ProgramHeader *)(elf_executable + header->programHeaderOffset + (i * header->programHeaderEntrySize));
  10b7b1:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10b7b5:	48 8b 50 20          	mov    rdx,QWORD PTR [rax+0x20]
  10b7b9:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10b7bd:	48 01 c2             	add    rdx,rax
  10b7c0:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10b7c4:	0f b7 40 36          	movzx  eax,WORD PTR [rax+0x36]
  10b7c8:	0f b7 c0             	movzx  eax,ax
  10b7cb:	48 0f af 45 f8       	imul   rax,QWORD PTR [rbp-0x8]
  10b7d0:	48 01 d0             	add    rax,rdx
  10b7d3:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
    klog_debug("program header entry:");
  10b7d7:	be 50 7c 10 00       	mov    esi,0x107c50
  10b7dc:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b7e1:	b8 00 00 00 00       	mov    eax,0x0
  10b7e6:	e8 0c 15 00 00       	call   10ccf7 <klog_write_fmt>
    klog_debug(" segment virtual memory location: 0x%X", program_header->virtual_address);
  10b7eb:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10b7ef:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  10b7f3:	48 89 c2             	mov    rdx,rax
  10b7f6:	be 68 7c 10 00       	mov    esi,0x107c68
  10b7fb:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b800:	b8 00 00 00 00       	mov    eax,0x0
  10b805:	e8 ed 14 00 00       	call   10ccf7 <klog_write_fmt>
    klog_debug(" segment file offset: 0x%X", program_header->offset_in_file);
  10b80a:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10b80e:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10b812:	48 89 c2             	mov    rdx,rax
  10b815:	be 8f 7c 10 00       	mov    esi,0x107c8f
  10b81a:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b81f:	b8 00 00 00 00       	mov    eax,0x0
  10b824:	e8 ce 14 00 00       	call   10ccf7 <klog_write_fmt>
    klog_debug(" segment file size: 0x%X", program_header->segment_file_size);
  10b829:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10b82d:	48 8b 40 20          	mov    rax,QWORD PTR [rax+0x20]
  10b831:	48 89 c2             	mov    rdx,rax
  10b834:	be aa 7c 10 00       	mov    esi,0x107caa
  10b839:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b83e:	b8 00 00 00 00       	mov    eax,0x0
  10b843:	e8 af 14 00 00       	call   10ccf7 <klog_write_fmt>
    klog_debug(" segment memory size: 0x%X", program_header->segment_memory_size);
  10b848:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10b84c:	48 8b 40 28          	mov    rax,QWORD PTR [rax+0x28]
  10b850:	48 89 c2             	mov    rdx,rax
  10b853:	be c3 7c 10 00       	mov    esi,0x107cc3
  10b858:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b85d:	b8 00 00 00 00       	mov    eax,0x0
  10b862:	e8 90 14 00 00       	call   10ccf7 <klog_write_fmt>
  for(size_t i = 0; i < header->programHeaderEntryCount; i++){
  10b867:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10b86c:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10b870:	0f b7 40 38          	movzx  eax,WORD PTR [rax+0x38]
  10b874:	0f b7 c0             	movzx  eax,ax
  10b877:	48 3b 45 f8          	cmp    rax,QWORD PTR [rbp-0x8]
  10b87b:	0f 87 30 ff ff ff    	ja     10b7b1 <kprocess_load_elf_executable+0x6b>
  }

  return header->programEntryOffset;
  10b881:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10b885:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
  10b889:	c9                   	leave  
  10b88a:	c3                   	ret    

000000000010b88b <kdebug_ioapic_log_irq_map>:
    klog_info("CPU%lu: lapic_id: %u", i, (uint32_t)sys->cpu_lapic_ids[i]);
  }
}

static void
kdebug_ioapic_log_irq_map(uintptr_t ioapic_base){
  10b88b:	55                   	push   rbp
  10b88c:	48 89 e5             	mov    rbp,rsp
  10b88f:	48 83 ec 20          	sub    rsp,0x20
  10b893:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  for(size_t i = 0; i < 8; i++){
  10b897:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10b89e:	00 
  10b89f:	e9 81 00 00 00       	jmp    10b925 <kdebug_ioapic_log_irq_map+0x9a>
    IOAPIC_IRQR_LOW irqr_low = {};
  10b8a4:	c7 45 f0 00 00 00 00 	mov    DWORD PTR [rbp-0x10],0x0
    //IOAPIC_IRQR_HIGH irqr_high = {};
    irqr_low.packed = ioapic_read_register(ioapic_base, 0x10 + (i * 2));
  10b8ab:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10b8af:	48 83 c0 08          	add    rax,0x8
  10b8b3:	01 c0                	add    eax,eax
  10b8b5:	0f b6 d0             	movzx  edx,al
  10b8b8:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10b8bc:	89 d6                	mov    esi,edx
  10b8be:	48 89 c7             	mov    rdi,rax
  10b8c1:	e8 bc e2 ff ff       	call   109b82 <ioapic_read_register>
  10b8c6:	89 45 f0             	mov    DWORD PTR [rbp-0x10],eax
    //irqr_high.packed = ioapic_read_register(ioapic_base, 0x10 + (i * 2) + 1);
    klog_debug("IRQ %u", (uint32_t)i);
  10b8c9:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10b8cd:	89 c2                	mov    edx,eax
  10b8cf:	be de 7c 10 00       	mov    esi,0x107cde
  10b8d4:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b8d9:	b8 00 00 00 00       	mov    eax,0x0
  10b8de:	e8 14 14 00 00       	call   10ccf7 <klog_write_fmt>
    klog_debug("  vector: %u", (uint32_t)irqr_low.vector);
  10b8e3:	0f b6 45 f0          	movzx  eax,BYTE PTR [rbp-0x10]
  10b8e7:	0f b6 c0             	movzx  eax,al
  10b8ea:	89 c2                	mov    edx,eax
  10b8ec:	be e5 7c 10 00       	mov    esi,0x107ce5
  10b8f1:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b8f6:	b8 00 00 00 00       	mov    eax,0x0
  10b8fb:	e8 f7 13 00 00       	call   10ccf7 <klog_write_fmt>
    klog_debug("  mask %u", (uint32_t)irqr_low.mask);
  10b900:	0f b6 45 f1          	movzx  eax,BYTE PTR [rbp-0xf]
  10b904:	c0 e8 07             	shr    al,0x7
  10b907:	0f b6 c0             	movzx  eax,al
  10b90a:	89 c2                	mov    edx,eax
  10b90c:	be f2 7c 10 00       	mov    esi,0x107cf2
  10b911:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b916:	b8 00 00 00 00       	mov    eax,0x0
  10b91b:	e8 d7 13 00 00       	call   10ccf7 <klog_write_fmt>
  for(size_t i = 0; i < 8; i++){
  10b920:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10b925:	48 83 7d f8 07       	cmp    QWORD PTR [rbp-0x8],0x7
  10b92a:	0f 86 74 ff ff ff    	jbe    10b8a4 <kdebug_ioapic_log_irq_map+0x19>
  }
}
  10b930:	90                   	nop
  10b931:	c9                   	leave  
  10b932:	c3                   	ret    

000000000010b933 <kdebug_log_page_table_entry_info>:


static void
kdebug_log_page_table_entry_info(const uintptr_t entry){
  10b933:	55                   	push   rbp
  10b934:	48 89 e5             	mov    rbp,rsp
  10b937:	48 83 ec 20          	sub    rsp,0x20
  10b93b:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  uintptr_t physical_address = entry & ~0xFFF;
  10b93f:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10b943:	48 25 00 f0 ff ff    	and    rax,0xfffffffffffff000
  10b949:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  bool is_present = entry & PAGE_PRESENT_BIT;
  10b94d:	b8 01 00 00 00       	mov    eax,0x1
  10b952:	48 23 45 e8          	and    rax,QWORD PTR [rbp-0x18]
  10b956:	48 85 c0             	test   rax,rax
  10b959:	0f 95 c0             	setne  al
  10b95c:	88 45 f7             	mov    BYTE PTR [rbp-0x9],al
  bool is_writeable = entry & PAGE_WRITEABLE_BIT;
  10b95f:	b8 02 00 00 00       	mov    eax,0x2
  10b964:	48 23 45 e8          	and    rax,QWORD PTR [rbp-0x18]
  10b968:	48 85 c0             	test   rax,rax
  10b96b:	0f 95 c0             	setne  al
  10b96e:	88 45 f6             	mov    BYTE PTR [rbp-0xa],al
  bool access_mode = entry & PAGE_USER_ACCESS_BIT;
  10b971:	b8 04 00 00 00       	mov    eax,0x4
  10b976:	48 23 45 e8          	and    rax,QWORD PTR [rbp-0x18]
  10b97a:	48 85 c0             	test   rax,rax
  10b97d:	0f 95 c0             	setne  al
  10b980:	88 45 f5             	mov    BYTE PTR [rbp-0xb],al
  bool is_write_through_caching = entry & PAGE_WRITE_TROUGH_CACHE_BIT;
  10b983:	b8 08 00 00 00       	mov    eax,0x8
  10b988:	48 23 45 e8          	and    rax,QWORD PTR [rbp-0x18]
  10b98c:	48 85 c0             	test   rax,rax
  10b98f:	0f 95 c0             	setne  al
  10b992:	88 45 f4             	mov    BYTE PTR [rbp-0xc],al
  bool is_caching_disabled = entry & PAGE_DISABLE_CACHE_BIT;
  10b995:	b8 10 00 00 00       	mov    eax,0x10
  10b99a:	48 23 45 e8          	and    rax,QWORD PTR [rbp-0x18]
  10b99e:	48 85 c0             	test   rax,rax
  10b9a1:	0f 95 c0             	setne  al
  10b9a4:	88 45 f3             	mov    BYTE PTR [rbp-0xd],al
  bool is_huge_page = entry & PAGE_HUGE_BIT;
  10b9a7:	b8 80 00 00 00       	mov    eax,0x80
  10b9ac:	48 23 45 e8          	and    rax,QWORD PTR [rbp-0x18]
  10b9b0:	48 85 c0             	test   rax,rax
  10b9b3:	0f 95 c0             	setne  al
  10b9b6:	88 45 f2             	mov    BYTE PTR [rbp-0xe],al
  klog_debug("physical_address: 0x%X", physical_address);
  10b9b9:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10b9bd:	48 89 c2             	mov    rdx,rax
  10b9c0:	be fc 7c 10 00       	mov    esi,0x107cfc
  10b9c5:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b9ca:	b8 00 00 00 00       	mov    eax,0x0
  10b9cf:	e8 23 13 00 00       	call   10ccf7 <klog_write_fmt>
  klog_debug("present: %s", is_present ? "true" : "false");
  10b9d4:	80 7d f7 00          	cmp    BYTE PTR [rbp-0x9],0x0
  10b9d8:	74 07                	je     10b9e1 <kdebug_log_page_table_entry_info+0xae>
  10b9da:	b8 86 63 10 00       	mov    eax,0x106386
  10b9df:	eb 05                	jmp    10b9e6 <kdebug_log_page_table_entry_info+0xb3>
  10b9e1:	b8 8b 63 10 00       	mov    eax,0x10638b
  10b9e6:	48 89 c2             	mov    rdx,rax
  10b9e9:	be 13 7d 10 00       	mov    esi,0x107d13
  10b9ee:	bf 00 e0 10 00       	mov    edi,0x10e000
  10b9f3:	b8 00 00 00 00       	mov    eax,0x0
  10b9f8:	e8 fa 12 00 00       	call   10ccf7 <klog_write_fmt>
  klog_debug("writeable: %s", is_writeable ? "true" : "false");
  10b9fd:	80 7d f6 00          	cmp    BYTE PTR [rbp-0xa],0x0
  10ba01:	74 07                	je     10ba0a <kdebug_log_page_table_entry_info+0xd7>
  10ba03:	b8 86 63 10 00       	mov    eax,0x106386
  10ba08:	eb 05                	jmp    10ba0f <kdebug_log_page_table_entry_info+0xdc>
  10ba0a:	b8 8b 63 10 00       	mov    eax,0x10638b
  10ba0f:	48 89 c2             	mov    rdx,rax
  10ba12:	be 1f 7d 10 00       	mov    esi,0x107d1f
  10ba17:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ba1c:	b8 00 00 00 00       	mov    eax,0x0
  10ba21:	e8 d1 12 00 00       	call   10ccf7 <klog_write_fmt>
  klog_debug("user accessiable: %s", access_mode ? "true" : "false");
  10ba26:	80 7d f5 00          	cmp    BYTE PTR [rbp-0xb],0x0
  10ba2a:	74 07                	je     10ba33 <kdebug_log_page_table_entry_info+0x100>
  10ba2c:	b8 86 63 10 00       	mov    eax,0x106386
  10ba31:	eb 05                	jmp    10ba38 <kdebug_log_page_table_entry_info+0x105>
  10ba33:	b8 8b 63 10 00       	mov    eax,0x10638b
  10ba38:	48 89 c2             	mov    rdx,rax
  10ba3b:	be 2d 7d 10 00       	mov    esi,0x107d2d
  10ba40:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ba45:	b8 00 00 00 00       	mov    eax,0x0
  10ba4a:	e8 a8 12 00 00       	call   10ccf7 <klog_write_fmt>
  klog_debug("write through caching: %s", is_write_through_caching ? "true" : "false");
  10ba4f:	80 7d f4 00          	cmp    BYTE PTR [rbp-0xc],0x0
  10ba53:	74 07                	je     10ba5c <kdebug_log_page_table_entry_info+0x129>
  10ba55:	b8 86 63 10 00       	mov    eax,0x106386
  10ba5a:	eb 05                	jmp    10ba61 <kdebug_log_page_table_entry_info+0x12e>
  10ba5c:	b8 8b 63 10 00       	mov    eax,0x10638b
  10ba61:	48 89 c2             	mov    rdx,rax
  10ba64:	be 42 7d 10 00       	mov    esi,0x107d42
  10ba69:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ba6e:	b8 00 00 00 00       	mov    eax,0x0
  10ba73:	e8 7f 12 00 00       	call   10ccf7 <klog_write_fmt>
  klog_debug("caching disabled: %s", is_caching_disabled ? "true" : "false");
  10ba78:	80 7d f3 00          	cmp    BYTE PTR [rbp-0xd],0x0
  10ba7c:	74 07                	je     10ba85 <kdebug_log_page_table_entry_info+0x152>
  10ba7e:	b8 86 63 10 00       	mov    eax,0x106386
  10ba83:	eb 05                	jmp    10ba8a <kdebug_log_page_table_entry_info+0x157>
  10ba85:	b8 8b 63 10 00       	mov    eax,0x10638b
  10ba8a:	48 89 c2             	mov    rdx,rax
  10ba8d:	be 5c 7d 10 00       	mov    esi,0x107d5c
  10ba92:	bf 00 e0 10 00       	mov    edi,0x10e000
  10ba97:	b8 00 00 00 00       	mov    eax,0x0
  10ba9c:	e8 56 12 00 00       	call   10ccf7 <klog_write_fmt>
  klog_debug("huge page: %s", is_huge_page ? "true" : "false"); 
  10baa1:	80 7d f2 00          	cmp    BYTE PTR [rbp-0xe],0x0
  10baa5:	74 07                	je     10baae <kdebug_log_page_table_entry_info+0x17b>
  10baa7:	b8 86 63 10 00       	mov    eax,0x106386
  10baac:	eb 05                	jmp    10bab3 <kdebug_log_page_table_entry_info+0x180>
  10baae:	b8 8b 63 10 00       	mov    eax,0x10638b
  10bab3:	48 89 c2             	mov    rdx,rax
  10bab6:	be 71 7d 10 00       	mov    esi,0x107d71
  10babb:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bac0:	b8 00 00 00 00       	mov    eax,0x0
  10bac5:	e8 2d 12 00 00       	call   10ccf7 <klog_write_fmt>
}
  10baca:	90                   	nop
  10bacb:	c9                   	leave  
  10bacc:	c3                   	ret    

000000000010bacd <kdebug_log_virtual_address_info_2MB>:

static void 
kdebug_log_virtual_address_info_2MB(const uintptr_t virtual_address){
  10bacd:	55                   	push   rbp
  10bace:	48 89 e5             	mov    rbp,rsp
  10bad1:	48 83 ec 30          	sub    rsp,0x30
  10bad5:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  uint64_t p4_index = (virtual_address >> 39) & 0x1FF;
  10bad9:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10badd:	48 c1 e8 27          	shr    rax,0x27
  10bae1:	25 ff 01 00 00       	and    eax,0x1ff
  10bae6:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  uint64_t p3_index = (virtual_address >> 30) & 0x1FF;
  10baea:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10baee:	48 c1 e8 1e          	shr    rax,0x1e
  10baf2:	25 ff 01 00 00       	and    eax,0x1ff
  10baf7:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
  uint64_t p2_index = (virtual_address >> 21) & 0x1FF;
  10bafb:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10baff:	48 c1 e8 15          	shr    rax,0x15
  10bb03:	25 ff 01 00 00       	and    eax,0x1ff
  10bb08:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
  uint64_t offset   = (virtual_address >> 0)  & 0xFFFFF;
  10bb0c:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10bb10:	25 ff ff 0f 00       	and    eax,0xfffff
  10bb15:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax

  klog_debug("logging virtual address info");
  10bb19:	be 7f 7d 10 00       	mov    esi,0x107d7f
  10bb1e:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bb23:	b8 00 00 00 00       	mov    eax,0x0
  10bb28:	e8 ca 11 00 00       	call   10ccf7 <klog_write_fmt>
  klog_debug(" virtual_address: 0x%X", virtual_address);
  10bb2d:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10bb31:	48 89 c2             	mov    rdx,rax
  10bb34:	be 9c 7d 10 00       	mov    esi,0x107d9c
  10bb39:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bb3e:	b8 00 00 00 00       	mov    eax,0x0
  10bb43:	e8 af 11 00 00       	call   10ccf7 <klog_write_fmt>
  klog_debug(" p4_index: %lu", p4_index);
  10bb48:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bb4c:	48 89 c2             	mov    rdx,rax
  10bb4f:	be b3 7d 10 00       	mov    esi,0x107db3
  10bb54:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bb59:	b8 00 00 00 00       	mov    eax,0x0
  10bb5e:	e8 94 11 00 00       	call   10ccf7 <klog_write_fmt>
  klog_debug(" p3_index: %lu", p3_index);
  10bb63:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10bb67:	48 89 c2             	mov    rdx,rax
  10bb6a:	be c2 7d 10 00       	mov    esi,0x107dc2
  10bb6f:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bb74:	b8 00 00 00 00       	mov    eax,0x0
  10bb79:	e8 79 11 00 00       	call   10ccf7 <klog_write_fmt>
  klog_debug(" p2_index: %lu", p2_index);
  10bb7e:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bb82:	48 89 c2             	mov    rdx,rax
  10bb85:	be d1 7d 10 00       	mov    esi,0x107dd1
  10bb8a:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bb8f:	b8 00 00 00 00       	mov    eax,0x0
  10bb94:	e8 5e 11 00 00       	call   10ccf7 <klog_write_fmt>
  klog_debug(" offset: %lu", offset);
  10bb99:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10bb9d:	48 89 c2             	mov    rdx,rax
  10bba0:	be e0 7d 10 00       	mov    esi,0x107de0
  10bba5:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bbaa:	b8 00 00 00 00       	mov    eax,0x0
  10bbaf:	e8 43 11 00 00       	call   10ccf7 <klog_write_fmt>

  klog_debug(" p4_entry_info:");
  10bbb4:	be ed 7d 10 00       	mov    esi,0x107ded
  10bbb9:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bbbe:	b8 00 00 00 00       	mov    eax,0x0
  10bbc3:	e8 2f 11 00 00       	call   10ccf7 <klog_write_fmt>
  kdebug_log_page_table_entry_info(g_p4_table.entries[p4_index]);
  10bbc8:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bbcc:	48 8b 04 c5 00 20 12 	mov    rax,QWORD PTR [rax*8+0x122000]
  10bbd3:	00 
  10bbd4:	48 89 c7             	mov    rdi,rax
  10bbd7:	e8 57 fd ff ff       	call   10b933 <kdebug_log_page_table_entry_info>
  klog_debug(" p3_entry_info:");
  10bbdc:	be fd 7d 10 00       	mov    esi,0x107dfd
  10bbe1:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bbe6:	b8 00 00 00 00       	mov    eax,0x0
  10bbeb:	e8 07 11 00 00       	call   10ccf7 <klog_write_fmt>
  kdebug_log_page_table_entry_info(g_p3_table.entries[p3_index]);
  10bbf0:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10bbf4:	48 8b 04 c5 00 30 12 	mov    rax,QWORD PTR [rax*8+0x123000]
  10bbfb:	00 
  10bbfc:	48 89 c7             	mov    rdi,rax
  10bbff:	e8 2f fd ff ff       	call   10b933 <kdebug_log_page_table_entry_info>
  klog_debug(" p2_entry_info:");
  10bc04:	be 0d 7e 10 00       	mov    esi,0x107e0d
  10bc09:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bc0e:	b8 00 00 00 00       	mov    eax,0x0
  10bc13:	e8 df 10 00 00       	call   10ccf7 <klog_write_fmt>
  kdebug_log_page_table_entry_info(g_p2_table.entries[p2_index]);
  10bc18:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bc1c:	48 8b 04 c5 00 40 12 	mov    rax,QWORD PTR [rax*8+0x124000]
  10bc23:	00 
  10bc24:	48 89 c7             	mov    rdi,rax
  10bc27:	e8 07 fd ff ff       	call   10b933 <kdebug_log_page_table_entry_info>
}
  10bc2c:	90                   	nop
  10bc2d:	c9                   	leave  
  10bc2e:	c3                   	ret    

000000000010bc2f <kdebug_log_page_info>:

static void
kdebug_log_page_info() {
  10bc2f:	55                   	push   rbp
  10bc30:	48 89 e5             	mov    rbp,rsp
  10bc33:	48 83 ec 20          	sub    rsp,0x20
  for(size_t i = 0; i < g_current_page_index; i++){
  10bc37:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10bc3e:	00 
  10bc3f:	eb 61                	jmp    10bca2 <kdebug_log_page_info+0x73>
    bool is_present = g_p2_table.entries[i] & 0b01;
  10bc41:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bc45:	48 8b 04 c5 00 40 12 	mov    rax,QWORD PTR [rax*8+0x124000]
  10bc4c:	00 
  10bc4d:	83 e0 01             	and    eax,0x1
  10bc50:	48 85 c0             	test   rax,rax
  10bc53:	0f 95 c0             	setne  al
  10bc56:	88 45 f7             	mov    BYTE PTR [rbp-0x9],al
    uintptr_t physical_address = g_p2_table.entries[i] & ~(0b111111111111);
  10bc59:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bc5d:	48 8b 04 c5 00 40 12 	mov    rax,QWORD PTR [rax*8+0x124000]
  10bc64:	00 
  10bc65:	48 25 00 f0 ff ff    	and    rax,0xfffffffffffff000
  10bc6b:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
    uintptr_t virtual_address = i * 1024 * 1024 * 2;
  10bc6f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bc73:	48 c1 e0 15          	shl    rax,0x15
  10bc77:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
    klog_debug("page_entry: virtual %lu mapped to %lu", virtual_address, physical_address);
  10bc7b:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  10bc7f:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10bc83:	48 89 d1             	mov    rcx,rdx
  10bc86:	48 89 c2             	mov    rdx,rax
  10bc89:	be 20 7e 10 00       	mov    esi,0x107e20
  10bc8e:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bc93:	b8 00 00 00 00       	mov    eax,0x0
  10bc98:	e8 5a 10 00 00       	call   10ccf7 <klog_write_fmt>
  for(size_t i = 0; i < g_current_page_index; i++){
  10bc9d:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10bca2:	8b 05 58 43 01 00    	mov    eax,DWORD PTR [rip+0x14358]        # 120000 <g_current_page_index>
  10bca8:	89 c0                	mov    eax,eax
  10bcaa:	48 3b 45 f8          	cmp    rax,QWORD PTR [rbp-0x8]
  10bcae:	77 91                	ja     10bc41 <kdebug_log_page_info+0x12>
  }
}
  10bcb0:	90                   	nop
  10bcb1:	c9                   	leave  
  10bcb2:	c3                   	ret    

000000000010bcb3 <kernel_longmode_entry>:
#include "kernel_debug.c"

extern void asm_enter_usermode(uintptr_t address_to_execute, uintptr_t stack_pointer);

extern void 
kernel_longmode_entry(uint64_t multiboot2_magic, uint64_t multiboot2_address) {
  10bcb3:	55                   	push   rbp
  10bcb4:	48 89 e5             	mov    rbp,rsp
  10bcb7:	48 83 ec 70          	sub    rsp,0x70
  10bcbb:	48 89 7d 98          	mov    QWORD PTR [rbp-0x68],rdi
  10bcbf:	48 89 75 90          	mov    QWORD PTR [rbp-0x70],rsi
	serial_debug_init();
  10bcc3:	b8 00 00 00 00       	mov    eax,0x0
  10bcc8:	e8 62 eb ff ff       	call   10a82f <serial_debug_init>
	legacy_pic8259_initalize();
  10bccd:	e8 55 e6 ff ff       	call   10a327 <legacy_pic8259_initalize>
	x86_64_idt_initalize();
  10bcd2:	b8 00 00 00 00       	mov    eax,0x0
  10bcd7:	e8 4d e8 ff ff       	call   10a529 <x86_64_idt_initalize>
  kmem_initalize();
  10bcdc:	b8 00 00 00 00       	mov    eax,0x0
  10bce1:	e8 ed ee ff ff       	call   10abd3 <kmem_initalize>

  //NOTE(Torin) Setup keyboard event stack
  globals.keyboard.scancode_event_stack = globals.keyboard.scancode_event_stack0;
  10bce6:	48 c7 05 57 29 01 00 	mov    QWORD PTR [rip+0x12957],0x11e650        # 11e648 <globals+0x10648>
  10bced:	50 e6 11 00 


	if (multiboot2_magic != MULTIBOOT2_BOOTLOADER_MAGIC) {
  10bcf1:	48 81 7d 98 89 62 d7 	cmp    QWORD PTR [rbp-0x68],0x36d76289
  10bcf8:	36 
  10bcf9:	74 20                	je     10bd1b <kernel_longmode_entry+0x68>
		klog_error("the kernel was not booted with a multiboot2 compliant bootloader!");
  10bcfb:	be 48 7e 10 00       	mov    esi,0x107e48
  10bd00:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bd05:	b8 00 00 00 00       	mov    eax,0x0
  10bd0a:	e8 e8 0f 00 00       	call   10ccf7 <klog_write_fmt>
		kpanic();
  10bd0f:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bd14:	e8 05 d9 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10bd19:	fa                   	cli    
  10bd1a:	f4                   	hlt    
	}

	if (multiboot2_address & 7) {
  10bd1b:	48 8b 45 90          	mov    rax,QWORD PTR [rbp-0x70]
  10bd1f:	83 e0 07             	and    eax,0x7
  10bd22:	48 85 c0             	test   rax,rax
  10bd25:	74 20                	je     10bd47 <kernel_longmode_entry+0x94>
		klog_error("unaligned multiboot_info!");
  10bd27:	be 8a 7e 10 00       	mov    esi,0x107e8a
  10bd2c:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bd31:	b8 00 00 00 00       	mov    eax,0x0
  10bd36:	e8 bc 0f 00 00       	call   10ccf7 <klog_write_fmt>
		kpanic();
  10bd3b:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bd40:	e8 d9 d8 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10bd45:	fa                   	cli    
  10bd46:	f4                   	hlt    
	}

  struct multiboot_tag_framebuffer *fb_mbtag = 0; 
  10bd47:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10bd4e:	00 
  uintptr_t rsdp_physical_address = 0;
  10bd4f:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
  10bd56:	00 
	struct multiboot_tag *tag = (struct multiboot_tag *)(multiboot2_address + 8);
  10bd57:	48 8b 45 90          	mov    rax,QWORD PTR [rbp-0x70]
  10bd5b:	48 83 c0 08          	add    rax,0x8
  10bd5f:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
	while (tag->type != MULTIBOOT_TAG_TYPE_END) {
  10bd63:	eb 5f                	jmp    10bdc4 <kernel_longmode_entry+0x111>
		switch (tag->type) {
  10bd65:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bd69:	8b 00                	mov    eax,DWORD PTR [rax]
  10bd6b:	83 f8 0e             	cmp    eax,0xe
  10bd6e:	74 0c                	je     10bd7c <kernel_longmode_entry+0xc9>
  10bd70:	83 f8 0f             	cmp    eax,0xf
  10bd73:	74 1d                	je     10bd92 <kernel_longmode_entry+0xdf>
  10bd75:	83 f8 08             	cmp    eax,0x8
  10bd78:	74 2e                	je     10bda8 <kernel_longmode_entry+0xf5>
  10bd7a:	eb 35                	jmp    10bdb1 <kernel_longmode_entry+0xfe>
			case MULTIBOOT_TAG_TYPE_ACPI_OLD: {
		    struct multiboot_tag_old_acpi *acpi_info = (struct multiboot_tag_old_acpi *)(tag);
  10bd7c:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bd80:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
        rsdp_physical_address = (uintptr_t)acpi_info->rsdp;
  10bd84:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10bd88:	48 83 c0 08          	add    rax,0x8
  10bd8c:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
			} break;
  10bd90:	eb 1f                	jmp    10bdb1 <kernel_longmode_entry+0xfe>
			case MULTIBOOT_TAG_TYPE_ACPI_NEW: {
				struct multiboot_tag_new_acpi *acpi_info = (struct multiboot_tag_new_acpi *)(tag);
  10bd92:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bd96:	48 89 45 d8          	mov    QWORD PTR [rbp-0x28],rax
        rsdp_physical_address = (uintptr_t)acpi_info->rsdp;
  10bd9a:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10bd9e:	48 83 c0 08          	add    rax,0x8
  10bda2:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
			} break;
  10bda6:	eb 09                	jmp    10bdb1 <kernel_longmode_entry+0xfe>

      case MULTIBOOT_TAG_TYPE_FRAMEBUFFER: {
        fb_mbtag = (struct multiboot_tag_framebuffer *)(tag);
  10bda8:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bdac:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
      } break;
  10bdb0:	90                   	nop
        }
        #endif
      };

		}
		tag = (struct multiboot_tag *)(((uint8_t *)tag) + ((tag->size + 7) & ~7));
  10bdb1:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bdb5:	8b 40 04             	mov    eax,DWORD PTR [rax+0x4]
  10bdb8:	83 c0 07             	add    eax,0x7
  10bdbb:	89 c0                	mov    eax,eax
  10bdbd:	83 e0 f8             	and    eax,0xfffffff8
  10bdc0:	48 01 45 e8          	add    QWORD PTR [rbp-0x18],rax
	while (tag->type != MULTIBOOT_TAG_TYPE_END) {
  10bdc4:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10bdc8:	8b 00                	mov    eax,DWORD PTR [rax]
  10bdca:	85 c0                	test   eax,eax
  10bdcc:	75 97                	jne    10bd65 <kernel_longmode_entry+0xb2>
	}

  //NOTE(Torin) Initalize the framebuffer
  if(fb_mbtag == 0) {
  10bdce:	48 83 7d f8 00       	cmp    QWORD PTR [rbp-0x8],0x0
  10bdd3:	75 30                	jne    10be05 <kernel_longmode_entry+0x152>
    kassert(0 && "MULTIBOOT FAILED TO PROVIDE FRAMEBUFFER TAG");
  10bdd5:	41 b8 a4 7e 10 00    	mov    r8d,0x107ea4
  10bddb:	b9 36 01 00 00       	mov    ecx,0x136
  10bde0:	ba b8 7e 10 00       	mov    edx,0x107eb8
  10bde5:	be 38 61 10 00       	mov    esi,0x106138
  10bdea:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bdef:	b8 00 00 00 00       	mov    eax,0x0
  10bdf4:	e8 fe 0e 00 00       	call   10ccf7 <klog_write_fmt>
  10bdf9:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bdfe:	e8 1b d8 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10be03:	fa                   	cli    
  10be04:	f4                   	hlt    
  }

  if(fb_mbtag->common.framebuffer_type != MULTIBOOT_FRAMEBUFFER_TYPE_RGB){
  10be05:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10be09:	0f b6 40 1d          	movzx  eax,BYTE PTR [rax+0x1d]
  10be0d:	3c 01                	cmp    al,0x1
  10be0f:	74 19                	je     10be2a <kernel_longmode_entry+0x177>
    klog_info("this is a text buffer");
  10be11:	be eb 7e 10 00       	mov    esi,0x107eeb
  10be16:	bf 00 e0 10 00       	mov    edi,0x10e000
  10be1b:	b8 00 00 00 00       	mov    eax,0x0
  10be20:	e8 d2 0e 00 00       	call   10ccf7 <klog_write_fmt>
  10be25:	e9 cf 00 00 00       	jmp    10bef9 <kernel_longmode_entry+0x246>
  } else {
    uintptr_t framebuffer_virtual_address = 0x0A000000;
  10be2a:	48 c7 45 d0 00 00 00 	mov    QWORD PTR [rbp-0x30],0xa000000
  10be31:	0a 
    uintptr_t page_offset = kmem_map_unaligned_physical_to_aligned_virtual_2MB(fb_mbtag->common.framebuffer_addr, framebuffer_virtual_address);
  10be32:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10be36:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10be3a:	48 8b 55 d0          	mov    rdx,QWORD PTR [rbp-0x30]
  10be3e:	48 89 d6             	mov    rsi,rdx
  10be41:	48 89 c7             	mov    rdi,rax
  10be44:	e8 44 ed ff ff       	call   10ab8d <kmem_map_unaligned_physical_to_aligned_virtual_2MB>
  10be49:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
    kmem_map_physical_to_virtual_2MB(fb_mbtag->common.framebuffer_addr - page_offset + 0x200000, framebuffer_virtual_address + 0x200000);
  10be4d:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10be51:	48 8d 90 00 00 20 00 	lea    rdx,[rax+0x200000]
  10be58:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10be5c:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10be60:	48 2b 45 c8          	sub    rax,QWORD PTR [rbp-0x38]
  10be64:	48 05 00 00 20 00    	add    rax,0x200000
  10be6a:	48 89 d6             	mov    rsi,rdx
  10be6d:	48 89 c7             	mov    rdi,rax
  10be70:	e8 b2 eb ff ff       	call   10aa27 <kmem_map_physical_to_virtual_2MB>

    Framebuffer *fb = &globals.framebuffer;
  10be75:	48 c7 45 c0 48 e7 11 	mov    QWORD PTR [rbp-0x40],0x11e748
  10be7c:	00 
    fb->width = fb_mbtag->common.framebuffer_width; 
  10be7d:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10be81:	8b 50 14             	mov    edx,DWORD PTR [rax+0x14]
  10be84:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10be88:	89 10                	mov    DWORD PTR [rax],edx
    fb->height = fb_mbtag->common.framebuffer_height;
  10be8a:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10be8e:	8b 50 18             	mov    edx,DWORD PTR [rax+0x18]
  10be91:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10be95:	89 50 04             	mov    DWORD PTR [rax+0x4],edx
    fb->buffer = (uint8_t *)framebuffer_virtual_address;
  10be98:	48 8b 55 d0          	mov    rdx,QWORD PTR [rbp-0x30]
  10be9c:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10bea0:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
    fb->depth = fb_mbtag->common.framebuffer_bpp / 8; 
  10bea4:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bea8:	0f b6 40 1c          	movzx  eax,BYTE PTR [rax+0x1c]
  10beac:	c0 e8 03             	shr    al,0x3
  10beaf:	89 c2                	mov    edx,eax
  10beb1:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10beb5:	88 50 0c             	mov    BYTE PTR [rax+0xc],dl
    fb->pitch = fb_mbtag->common.framebuffer_pitch; 
  10beb8:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10bebc:	8b 50 10             	mov    edx,DWORD PTR [rax+0x10]
  10bebf:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10bec3:	89 50 08             	mov    DWORD PTR [rax+0x8],edx
    klog_debug("framebuffer: width: %u, height: %u, depth: %u", fb->width, fb->height, (uint32_t)fb->depth);
  10bec6:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10beca:	0f b6 40 0c          	movzx  eax,BYTE PTR [rax+0xc]
  10bece:	0f b6 c8             	movzx  ecx,al
  10bed1:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10bed5:	8b 50 04             	mov    edx,DWORD PTR [rax+0x4]
  10bed8:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10bedc:	8b 00                	mov    eax,DWORD PTR [rax]
  10bede:	41 89 c8             	mov    r8d,ecx
  10bee1:	89 d1                	mov    ecx,edx
  10bee3:	89 c2                	mov    edx,eax
  10bee5:	be 08 7f 10 00       	mov    esi,0x107f08
  10beea:	bf 00 e0 10 00       	mov    edi,0x10e000
  10beef:	b8 00 00 00 00       	mov    eax,0x0
  10bef4:	e8 fe 0d 00 00       	call   10ccf7 <klog_write_fmt>
  }


  if(rsdp_physical_address == 0){
  10bef9:	48 83 7d f0 00       	cmp    QWORD PTR [rbp-0x10],0x0
  10befe:	75 30                	jne    10bf30 <kernel_longmode_entry+0x27d>
    kassert(0 && "MULTIBOOT FAILED TO PROVIDE LOCATION OF RSDP");
  10bf00:	41 b8 a4 7e 10 00    	mov    r8d,0x107ea4
  10bf06:	b9 4b 01 00 00       	mov    ecx,0x14b
  10bf0b:	ba 38 7f 10 00       	mov    edx,0x107f38
  10bf10:	be 38 61 10 00       	mov    esi,0x106138
  10bf15:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bf1a:	b8 00 00 00 00       	mov    eax,0x0
  10bf1f:	e8 d3 0d 00 00       	call   10ccf7 <klog_write_fmt>
  10bf24:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bf29:	e8 f0 d6 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10bf2e:	fa                   	cli    
  10bf2f:	f4                   	hlt    
  }

  System_Info *sys = &globals.system_info;
  10bf30:	48 c7 45 b8 90 e6 11 	mov    QWORD PTR [rbp-0x48],0x11e690
  10bf37:	00 
  parse_root_system_descriptor((RSDP_Descriptor_1*)rsdp_physical_address, sys);
  10bf38:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10bf3c:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  10bf40:	48 89 d6             	mov    rsi,rdx
  10bf43:	48 89 c7             	mov    rdi,rax
  10bf46:	e8 f5 d8 ff ff       	call   109840 <parse_root_system_descriptor>
  //NOTE(Torin) Tasking relating thingy-things

  //TODO(Torin 2016-08-29) This should probably be established after
  //the other cpus are initalized
  extern uintptr_t stack_top;
  uintptr_t stack_top_ptr = (uintptr_t)&stack_top;
  10bf4b:	48 c7 45 b0 02 70 12 	mov    QWORD PTR [rbp-0x50],0x127002
  10bf52:	00 
  sys->kernel_stack_address = stack_top_ptr;
  10bf53:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bf57:	48 8b 55 b0          	mov    rdx,QWORD PTR [rbp-0x50]
  10bf5b:	48 89 50 20          	mov    QWORD PTR [rax+0x20],rdx
  memset(&g_tss_entry, 0x00, sizeof(g_tss_entry));
  10bf5f:	ba 6c 00 00 00       	mov    edx,0x6c
  10bf64:	be 00 00 00 00       	mov    esi,0x0
  10bf69:	bf 80 e7 11 00       	mov    edi,0x11e780
  10bf6e:	e8 8d d0 ff ff       	call   109000 <__memset>
  g_tss_entry.rsp0 = stack_top_ptr;
  10bf73:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  10bf77:	48 89 05 06 28 01 00 	mov    QWORD PTR [rip+0x12806],rax        # 11e784 <g_tss_entry+0x4>
  g_tss_entry.ist1 = stack_top_ptr;
  10bf7e:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  10bf82:	48 89 05 1b 28 01 00 	mov    QWORD PTR [rip+0x1281b],rax        # 11e7a4 <g_tss_entry+0x24>
  klog_debug("tss rsp0: 0x%X", g_tss_entry.rsp0);
  10bf89:	48 8b 05 f4 27 01 00 	mov    rax,QWORD PTR [rip+0x127f4]        # 11e784 <g_tss_entry+0x4>
  10bf90:	48 89 c2             	mov    rdx,rax
  10bf93:	be 6c 7f 10 00       	mov    esi,0x107f6c
  10bf98:	bf 00 e0 10 00       	mov    edi,0x10e000
  10bf9d:	b8 00 00 00 00       	mov    eax,0x0
  10bfa2:	e8 50 0d 00 00       	call   10ccf7 <klog_write_fmt>
  uint8_t *gdt = (uint8_t *)&GDT64;
  10bfa7:	48 c7 45 a8 00 8d 10 	mov    QWORD PTR [rbp-0x58],0x108d00
  10bfae:	00 
  gdt_encode_system_descriptor((uintptr_t)&g_tss_entry, 0xFF, GDT_DESCRIPTOR_TYPE_TSS, 3, (uintptr_t)(gdt + GDT_TSS));
  10bfaf:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  10bfb3:	48 83 c0 28          	add    rax,0x28
  10bfb7:	48 89 c2             	mov    rdx,rax
  10bfba:	b8 80 e7 11 00       	mov    eax,0x11e780
  10bfbf:	49 89 d0             	mov    r8,rdx
  10bfc2:	b9 03 00 00 00       	mov    ecx,0x3
  10bfc7:	ba 09 00 00 00       	mov    edx,0x9
  10bfcc:	be ff 00 00 00       	mov    esi,0xff
  10bfd1:	48 89 c7             	mov    rdi,rax
  10bfd4:	e8 c2 de ff ff       	call   109e9b <gdt_encode_system_descriptor>
  tss_ldr(GDT_TSS);
  10bfd9:	bf 28 00 00 00       	mov    edi,0x28
  10bfde:	e8 03 e1 ff ff       	call   10a0e6 <tss_ldr>
  
  //TODO(Torin) Real page allocator
  //NOTE(Torin) Arbitrarly maps the lapic and ioapic into the kernels virtual addresss space
  //And initalizes the iopapic and lapic
  sys->lapic_virtual_address = 0x0C200000;
  10bfe3:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bfe7:	48 c7 40 10 00 00 20 	mov    QWORD PTR [rax+0x10],0xc200000
  10bfee:	0c 
  sys->ioapic_virtual_address = 0x0C400000;
  10bfef:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bff3:	48 c7 40 18 00 00 40 	mov    QWORD PTR [rax+0x18],0xc400000
  10bffa:	0c 
  kmem_map_physical_to_virtual_2MB(sys->lapic_physical_address, sys->lapic_virtual_address);
  10bffb:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10bfff:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10c003:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10c007:	48 8b 00             	mov    rax,QWORD PTR [rax]
  10c00a:	48 89 d6             	mov    rsi,rdx
  10c00d:	48 89 c7             	mov    rdi,rax
  10c010:	e8 12 ea ff ff       	call   10aa27 <kmem_map_physical_to_virtual_2MB>
  kmem_map_physical_to_virtual_2MB(sys->ioapic_physical_address, sys->ioapic_virtual_address);
  10c015:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10c019:	48 8b 50 18          	mov    rdx,QWORD PTR [rax+0x18]
  10c01d:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10c021:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10c025:	48 89 d6             	mov    rsi,rdx
  10c028:	48 89 c7             	mov    rdi,rax
  10c02b:	e8 f7 e9 ff ff       	call   10aa27 <kmem_map_physical_to_virtual_2MB>
  klog_debug("ioapic: physical = 0x%X, virtual = 0x%X", sys->ioapic_physical_address, sys->lapic_virtual_address);
  10c030:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10c034:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10c038:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10c03c:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10c040:	48 89 d1             	mov    rcx,rdx
  10c043:	48 89 c2             	mov    rdx,rax
  10c046:	be 80 7f 10 00       	mov    esi,0x107f80
  10c04b:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c050:	b8 00 00 00 00       	mov    eax,0x0
  10c055:	e8 9d 0c 00 00       	call   10ccf7 <klog_write_fmt>
  klog_debug("lapic: physical = 0x%X, virtual = 0x%X", sys->lapic_physical_address, sys->ioapic_virtual_address);
  10c05a:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10c05e:	48 8b 50 18          	mov    rdx,QWORD PTR [rax+0x18]
  10c062:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10c066:	48 8b 00             	mov    rax,QWORD PTR [rax]
  10c069:	48 89 d1             	mov    rcx,rdx
  10c06c:	48 89 c2             	mov    rdx,rax
  10c06f:	be a8 7f 10 00       	mov    esi,0x107fa8
  10c074:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c079:	b8 00 00 00 00       	mov    eax,0x0
  10c07e:	e8 74 0c 00 00       	call   10ccf7 <klog_write_fmt>
  lapic_initalize(sys->lapic_virtual_address);
  10c083:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10c087:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  10c08b:	48 89 c7             	mov    rdi,rax
  10c08e:	e8 97 db ff ff       	call   109c2a <lapic_initalize>
  ioapic_initalize(sys->ioapic_virtual_address);
  10c093:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10c097:	48 8b 40 18          	mov    rax,QWORD PTR [rax+0x18]
  10c09b:	48 89 c7             	mov    rdi,rax
  10c09e:	e8 3c db ff ff       	call   109bdf <ioapic_initalize>
  klog_debug("apic initalized");
  10c0a3:	be cf 7f 10 00       	mov    esi,0x107fcf
  10c0a8:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c0ad:	b8 00 00 00 00       	mov    eax,0x0
  10c0b2:	e8 40 0c 00 00       	call   10ccf7 <klog_write_fmt>

  //kgfx_draw_log_if_dirty(&globals.log);

  //pci_enumerate_devices();

  lapic_enable_timer(sys->lapic_virtual_address);
  10c0b7:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10c0bb:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
  10c0bf:	48 89 c7             	mov    rdi,rax
  10c0c2:	e8 bb db ff ff       	call   109c82 <lapic_enable_timer>
  
	while(1) { asm volatile("hlt"); };
  10c0c7:	f4                   	hlt    
  10c0c8:	eb fd                	jmp    10c0c7 <kernel_longmode_entry+0x414>

000000000010c0ca <kprocess_destroy>:
  isr_handler_page_fault,
  0x0,
  0x0,
};

static void kprocess_destroy(uint64_t pid){
  10c0ca:	55                   	push   rbp
  10c0cb:	48 89 e5             	mov    rbp,rsp
  10c0ce:	48 83 ec 10          	sub    rsp,0x10
  10c0d2:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  klog_debug("destroyed process: %lu", pid);
  10c0d6:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c0da:	48 89 c2             	mov    rdx,rax
  10c0dd:	be df 7f 10 00       	mov    esi,0x107fdf
  10c0e2:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c0e7:	b8 00 00 00 00       	mov    eax,0x0
  10c0ec:	e8 06 0c 00 00       	call   10ccf7 <klog_write_fmt>
  kgfx_draw_log_if_dirty(&globals.log);
  10c0f1:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c0f6:	e8 23 d5 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  asm volatile("hlt");
  10c0fb:	f4                   	hlt    
}
  10c0fc:	90                   	nop
  10c0fd:	c9                   	leave  
  10c0fe:	c3                   	ret    

000000000010c0ff <syscall_handler_print_string>:

static void syscall_handler_print_string(const char *string, size_t length){
  10c0ff:	55                   	push   rbp
  10c100:	48 89 e5             	mov    rbp,rsp
  10c103:	48 83 ec 10          	sub    rsp,0x10
  10c107:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  10c10b:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
  klog_write_string(&globals.log, string, length);
  10c10f:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  10c113:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c117:	48 89 c6             	mov    rsi,rax
  10c11a:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c11f:	e8 d1 0a 00 00       	call   10cbf5 <klog_write_string>
}
  10c124:	90                   	nop
  10c125:	c9                   	leave  
  10c126:	c3                   	ret    

000000000010c127 <syscall_handler_exit_process>:

static void syscall_handler_exit_process(Interrupt_Stack_Frame_No_Error stack){
  10c127:	55                   	push   rbp
  10c128:	48 89 e5             	mov    rbp,rsp
  //NOTE(Torin 2016-08-29) Set the stackframe to send us back into the kernel
  stack.ss = GDT_RING0_DATA;
  10c12b:	48 c7 45 30 08 00 00 	mov    QWORD PTR [rbp+0x30],0x8
  10c132:	00 
  stack.cs = GDT_RING0_CODE;
  10c133:	48 c7 45 18 18 00 00 	mov    QWORD PTR [rbp+0x18],0x18
  10c13a:	00 
  stack.rip = (uintptr_t)kprocess_destroy;
  10c13b:	b8 ca c0 10 00       	mov    eax,0x10c0ca
  10c140:	48 89 45 10          	mov    QWORD PTR [rbp+0x10],rax
  stack.rsp = (uintptr_t)globals.system_info.kernel_stack_address;
  10c144:	48 8b 05 65 25 01 00 	mov    rax,QWORD PTR [rip+0x12565]        # 11e6b0 <globals+0x106b0>
  10c14b:	48 89 45 28          	mov    QWORD PTR [rbp+0x28],rax
  asm volatile("mov $0x00, %rdi");
  10c14f:	48 c7 c7 00 00 00 00 	mov    rdi,0x0
}
  10c156:	90                   	nop
  10c157:	5d                   	pop    rbp
  10c158:	c3                   	ret    

000000000010c159 <isr_common_handler>:
  (uintptr_t)syscall_handler_print_string,
  (uintptr_t)syscall_handler_exit_process,
};

extern void 
isr_common_handler(Interrupt_Stack_Frame stack) {
  10c159:	55                   	push   rbp
  10c15a:	48 89 e5             	mov    rbp,rsp
  10c15d:	48 83 ec 10          	sub    rsp,0x10
	klog_debug("Exception Occured:%u %s", stack.interrupt_number, EXCEPTION_NAMES[stack.interrupt_number]);
  10c161:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  10c165:	48 8b 14 c5 c0 d6 10 	mov    rdx,QWORD PTR [rax*8+0x10d6c0]
  10c16c:	00 
  10c16d:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  10c171:	48 89 d1             	mov    rcx,rdx
  10c174:	48 89 c2             	mov    rdx,rax
  10c177:	be 10 80 10 00       	mov    esi,0x108010
  10c17c:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c181:	b8 00 00 00 00       	mov    eax,0x0
  10c186:	e8 6c 0b 00 00       	call   10ccf7 <klog_write_fmt>
	klog_debug("error_code: %u", stack.error_code);
  10c18b:	48 8b 45 30          	mov    rax,QWORD PTR [rbp+0x30]
  10c18f:	48 89 c2             	mov    rdx,rax
  10c192:	be 28 80 10 00       	mov    esi,0x108028
  10c197:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c19c:	b8 00 00 00 00       	mov    eax,0x0
  10c1a1:	e8 51 0b 00 00       	call   10ccf7 <klog_write_fmt>
	klog_debug("rip: 0x%X", stack.rip);
  10c1a6:	48 8b 45 38          	mov    rax,QWORD PTR [rbp+0x38]
  10c1aa:	48 89 c2             	mov    rdx,rax
  10c1ad:	be 37 80 10 00       	mov    esi,0x108037
  10c1b2:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c1b7:	b8 00 00 00 00       	mov    eax,0x0
  10c1bc:	e8 36 0b 00 00       	call   10ccf7 <klog_write_fmt>

  ExceptionHandlerProc exception_handler = g_exception_handlers[stack.interrupt_number];
  10c1c1:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  10c1c5:	48 8b 04 c5 c0 d7 10 	mov    rax,QWORD PTR [rax*8+0x10d7c0]
  10c1cc:	00 
  10c1cd:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  if(exception_handler != 0){
  10c1d1:	48 83 7d f8 00       	cmp    QWORD PTR [rbp-0x8],0x0
  10c1d6:	74 28                	je     10c200 <isr_common_handler+0xa7>
    exception_handler(stack);
  10c1d8:	ff 75 58             	push   QWORD PTR [rbp+0x58]
  10c1db:	ff 75 50             	push   QWORD PTR [rbp+0x50]
  10c1de:	ff 75 48             	push   QWORD PTR [rbp+0x48]
  10c1e1:	ff 75 40             	push   QWORD PTR [rbp+0x40]
  10c1e4:	ff 75 38             	push   QWORD PTR [rbp+0x38]
  10c1e7:	ff 75 30             	push   QWORD PTR [rbp+0x30]
  10c1ea:	ff 75 28             	push   QWORD PTR [rbp+0x28]
  10c1ed:	ff 75 20             	push   QWORD PTR [rbp+0x20]
  10c1f0:	ff 75 18             	push   QWORD PTR [rbp+0x18]
  10c1f3:	ff 75 10             	push   QWORD PTR [rbp+0x10]
  10c1f6:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c1fa:	ff d0                	call   rax
  10c1fc:	48 83 c4 50          	add    rsp,0x50
  }
}
  10c200:	90                   	nop
  10c201:	c9                   	leave  
  10c202:	c3                   	ret    

000000000010c203 <irq_common_handler>:

extern void 
irq_common_handler(IRQRegisterState regstate) {
  10c203:	55                   	push   rbp
  10c204:	48 89 e5             	mov    rbp,rsp
  10c207:	48 83 ec 10          	sub    rsp,0x10
  if(_interrupt_handlers[regstate.interrupt_number] == 0x00){
  10c20b:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  10c20f:	48 8b 04 c5 00 f8 11 	mov    rax,QWORD PTR [rax*8+0x11f800]
  10c216:	00 
  10c217:	48 85 c0             	test   rax,rax
  10c21a:	75 16                	jne    10c232 <irq_common_handler+0x2f>
		klog_error("unregistered interrupt handler");
  10c21c:	be 48 80 10 00       	mov    esi,0x108048
  10c221:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c226:	b8 00 00 00 00       	mov    eax,0x0
  10c22b:	e8 c7 0a 00 00       	call   10ccf7 <klog_write_fmt>
  10c230:	eb 16                	jmp    10c248 <irq_common_handler+0x45>
  } else {
	  InterruptHandlerProc proc = (InterruptHandlerProc)_interrupt_handlers[regstate.interrupt_number];
  10c232:	48 8b 45 28          	mov    rax,QWORD PTR [rbp+0x28]
  10c236:	48 8b 04 c5 00 f8 11 	mov    rax,QWORD PTR [rax*8+0x11f800]
  10c23d:	00 
  10c23e:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
		proc();
  10c242:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c246:	ff d0                	call   rax
  }
  lapic_write_register(globals.system_info.lapic_virtual_address, 0xB0, 0x00);
  10c248:	48 8b 05 51 24 01 00 	mov    rax,QWORD PTR [rip+0x12451]        # 11e6a0 <globals+0x106a0>
  10c24f:	ba 00 00 00 00       	mov    edx,0x0
  10c254:	be b0 00 00 00       	mov    esi,0xb0
  10c259:	48 89 c7             	mov    rdi,rax
  10c25c:	e8 50 d9 ff ff       	call   109bb1 <lapic_write_register>
}
  10c261:	90                   	nop
  10c262:	c9                   	leave  
  10c263:	c3                   	ret    

000000000010c264 <irq_handler_keyboard>:
//was already down it will still register that the key was
//pressed with the modifier.  Does this event matter?  Would this be better?
//Should store keycode + extra btye saying (isdown, shiftdown?, ctrldow?, altdown?)

static void 
irq_handler_keyboard(void) {
  10c264:	55                   	push   rbp
  10c265:	48 89 e5             	mov    rbp,rsp
  10c268:	48 83 ec 10          	sub    rsp,0x10
  static const uint32_t KEYBOARD_DATA_PORT   = 0x60;
  static const uint32_t KEYBOARD_STATUS_PORT = 0x64;
	uint8_t keyboard_status = read_port_uint8(KEYBOARD_STATUS_PORT);
  10c26c:	8b 05 16 c1 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffc116]        # 108388 <KEYBOARD_STATUS_PORT.5349>
  10c272:	0f b7 c0             	movzx  eax,ax
  10c275:	89 c7                	mov    edi,eax
  10c277:	e8 ac cf ff ff       	call   109228 <read_port_uint8>
  10c27c:	88 45 ff             	mov    BYTE PTR [rbp-0x1],al
  if(keyboard_status & 0x01){
  10c27f:	0f b6 45 ff          	movzx  eax,BYTE PTR [rbp-0x1]
  10c283:	83 e0 01             	and    eax,0x1
  10c286:	85 c0                	test   eax,eax
  10c288:	0f 84 aa 00 00 00    	je     10c338 <irq_handler_keyboard+0xd4>
		uint8_t scancode = read_port_uint8(KEYBOARD_DATA_PORT);
  10c28e:	8b 05 f8 c0 ff ff    	mov    eax,DWORD PTR [rip+0xffffffffffffc0f8]        # 10838c <KEYBOARD_DATA_PORT.5348>
  10c294:	0f b7 c0             	movzx  eax,ax
  10c297:	89 c7                	mov    edi,eax
  10c299:	e8 8a cf ff ff       	call   109228 <read_port_uint8>
  10c29e:	88 45 fe             	mov    BYTE PTR [rbp-0x2],al
    if(globals.log_keyboard_events){
  10c2a1:	0f b6 05 b9 24 01 00 	movzx  eax,BYTE PTR [rip+0x124b9]        # 11e761 <globals+0x10761>
  10c2a8:	84 c0                	test   al,al
  10c2aa:	74 1a                	je     10c2c6 <irq_handler_keyboard+0x62>
      klog_debug("[keyboard_event] scancode %u", scancode);
  10c2ac:	0f b6 45 fe          	movzx  eax,BYTE PTR [rbp-0x2]
  10c2b0:	89 c2                	mov    edx,eax
  10c2b2:	be fa 80 10 00       	mov    esi,0x1080fa
  10c2b7:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c2bc:	b8 00 00 00 00       	mov    eax,0x0
  10c2c1:	e8 31 0a 00 00       	call   10ccf7 <klog_write_fmt>
    }

    //TODO(Torin) How should this case be handled?  Is it even possbile to occur in practice?
    //What if the user has a stupidly slow computer?
    if(globals.keyboard.scancode_event_stack_count >= sizeof(globals.keyboard.scancode_event_stack)) {
  10c2c6:	48 8b 05 73 23 01 00 	mov    rax,QWORD PTR [rip+0x12373]        # 11e640 <globals+0x10640>
  10c2cd:	48 83 f8 07          	cmp    rax,0x7
  10c2d1:	76 16                	jbe    10c2e9 <irq_handler_keyboard+0x85>
      klog_warning("[keyboard_event] keyboard event stack reached maximum size before events were processed");
  10c2d3:	be 18 81 10 00       	mov    esi,0x108118
  10c2d8:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c2dd:	b8 00 00 00 00       	mov    eax,0x0
  10c2e2:	e8 10 0a 00 00       	call   10ccf7 <klog_write_fmt>
      return;
  10c2e7:	eb 4f                	jmp    10c338 <irq_handler_keyboard+0xd4>
    }

    if (scancode > 0x80) {  //NOTE(Torin)key release event 
  10c2e9:	80 7d fe 80          	cmp    BYTE PTR [rbp-0x2],0x80
  10c2ed:	76 19                	jbe    10c308 <irq_handler_keyboard+0xa4>
      uint8_t base_scancode = scancode - 0x80;
  10c2ef:	0f b6 45 fe          	movzx  eax,BYTE PTR [rbp-0x2]
  10c2f3:	83 c0 80             	add    eax,0xffffff80
  10c2f6:	88 45 fd             	mov    BYTE PTR [rbp-0x3],al
      globals.keyboard.keystate[base_scancode] = 0;
  10c2f9:	0f b6 45 fd          	movzx  eax,BYTE PTR [rbp-0x3]
  10c2fd:	48 98                	cdqe   
  10c2ff:	c6 80 40 e5 11 00 00 	mov    BYTE PTR [rax+0x11e540],0x0
  10c306:	eb 0d                	jmp    10c315 <irq_handler_keyboard+0xb1>
    } else { //NOTE(Torin)Key press event
      globals.keyboard.keystate[scancode] = 1;
  10c308:	0f b6 45 fe          	movzx  eax,BYTE PTR [rbp-0x2]
  10c30c:	48 98                	cdqe   
  10c30e:	c6 80 40 e5 11 00 01 	mov    BYTE PTR [rax+0x11e540],0x1
    }
    
    //TODO(Torin) we would be saving some subtractions cost in userspace by storing the keycode here instead of the
    //scanconde and adding an extra byte to store information about the isDown state and keyboard modifiers!
    globals.keyboard.scancode_event_stack[globals.keyboard.scancode_event_stack_count++] = scancode;
  10c315:	48 8b 0d 2c 23 01 00 	mov    rcx,QWORD PTR [rip+0x1232c]        # 11e648 <globals+0x10648>
  10c31c:	48 8b 05 1d 23 01 00 	mov    rax,QWORD PTR [rip+0x1231d]        # 11e640 <globals+0x10640>
  10c323:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10c327:	48 89 15 12 23 01 00 	mov    QWORD PTR [rip+0x12312],rdx        # 11e640 <globals+0x10640>
  10c32e:	48 8d 14 01          	lea    rdx,[rcx+rax*1]
  10c332:	0f b6 45 fe          	movzx  eax,BYTE PTR [rbp-0x2]
  10c336:	88 02                	mov    BYTE PTR [rdx],al
  }
}
  10c338:	c9                   	leave  
  10c339:	c3                   	ret    

000000000010c33a <klog_process_keyevents>:

static void 
klog_process_keyevents(Keyboard_State *keyboard, Circular_Log *log){
  10c33a:	55                   	push   rbp
  10c33b:	48 89 e5             	mov    rbp,rsp
  10c33e:	48 83 ec 20          	sub    rsp,0x20
  10c342:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10c346:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  for(size_t i = 0; i < keyboard->scancode_event_stack_count; i++){
  10c34a:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10c351:	00 
  10c352:	e9 2e 01 00 00       	jmp    10c485 <klog_process_keyevents+0x14b>
    uint8_t scancode = keyboard->scancode_event_stack[i];
  10c357:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10c35b:	48 8b 90 08 01 00 00 	mov    rdx,QWORD PTR [rax+0x108]
  10c362:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c366:	48 01 d0             	add    rax,rdx
  10c369:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c36c:	88 45 f6             	mov    BYTE PTR [rbp-0xa],al

    if(scancode == KEYCODE_BACKSPACE_PRESSED){
  10c36f:	80 7d f6 0e          	cmp    BYTE PTR [rbp-0xa],0xe
  10c373:	75 11                	jne    10c386 <klog_process_keyevents+0x4c>
      klog_remove_last_input_character(log);
  10c375:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c379:	48 89 c7             	mov    rdi,rax
  10c37c:	e8 12 0c 00 00       	call   10cf93 <klog_remove_last_input_character>
  10c381:	e9 9e 00 00 00       	jmp    10c424 <klog_process_keyevents+0xea>
		} else if(scancode == KEYCODE_ENTER_PRESSED){
  10c386:	80 7d f6 1c          	cmp    BYTE PTR [rbp-0xa],0x1c
  10c38a:	75 11                	jne    10c39d <klog_process_keyevents+0x63>
      klog_submit_input_to_shell(log);
  10c38c:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c390:	48 89 c7             	mov    rdi,rax
  10c393:	e8 7a 0c 00 00       	call   10d012 <klog_submit_input_to_shell>
  10c398:	e9 87 00 00 00       	jmp    10c424 <klog_process_keyevents+0xea>
		} else if (scancode == KEYCODE_UP_PRESSED){
  10c39d:	80 7d f6 48          	cmp    BYTE PTR [rbp-0xa],0x48
  10c3a1:	75 46                	jne    10c3e9 <klog_process_keyevents+0xaf>
      if(log->scroll_offset < log->current_entry_count - 1){
  10c3a3:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c3a7:	48 8b 90 10 04 01 00 	mov    rdx,QWORD PTR [rax+0x10410]
  10c3ae:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c3b2:	48 8b 80 08 04 01 00 	mov    rax,QWORD PTR [rax+0x10408]
  10c3b9:	48 83 e8 01          	sub    rax,0x1
  10c3bd:	48 39 c2             	cmp    rdx,rax
  10c3c0:	73 1a                	jae    10c3dc <klog_process_keyevents+0xa2>
        log->scroll_offset += 1;
  10c3c2:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c3c6:	48 8b 80 10 04 01 00 	mov    rax,QWORD PTR [rax+0x10410]
  10c3cd:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10c3d1:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c3d5:	48 89 90 10 04 01 00 	mov    QWORD PTR [rax+0x10410],rdx
      }


      log->is_dirty = true;
  10c3dc:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c3e0:	c6 80 24 05 01 00 01 	mov    BYTE PTR [rax+0x10524],0x1
  10c3e7:	eb 3b                	jmp    10c424 <klog_process_keyevents+0xea>
    } else if (scancode == KEYCODE_DOWN_PRESSED){
  10c3e9:	80 7d f6 50          	cmp    BYTE PTR [rbp-0xa],0x50
  10c3ed:	75 35                	jne    10c424 <klog_process_keyevents+0xea>
      if(log->scroll_offset > 0){
  10c3ef:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c3f3:	48 8b 80 10 04 01 00 	mov    rax,QWORD PTR [rax+0x10410]
  10c3fa:	48 85 c0             	test   rax,rax
  10c3fd:	74 25                	je     10c424 <klog_process_keyevents+0xea>
        log->scroll_offset -= 1;
  10c3ff:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c403:	48 8b 80 10 04 01 00 	mov    rax,QWORD PTR [rax+0x10410]
  10c40a:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  10c40e:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c412:	48 89 90 10 04 01 00 	mov    QWORD PTR [rax+0x10410],rdx
        log->is_dirty = true;
  10c419:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c41d:	c6 80 24 05 01 00 01 	mov    BYTE PTR [rax+0x10524],0x1
      }
    }

    if(scancode < (int)sizeof(SCANCODE_TO_LOWERCASE_ACII)){
  10c424:	80 7d f6 39          	cmp    BYTE PTR [rbp-0xa],0x39
  10c428:	77 56                	ja     10c480 <klog_process_keyevents+0x146>
      char ascii_character = 0;
  10c42a:	c6 45 f7 00          	mov    BYTE PTR [rbp-0x9],0x0
      if(keyboard->keystate[KEYBOARD_SCANCODE1_LSHIFT] ||
  10c42e:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10c432:	0f b6 40 2a          	movzx  eax,BYTE PTR [rax+0x2a]
  10c436:	84 c0                	test   al,al
  10c438:	75 0c                	jne    10c446 <klog_process_keyevents+0x10c>
        keyboard->keystate[KEYBOARD_SCANCODE1_RSHIFT]){
  10c43a:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10c43e:	0f b6 40 36          	movzx  eax,BYTE PTR [rax+0x36]
      if(keyboard->keystate[KEYBOARD_SCANCODE1_LSHIFT] ||
  10c442:	84 c0                	test   al,al
  10c444:	74 12                	je     10c458 <klog_process_keyevents+0x11e>
        ascii_character = SCANCODE_TO_UPERCASE_ACII[scancode];
  10c446:	0f b6 45 f6          	movzx  eax,BYTE PTR [rbp-0xa]
  10c44a:	48 98                	cdqe   
  10c44c:	0f b6 80 c0 80 10 00 	movzx  eax,BYTE PTR [rax+0x1080c0]
  10c453:	88 45 f7             	mov    BYTE PTR [rbp-0x9],al
  10c456:	eb 10                	jmp    10c468 <klog_process_keyevents+0x12e>
      } else { ascii_character = SCANCODE_TO_LOWERCASE_ACII[scancode]; }
  10c458:	0f b6 45 f6          	movzx  eax,BYTE PTR [rbp-0xa]
  10c45c:	48 98                	cdqe   
  10c45e:	0f b6 80 80 80 10 00 	movzx  eax,BYTE PTR [rax+0x108080]
  10c465:	88 45 f7             	mov    BYTE PTR [rbp-0x9],al
      if(ascii_character == 0) return;
  10c468:	80 7d f7 00          	cmp    BYTE PTR [rbp-0x9],0x0
  10c46c:	74 2e                	je     10c49c <klog_process_keyevents+0x162>
      klog_add_input_character(log, ascii_character);
  10c46e:	0f be 55 f7          	movsx  edx,BYTE PTR [rbp-0x9]
  10c472:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c476:	89 d6                	mov    esi,edx
  10c478:	48 89 c7             	mov    rdi,rax
  10c47b:	e8 6a 0a 00 00       	call   10ceea <klog_add_input_character>
  for(size_t i = 0; i < keyboard->scancode_event_stack_count; i++){
  10c480:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10c485:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10c489:	48 8b 80 00 01 00 00 	mov    rax,QWORD PTR [rax+0x100]
  10c490:	48 3b 45 f8          	cmp    rax,QWORD PTR [rbp-0x8]
  10c494:	0f 87 bd fe ff ff    	ja     10c357 <klog_process_keyevents+0x1d>
  10c49a:	eb 01                	jmp    10c49d <klog_process_keyevents+0x163>
      if(ascii_character == 0) return;
  10c49c:	90                   	nop
    }
  }
}
  10c49d:	c9                   	leave  
  10c49e:	c3                   	ret    

000000000010c49f <irq_handler_pit>:

static void 
irq_handler_pit(void) {
  10c49f:	55                   	push   rbp
  10c4a0:	48 89 e5             	mov    rbp,rsp
  10c4a3:	48 83 ec 10          	sub    rsp,0x10
  bochs_magic_breakpoint;
  10c4a7:	66 87 db             	xchg   bx,bx
  Keyboard_State *keyboard = &globals.keyboard;
  10c4aa:	48 c7 45 f8 40 e5 11 	mov    QWORD PTR [rbp-0x8],0x11e540
  10c4b1:	00 
  if(globals.keyboard.scancode_event_stack_count > 0){
  10c4b2:	48 8b 05 87 21 01 00 	mov    rax,QWORD PTR [rip+0x12187]        # 11e640 <globals+0x10640>
  10c4b9:	48 85 c0             	test   rax,rax
  10c4bc:	0f 84 86 00 00 00    	je     10c548 <irq_handler_pit+0xa9>
    klog_process_keyevents(keyboard, &globals.log); 
  10c4c2:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c4c6:	be 00 e0 10 00       	mov    esi,0x10e000
  10c4cb:	48 89 c7             	mov    rdi,rax
  10c4ce:	e8 67 fe ff ff       	call   10c33a <klog_process_keyevents>
    if(keyboard->scancode_event_stack == keyboard->scancode_event_stack0){
  10c4d3:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c4d7:	48 8b 80 08 01 00 00 	mov    rax,QWORD PTR [rax+0x108]
  10c4de:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10c4e2:	48 81 c2 10 01 00 00 	add    rdx,0x110
  10c4e9:	48 39 d0             	cmp    rax,rdx
  10c4ec:	75 18                	jne    10c506 <irq_handler_pit+0x67>
      keyboard->scancode_event_stack = keyboard->scancode_event_stack1;
  10c4ee:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c4f2:	48 8d 90 30 01 00 00 	lea    rdx,[rax+0x130]
  10c4f9:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c4fd:	48 89 90 08 01 00 00 	mov    QWORD PTR [rax+0x108],rdx
  10c504:	eb 16                	jmp    10c51c <irq_handler_pit+0x7d>
    } else { keyboard->scancode_event_stack = keyboard->scancode_event_stack0; }
  10c506:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c50a:	48 8d 90 10 01 00 00 	lea    rdx,[rax+0x110]
  10c511:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c515:	48 89 90 08 01 00 00 	mov    QWORD PTR [rax+0x108],rdx
    memset(keyboard->scancode_event_stack, 0x00, sizeof(keyboard->scancode_event_stack0));
  10c51c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c520:	48 8b 80 08 01 00 00 	mov    rax,QWORD PTR [rax+0x108]
  10c527:	ba 20 00 00 00       	mov    edx,0x20
  10c52c:	be 00 00 00 00       	mov    esi,0x0
  10c531:	48 89 c7             	mov    rdi,rax
  10c534:	e8 c7 ca ff ff       	call   109000 <__memset>
    keyboard->scancode_event_stack_count = 0;
  10c539:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c53d:	48 c7 80 00 01 00 00 	mov    QWORD PTR [rax+0x100],0x0
  10c544:	00 00 00 00 
  }

	kgfx_draw_log_if_dirty(&globals.log);
  10c548:	bf 00 e0 10 00       	mov    edi,0x10e000
  10c54d:	e8 cc d0 ff ff       	call   10961e <kgfx_draw_log_if_dirty>
  10c552:	90                   	nop
  10c553:	c9                   	leave  
  10c554:	c3                   	ret    

000000000010c555 <string_inplace_reverse>:
  uint32_to_string_base16(dest + 8, value0);
}
#endif

static inline
void string_inplace_reverse(char *str, size_t length){
  10c555:	55                   	push   rbp
  10c556:	48 89 e5             	mov    rbp,rsp
  10c559:	48 83 ec 30          	sub    rsp,0x30
  10c55d:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  10c561:	48 89 75 d0          	mov    QWORD PTR [rbp-0x30],rsi
  size_t midpoint = length / 2;
  10c565:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10c569:	48 d1 e8             	shr    rax,1
  10c56c:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
  for(size_t i = 0; i < midpoint; i++){
  10c570:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10c577:	00 
  10c578:	eb 52                	jmp    10c5cc <string_inplace_reverse+0x77>
    char oldValue = str[i];
  10c57a:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
  10c57e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c582:	48 01 d0             	add    rax,rdx
  10c585:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c588:	88 45 ef             	mov    BYTE PTR [rbp-0x11],al
    str[i] = str[length - 1 - i];
  10c58b:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
  10c58f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c593:	48 01 c2             	add    rdx,rax
  10c596:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10c59a:	48 2b 45 f8          	sub    rax,QWORD PTR [rbp-0x8]
  10c59e:	48 8d 48 ff          	lea    rcx,[rax-0x1]
  10c5a2:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10c5a6:	48 01 c8             	add    rax,rcx
  10c5a9:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c5ac:	88 02                	mov    BYTE PTR [rdx],al
    str[length - 1 - i] = oldValue;
  10c5ae:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10c5b2:	48 2b 45 f8          	sub    rax,QWORD PTR [rbp-0x8]
  10c5b6:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  10c5ba:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10c5be:	48 01 c2             	add    rdx,rax
  10c5c1:	0f b6 45 ef          	movzx  eax,BYTE PTR [rbp-0x11]
  10c5c5:	88 02                	mov    BYTE PTR [rdx],al
  for(size_t i = 0; i < midpoint; i++){
  10c5c7:	48 83 45 f8 01       	add    QWORD PTR [rbp-0x8],0x1
  10c5cc:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c5d0:	48 3b 45 f0          	cmp    rax,QWORD PTR [rbp-0x10]
  10c5d4:	72 a4                	jb     10c57a <string_inplace_reverse+0x25>
  }
} 
  10c5d6:	90                   	nop
  10c5d7:	c9                   	leave  
  10c5d8:	c3                   	ret    

000000000010c5d9 <uint64_to_string>:

static inline 
size_t uint64_to_string(char *dest, uint64_t value, uint8_t base){
  10c5d9:	55                   	push   rbp
  10c5da:	48 89 e5             	mov    rbp,rsp
  10c5dd:	48 83 ec 28          	sub    rsp,0x28
  10c5e1:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10c5e5:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  10c5e9:	89 d0                	mov    eax,edx
  10c5eb:	88 45 dc             	mov    BYTE PTR [rbp-0x24],al
  size_t bytes_written = 0;
  10c5ee:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10c5f5:	00 
  if(value == 0) {
  10c5f6:	48 83 7d e0 00       	cmp    QWORD PTR [rbp-0x20],0x0
  10c5fb:	75 55                	jne    10c652 <uint64_to_string+0x79>
    dest[0] = '0';
  10c5fd:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10c601:	c6 00 30             	mov    BYTE PTR [rax],0x30
    bytes_written = 1;
  10c604:	48 c7 45 f8 01 00 00 	mov    QWORD PTR [rbp-0x8],0x1
  10c60b:	00 
  10c60c:	eb 5e                	jmp    10c66c <uint64_to_string+0x93>
  } else {
    while(value > 0){
      static const char LOOKUP[] = "0123456789ABCDEF";
      dest[bytes_written++] = LOOKUP[value % base];
  10c60e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c612:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10c616:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
  10c61a:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  10c61e:	48 8d 0c 10          	lea    rcx,[rax+rdx*1]
  10c622:	0f b6 75 dc          	movzx  esi,BYTE PTR [rbp-0x24]
  10c626:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c62a:	ba 00 00 00 00       	mov    edx,0x0
  10c62f:	48 f7 f6             	div    rsi
  10c632:	48 89 d0             	mov    rax,rdx
  10c635:	0f b6 80 90 83 10 00 	movzx  eax,BYTE PTR [rax+0x108390]
  10c63c:	88 01                	mov    BYTE PTR [rcx],al
      value /= base;
  10c63e:	0f b6 4d dc          	movzx  ecx,BYTE PTR [rbp-0x24]
  10c642:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10c646:	ba 00 00 00 00       	mov    edx,0x0
  10c64b:	48 f7 f1             	div    rcx
  10c64e:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
    while(value > 0){
  10c652:	48 83 7d e0 00       	cmp    QWORD PTR [rbp-0x20],0x0
  10c657:	75 b5                	jne    10c60e <uint64_to_string+0x35>
    }
    string_inplace_reverse(dest, bytes_written);
  10c659:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10c65d:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10c661:	48 89 d6             	mov    rsi,rdx
  10c664:	48 89 c7             	mov    rdi,rax
  10c667:	e8 e9 fe ff ff       	call   10c555 <string_inplace_reverse>
  }
  return bytes_written;
  10c66c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
}
  10c670:	c9                   	leave  
  10c671:	c3                   	ret    

000000000010c672 <kernel_vsnprintf>:
  return bytes_written;
}

static size_t 
kernel_vsnprintf(char *buffer, size_t capacity, const char *fmt, va_list args) 
{
  10c672:	55                   	push   rbp
  10c673:	48 89 e5             	mov    rbp,rsp
  10c676:	48 83 c4 80          	add    rsp,0xffffffffffffff80
  10c67a:	48 89 7d 98          	mov    QWORD PTR [rbp-0x68],rdi
  10c67e:	48 89 75 90          	mov    QWORD PTR [rbp-0x70],rsi
  10c682:	48 89 55 88          	mov    QWORD PTR [rbp-0x78],rdx
  10c686:	48 89 4d 80          	mov    QWORD PTR [rbp-0x80],rcx
  size_t bytes_written = 0;
  10c68a:	48 c7 45 f8 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
  10c691:	00 
  size_t fmt_index = 0;
  10c692:	48 c7 45 f0 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
  10c699:	00 
  while(fmt[fmt_index] != 0){
  10c69a:	e9 8c 04 00 00       	jmp    10cb2b <kernel_vsnprintf+0x4b9>
    if(fmt[fmt_index] == '%'){
  10c69f:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c6a3:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c6a7:	48 01 d0             	add    rax,rdx
  10c6aa:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c6ad:	3c 25                	cmp    al,0x25
  10c6af:	0f 85 f1 03 00 00    	jne    10caa6 <kernel_vsnprintf+0x434>
			fmt_index++;
  10c6b5:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1

			if(fmt[fmt_index] == 'l') {
  10c6ba:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c6be:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c6c2:	48 01 d0             	add    rax,rdx
  10c6c5:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c6c8:	3c 6c                	cmp    al,0x6c
  10c6ca:	0f 85 aa 00 00 00    	jne    10c77a <kernel_vsnprintf+0x108>
				fmt_index++;
  10c6d0:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
				if(fmt[fmt_index] == 'u') {
  10c6d5:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c6d9:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c6dd:	48 01 d0             	add    rax,rdx
  10c6e0:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c6e3:	3c 75                	cmp    al,0x75
  10c6e5:	0f 85 40 04 00 00    	jne    10cb2b <kernel_vsnprintf+0x4b9>
					uint64_t value = va_arg(args, uint64_t);
  10c6eb:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c6ef:	8b 00                	mov    eax,DWORD PTR [rax]
  10c6f1:	83 f8 2f             	cmp    eax,0x2f
  10c6f4:	77 24                	ja     10c71a <kernel_vsnprintf+0xa8>
  10c6f6:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c6fa:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10c6fe:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c702:	8b 00                	mov    eax,DWORD PTR [rax]
  10c704:	89 c0                	mov    eax,eax
  10c706:	48 01 d0             	add    rax,rdx
  10c709:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c70d:	8b 12                	mov    edx,DWORD PTR [rdx]
  10c70f:	8d 4a 08             	lea    ecx,[rdx+0x8]
  10c712:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c716:	89 0a                	mov    DWORD PTR [rdx],ecx
  10c718:	eb 14                	jmp    10c72e <kernel_vsnprintf+0xbc>
  10c71a:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c71e:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10c722:	48 8d 48 08          	lea    rcx,[rax+0x8]
  10c726:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c72a:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  10c72e:	48 8b 00             	mov    rax,QWORD PTR [rax]
  10c731:	48 89 45 a8          	mov    QWORD PTR [rbp-0x58],rax
          if(bytes_written + 20 > capacity) return bytes_written;
  10c735:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c739:	48 83 c0 14          	add    rax,0x14
  10c73d:	48 3b 45 90          	cmp    rax,QWORD PTR [rbp-0x70]
  10c741:	76 09                	jbe    10c74c <kernel_vsnprintf+0xda>
  10c743:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c747:	e9 f9 03 00 00       	jmp    10cb45 <kernel_vsnprintf+0x4d3>
          bytes_written += uint64_to_string(buffer + bytes_written, value, 10);
  10c74c:	48 8b 55 98          	mov    rdx,QWORD PTR [rbp-0x68]
  10c750:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c754:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
  10c758:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
  10c75c:	ba 0a 00 00 00       	mov    edx,0xa
  10c761:	48 89 c6             	mov    rsi,rax
  10c764:	48 89 cf             	mov    rdi,rcx
  10c767:	e8 6d fe ff ff       	call   10c5d9 <uint64_to_string>
  10c76c:	48 01 45 f8          	add    QWORD PTR [rbp-0x8],rax
          fmt_index++;
  10c770:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  10c775:	e9 b1 03 00 00       	jmp    10cb2b <kernel_vsnprintf+0x4b9>
				}
			}

      //uint32_t base16	
			else if (fmt[fmt_index] == 'u') {
  10c77a:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c77e:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c782:	48 01 d0             	add    rax,rdx
  10c785:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c788:	3c 75                	cmp    al,0x75
  10c78a:	0f 85 8b 00 00 00    	jne    10c81b <kernel_vsnprintf+0x1a9>
				uint32_t value = va_arg(args, uint32_t);
  10c790:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c794:	8b 00                	mov    eax,DWORD PTR [rax]
  10c796:	83 f8 2f             	cmp    eax,0x2f
  10c799:	77 24                	ja     10c7bf <kernel_vsnprintf+0x14d>
  10c79b:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c79f:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10c7a3:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c7a7:	8b 00                	mov    eax,DWORD PTR [rax]
  10c7a9:	89 c0                	mov    eax,eax
  10c7ab:	48 01 d0             	add    rax,rdx
  10c7ae:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c7b2:	8b 12                	mov    edx,DWORD PTR [rdx]
  10c7b4:	8d 4a 08             	lea    ecx,[rdx+0x8]
  10c7b7:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c7bb:	89 0a                	mov    DWORD PTR [rdx],ecx
  10c7bd:	eb 14                	jmp    10c7d3 <kernel_vsnprintf+0x161>
  10c7bf:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c7c3:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10c7c7:	48 8d 48 08          	lea    rcx,[rax+0x8]
  10c7cb:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c7cf:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  10c7d3:	8b 00                	mov    eax,DWORD PTR [rax]
  10c7d5:	89 45 dc             	mov    DWORD PTR [rbp-0x24],eax
        if(bytes_written + 10 > capacity) return bytes_written;
  10c7d8:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c7dc:	48 83 c0 0a          	add    rax,0xa
  10c7e0:	48 3b 45 90          	cmp    rax,QWORD PTR [rbp-0x70]
  10c7e4:	76 09                	jbe    10c7ef <kernel_vsnprintf+0x17d>
  10c7e6:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c7ea:	e9 56 03 00 00       	jmp    10cb45 <kernel_vsnprintf+0x4d3>
				bytes_written += uint64_to_string(buffer + bytes_written, (uint64_t)value, 10);
  10c7ef:	8b 45 dc             	mov    eax,DWORD PTR [rbp-0x24]
  10c7f2:	48 8b 4d 98          	mov    rcx,QWORD PTR [rbp-0x68]
  10c7f6:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10c7fa:	48 01 d1             	add    rcx,rdx
  10c7fd:	ba 0a 00 00 00       	mov    edx,0xa
  10c802:	48 89 c6             	mov    rsi,rax
  10c805:	48 89 cf             	mov    rdi,rcx
  10c808:	e8 cc fd ff ff       	call   10c5d9 <uint64_to_string>
  10c80d:	48 01 45 f8          	add    QWORD PTR [rbp-0x8],rax
        fmt_index++;
  10c811:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  10c816:	e9 10 03 00 00       	jmp    10cb2b <kernel_vsnprintf+0x4b9>
			}

      //cstring
			else if (fmt[fmt_index] == 's') {
  10c81b:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c81f:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c823:	48 01 d0             	add    rax,rdx
  10c826:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c829:	3c 73                	cmp    al,0x73
  10c82b:	0f 85 a5 00 00 00    	jne    10c8d6 <kernel_vsnprintf+0x264>
				const char *str = (const char *)va_arg(args, uintptr_t);
  10c831:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c835:	8b 00                	mov    eax,DWORD PTR [rax]
  10c837:	83 f8 2f             	cmp    eax,0x2f
  10c83a:	77 24                	ja     10c860 <kernel_vsnprintf+0x1ee>
  10c83c:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c840:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10c844:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c848:	8b 00                	mov    eax,DWORD PTR [rax]
  10c84a:	89 c0                	mov    eax,eax
  10c84c:	48 01 d0             	add    rax,rdx
  10c84f:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c853:	8b 12                	mov    edx,DWORD PTR [rdx]
  10c855:	8d 4a 08             	lea    ecx,[rdx+0x8]
  10c858:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c85c:	89 0a                	mov    DWORD PTR [rdx],ecx
  10c85e:	eb 14                	jmp    10c874 <kernel_vsnprintf+0x202>
  10c860:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c864:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10c868:	48 8d 48 08          	lea    rcx,[rax+0x8]
  10c86c:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c870:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  10c874:	48 8b 00             	mov    rax,QWORD PTR [rax]
  10c877:	48 89 45 d0          	mov    QWORD PTR [rbp-0x30],rax
				size_t length = strlen(str);
  10c87b:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10c87f:	48 89 c7             	mov    rdi,rax
  10c882:	e8 06 c8 ff ff       	call   10908d <strlen>
  10c887:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
        if(bytes_written + length > capacity) return bytes_written;
  10c88b:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10c88f:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  10c893:	48 01 d0             	add    rax,rdx
  10c896:	48 3b 45 90          	cmp    rax,QWORD PTR [rbp-0x70]
  10c89a:	76 09                	jbe    10c8a5 <kernel_vsnprintf+0x233>
  10c89c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c8a0:	e9 a0 02 00 00       	jmp    10cb45 <kernel_vsnprintf+0x4d3>
        memcpy(buffer + bytes_written, str, length);
  10c8a5:	48 8b 55 98          	mov    rdx,QWORD PTR [rbp-0x68]
  10c8a9:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c8ad:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
  10c8b1:	48 8b 55 c8          	mov    rdx,QWORD PTR [rbp-0x38]
  10c8b5:	48 8b 45 d0          	mov    rax,QWORD PTR [rbp-0x30]
  10c8b9:	48 89 c6             	mov    rsi,rax
  10c8bc:	48 89 cf             	mov    rdi,rcx
  10c8bf:	e8 7e c7 ff ff       	call   109042 <__memcpy>
        bytes_written += length; 
  10c8c4:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
  10c8c8:	48 01 45 f8          	add    QWORD PTR [rbp-0x8],rax
				fmt_index++;
  10c8cc:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  10c8d1:	e9 55 02 00 00       	jmp    10cb2b <kernel_vsnprintf+0x4b9>
			}

      else if(fmt[fmt_index] == 'X'){
  10c8d6:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c8da:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c8de:	48 01 d0             	add    rax,rdx
  10c8e1:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c8e4:	3c 58                	cmp    al,0x58
  10c8e6:	0f 85 8f 00 00 00    	jne    10c97b <kernel_vsnprintf+0x309>
        uint64_t value = va_arg(args, uint64_t);
  10c8ec:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c8f0:	8b 00                	mov    eax,DWORD PTR [rax]
  10c8f2:	83 f8 2f             	cmp    eax,0x2f
  10c8f5:	77 24                	ja     10c91b <kernel_vsnprintf+0x2a9>
  10c8f7:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c8fb:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10c8ff:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c903:	8b 00                	mov    eax,DWORD PTR [rax]
  10c905:	89 c0                	mov    eax,eax
  10c907:	48 01 d0             	add    rax,rdx
  10c90a:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c90e:	8b 12                	mov    edx,DWORD PTR [rdx]
  10c910:	8d 4a 08             	lea    ecx,[rdx+0x8]
  10c913:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c917:	89 0a                	mov    DWORD PTR [rdx],ecx
  10c919:	eb 14                	jmp    10c92f <kernel_vsnprintf+0x2bd>
  10c91b:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c91f:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10c923:	48 8d 48 08          	lea    rcx,[rax+0x8]
  10c927:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c92b:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  10c92f:	48 8b 00             	mov    rax,QWORD PTR [rax]
  10c932:	48 89 45 c0          	mov    QWORD PTR [rbp-0x40],rax
        if(bytes_written + 16 > capacity) return bytes_written;
  10c936:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c93a:	48 83 c0 10          	add    rax,0x10
  10c93e:	48 3b 45 90          	cmp    rax,QWORD PTR [rbp-0x70]
  10c942:	76 09                	jbe    10c94d <kernel_vsnprintf+0x2db>
  10c944:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c948:	e9 f8 01 00 00       	jmp    10cb45 <kernel_vsnprintf+0x4d3>
        bytes_written += uint64_to_string(buffer + bytes_written, value, 16);
  10c94d:	48 8b 55 98          	mov    rdx,QWORD PTR [rbp-0x68]
  10c951:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10c955:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
  10c959:	48 8b 45 c0          	mov    rax,QWORD PTR [rbp-0x40]
  10c95d:	ba 10 00 00 00       	mov    edx,0x10
  10c962:	48 89 c6             	mov    rsi,rax
  10c965:	48 89 cf             	mov    rdi,rcx
  10c968:	e8 6c fc ff ff       	call   10c5d9 <uint64_to_string>
  10c96d:	48 01 45 f8          	add    QWORD PTR [rbp-0x8],rax
        fmt_index++;
  10c971:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
  10c976:	e9 b0 01 00 00       	jmp    10cb2b <kernel_vsnprintf+0x4b9>
      }

			else if (fmt[fmt_index] == '.') {
  10c97b:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c97f:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c983:	48 01 d0             	add    rax,rdx
  10c986:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c989:	3c 2e                	cmp    al,0x2e
  10c98b:	0f 85 9a 01 00 00    	jne    10cb2b <kernel_vsnprintf+0x4b9>
				fmt_index++;
  10c991:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
				if(fmt[fmt_index] == '*'){
  10c996:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c99a:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c99e:	48 01 d0             	add    rax,rdx
  10c9a1:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c9a4:	3c 2a                	cmp    al,0x2a
  10c9a6:	0f 85 7f 01 00 00    	jne    10cb2b <kernel_vsnprintf+0x4b9>
					fmt_index++;
  10c9ac:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
          if(fmt[fmt_index] == 's'){
  10c9b1:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10c9b5:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10c9b9:	48 01 d0             	add    rax,rdx
  10c9bc:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10c9bf:	3c 73                	cmp    al,0x73
  10c9c1:	0f 85 64 01 00 00    	jne    10cb2b <kernel_vsnprintf+0x4b9>
            fmt_index++;
  10c9c7:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
            size_t str_length = (size_t)va_arg(args, uintptr_t);
  10c9cc:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c9d0:	8b 00                	mov    eax,DWORD PTR [rax]
  10c9d2:	83 f8 2f             	cmp    eax,0x2f
  10c9d5:	77 24                	ja     10c9fb <kernel_vsnprintf+0x389>
  10c9d7:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c9db:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10c9df:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c9e3:	8b 00                	mov    eax,DWORD PTR [rax]
  10c9e5:	89 c0                	mov    eax,eax
  10c9e7:	48 01 d0             	add    rax,rdx
  10c9ea:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c9ee:	8b 12                	mov    edx,DWORD PTR [rdx]
  10c9f0:	8d 4a 08             	lea    ecx,[rdx+0x8]
  10c9f3:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10c9f7:	89 0a                	mov    DWORD PTR [rdx],ecx
  10c9f9:	eb 14                	jmp    10ca0f <kernel_vsnprintf+0x39d>
  10c9fb:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10c9ff:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10ca03:	48 8d 48 08          	lea    rcx,[rax+0x8]
  10ca07:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10ca0b:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  10ca0f:	48 8b 00             	mov    rax,QWORD PTR [rax]
  10ca12:	48 89 45 b8          	mov    QWORD PTR [rbp-0x48],rax
            const char *str = (const char *)va_arg(args, uintptr_t);
  10ca16:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10ca1a:	8b 00                	mov    eax,DWORD PTR [rax]
  10ca1c:	83 f8 2f             	cmp    eax,0x2f
  10ca1f:	77 24                	ja     10ca45 <kernel_vsnprintf+0x3d3>
  10ca21:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10ca25:	48 8b 50 10          	mov    rdx,QWORD PTR [rax+0x10]
  10ca29:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10ca2d:	8b 00                	mov    eax,DWORD PTR [rax]
  10ca2f:	89 c0                	mov    eax,eax
  10ca31:	48 01 d0             	add    rax,rdx
  10ca34:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10ca38:	8b 12                	mov    edx,DWORD PTR [rdx]
  10ca3a:	8d 4a 08             	lea    ecx,[rdx+0x8]
  10ca3d:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10ca41:	89 0a                	mov    DWORD PTR [rdx],ecx
  10ca43:	eb 14                	jmp    10ca59 <kernel_vsnprintf+0x3e7>
  10ca45:	48 8b 45 80          	mov    rax,QWORD PTR [rbp-0x80]
  10ca49:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
  10ca4d:	48 8d 48 08          	lea    rcx,[rax+0x8]
  10ca51:	48 8b 55 80          	mov    rdx,QWORD PTR [rbp-0x80]
  10ca55:	48 89 4a 08          	mov    QWORD PTR [rdx+0x8],rcx
  10ca59:	48 8b 00             	mov    rax,QWORD PTR [rax]
  10ca5c:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
            if(bytes_written + str_length > capacity) return bytes_written;
  10ca60:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10ca64:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10ca68:	48 01 d0             	add    rax,rdx
  10ca6b:	48 3b 45 90          	cmp    rax,QWORD PTR [rbp-0x70]
  10ca6f:	76 09                	jbe    10ca7a <kernel_vsnprintf+0x408>
  10ca71:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10ca75:	e9 cb 00 00 00       	jmp    10cb45 <kernel_vsnprintf+0x4d3>
            memcpy(buffer + bytes_written, str, str_length);
  10ca7a:	48 8b 55 98          	mov    rdx,QWORD PTR [rbp-0x68]
  10ca7e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10ca82:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
  10ca86:	48 8b 55 b8          	mov    rdx,QWORD PTR [rbp-0x48]
  10ca8a:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
  10ca8e:	48 89 c6             	mov    rsi,rax
  10ca91:	48 89 cf             	mov    rdi,rcx
  10ca94:	e8 a9 c5 ff ff       	call   109042 <__memcpy>
            bytes_written += str_length;
  10ca99:	48 8b 45 b8          	mov    rax,QWORD PTR [rbp-0x48]
  10ca9d:	48 01 45 f8          	add    QWORD PTR [rbp-0x8],rax
  10caa1:	e9 85 00 00 00       	jmp    10cb2b <kernel_vsnprintf+0x4b9>
        }
			}
		}

		else {
      size_t begin = fmt_index;
  10caa6:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10caaa:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
      while(fmt[fmt_index] != '%' && fmt[fmt_index] != 0){
  10caae:	eb 05                	jmp    10cab5 <kernel_vsnprintf+0x443>
       fmt_index++; 
  10cab0:	48 83 45 f0 01       	add    QWORD PTR [rbp-0x10],0x1
      while(fmt[fmt_index] != '%' && fmt[fmt_index] != 0){
  10cab5:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10cab9:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10cabd:	48 01 d0             	add    rax,rdx
  10cac0:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10cac3:	3c 25                	cmp    al,0x25
  10cac5:	74 12                	je     10cad9 <kernel_vsnprintf+0x467>
  10cac7:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10cacb:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10cacf:	48 01 d0             	add    rax,rdx
  10cad2:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10cad5:	84 c0                	test   al,al
  10cad7:	75 d7                	jne    10cab0 <kernel_vsnprintf+0x43e>
      }

      size_t length = fmt_index - begin;
  10cad9:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10cadd:	48 2b 45 e8          	sub    rax,QWORD PTR [rbp-0x18]
  10cae1:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
      if(bytes_written + length > capacity) return bytes_written;
  10cae5:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10cae9:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10caed:	48 01 d0             	add    rax,rdx
  10caf0:	48 3b 45 90          	cmp    rax,QWORD PTR [rbp-0x70]
  10caf4:	76 06                	jbe    10cafc <kernel_vsnprintf+0x48a>
  10caf6:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cafa:	eb 49                	jmp    10cb45 <kernel_vsnprintf+0x4d3>
      memcpy(buffer + bytes_written, fmt + begin, length);
  10cafc:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10cb00:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cb04:	48 8d 34 02          	lea    rsi,[rdx+rax*1]
  10cb08:	48 8b 55 98          	mov    rdx,QWORD PTR [rbp-0x68]
  10cb0c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cb10:	48 8d 0c 02          	lea    rcx,[rdx+rax*1]
  10cb14:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10cb18:	48 89 c2             	mov    rdx,rax
  10cb1b:	48 89 cf             	mov    rdi,rcx
  10cb1e:	e8 1f c5 ff ff       	call   109042 <__memcpy>
      bytes_written += length;
  10cb23:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10cb27:	48 01 45 f8          	add    QWORD PTR [rbp-0x8],rax
  while(fmt[fmt_index] != 0){
  10cb2b:	48 8b 55 88          	mov    rdx,QWORD PTR [rbp-0x78]
  10cb2f:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10cb33:	48 01 d0             	add    rax,rdx
  10cb36:	0f b6 00             	movzx  eax,BYTE PTR [rax]
  10cb39:	84 c0                	test   al,al
  10cb3b:	0f 85 5e fb ff ff    	jne    10c69f <kernel_vsnprintf+0x2d>
		}
  } 
  return bytes_written;
  10cb41:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
}
  10cb45:	c9                   	leave  
  10cb46:	c3                   	ret    

000000000010cb47 <klog_get_next_available_entry>:

Circular_Log_Entry *klog_get_next_available_entry(Circular_Log *log){
  10cb47:	55                   	push   rbp
  10cb48:	48 89 e5             	mov    rbp,rsp
  10cb4b:	48 83 ec 18          	sub    rsp,0x18
  10cb4f:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  spinlock_aquire(&log->spinlock);
  10cb53:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cb57:	48 05 20 05 01 00    	add    rax,0x10520
  10cb5d:	48 89 c7             	mov    rdi,rax
  10cb60:	e8 59 c6 ff ff       	call   1091be <spinlock_aquire>
  size_t entry_index = log->entry_write_position % CIRCULAR_LOG_ENTRY_COUNT; 
  10cb65:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cb69:	48 8b 80 00 04 01 00 	mov    rax,QWORD PTR [rax+0x10400]
  10cb70:	25 ff 00 00 00       	and    eax,0xff
  10cb75:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  Circular_Log_Entry *entry = &log->entries[entry_index];
  10cb79:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10cb7d:	48 89 d0             	mov    rax,rdx
  10cb80:	48 c1 e0 06          	shl    rax,0x6
  10cb84:	48 01 d0             	add    rax,rdx
  10cb87:	48 c1 e0 02          	shl    rax,0x2
  10cb8b:	48 8b 55 e8          	mov    rdx,QWORD PTR [rbp-0x18]
  10cb8f:	48 01 d0             	add    rax,rdx
  10cb92:	48 89 45 f0          	mov    QWORD PTR [rbp-0x10],rax
  log->entry_write_position++;
  10cb96:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cb9a:	48 8b 80 00 04 01 00 	mov    rax,QWORD PTR [rax+0x10400]
  10cba1:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10cba5:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cba9:	48 89 90 00 04 01 00 	mov    QWORD PTR [rax+0x10400],rdx
  if(log->current_entry_count < CIRCULAR_LOG_ENTRY_COUNT) {
  10cbb0:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cbb4:	48 8b 80 08 04 01 00 	mov    rax,QWORD PTR [rax+0x10408]
  10cbbb:	48 3d ff 00 00 00    	cmp    rax,0xff
  10cbc1:	77 1a                	ja     10cbdd <klog_get_next_available_entry+0x96>
    log->current_entry_count++; 
  10cbc3:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cbc7:	48 8b 80 08 04 01 00 	mov    rax,QWORD PTR [rax+0x10408]
  10cbce:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10cbd2:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cbd6:	48 89 90 08 04 01 00 	mov    QWORD PTR [rax+0x10408],rdx
  }
  spinlock_release(&log->spinlock);
  10cbdd:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cbe1:	48 05 20 05 01 00    	add    rax,0x10520
  10cbe7:	48 89 c7             	mov    rdi,rax
  10cbea:	e8 fe c5 ff ff       	call   1091ed <spinlock_release>
  return entry;
  10cbef:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
}
  10cbf3:	c9                   	leave  
  10cbf4:	c3                   	ret    

000000000010cbf5 <klog_write_string>:

void klog_write_string(Circular_Log *log, const char *string, size_t length){
  10cbf5:	55                   	push   rbp
  10cbf6:	48 89 e5             	mov    rbp,rsp
  10cbf9:	48 83 ec 30          	sub    rsp,0x30
  10cbfd:	48 89 7d e8          	mov    QWORD PTR [rbp-0x18],rdi
  10cc01:	48 89 75 e0          	mov    QWORD PTR [rbp-0x20],rsi
  10cc05:	48 89 55 d8          	mov    QWORD PTR [rbp-0x28],rdx
  if(length > CIRCULAR_LOG_MESSAGE_SIZE){
  10cc09:	48 81 7d d8 00 01 00 	cmp    QWORD PTR [rbp-0x28],0x100
  10cc10:	00 
  10cc11:	76 40                	jbe    10cc53 <klog_write_string+0x5e>
    klog_error("failed to print string of length: %u", length);
  10cc13:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10cc17:	48 89 c2             	mov    rdx,rax
  10cc1a:	be 70 81 10 00       	mov    esi,0x108170
  10cc1f:	bf 00 e0 10 00       	mov    edi,0x10e000
  10cc24:	b8 00 00 00 00       	mov    eax,0x0
  10cc29:	e8 c9 00 00 00       	call   10ccf7 <klog_write_fmt>
    klog_error("string: %.*s", 30, string);
  10cc2e:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]
  10cc32:	48 89 c1             	mov    rcx,rax
  10cc35:	ba 1e 00 00 00       	mov    edx,0x1e
  10cc3a:	be 95 81 10 00       	mov    esi,0x108195
  10cc3f:	bf 00 e0 10 00       	mov    edi,0x10e000
  10cc44:	b8 00 00 00 00       	mov    eax,0x0
  10cc49:	e8 a9 00 00 00       	call   10ccf7 <klog_write_fmt>
    return;
  10cc4e:	e9 a2 00 00 00       	jmp    10ccf5 <klog_write_string+0x100>
  }

  if(globals.is_logging_disabled) return;
  10cc53:	0f b6 05 06 1b 01 00 	movzx  eax,BYTE PTR [rip+0x11b06]        # 11e760 <globals+0x10760>
  10cc5a:	84 c0                	test   al,al
  10cc5c:	0f 85 92 00 00 00    	jne    10ccf4 <klog_write_string+0xff>
  Circular_Log_Entry *entry = klog_get_next_available_entry(log);
  10cc62:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cc66:	48 89 c7             	mov    rdi,rax
  10cc69:	e8 d9 fe ff ff       	call   10cb47 <klog_get_next_available_entry>
  10cc6e:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
  memcpy(entry->message, string, length);
  10cc72:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cc76:	48 8b 55 d8          	mov    rdx,QWORD PTR [rbp-0x28]
  10cc7a:	48 8b 4d e0          	mov    rcx,QWORD PTR [rbp-0x20]
  10cc7e:	48 89 ce             	mov    rsi,rcx
  10cc81:	48 89 c7             	mov    rdi,rax
  10cc84:	e8 b9 c3 ff ff       	call   109042 <__memcpy>
  entry->length = length;
  10cc89:	48 8b 45 d8          	mov    rax,QWORD PTR [rbp-0x28]
  10cc8d:	89 c2                	mov    edx,eax
  10cc8f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cc93:	89 90 00 01 00 00    	mov    DWORD PTR [rax+0x100],edx

  spinlock_aquire(&log->spinlock);
  10cc99:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cc9d:	48 05 20 05 01 00    	add    rax,0x10520
  10cca3:	48 89 c7             	mov    rdi,rax
  10cca6:	e8 13 c5 ff ff       	call   1091be <spinlock_aquire>
  log->is_dirty = true;
  10ccab:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10ccaf:	c6 80 24 05 01 00 01 	mov    BYTE PTR [rax+0x10524],0x1
  write_serial(entry->message, entry->length);
  10ccb6:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10ccba:	8b 80 00 01 00 00    	mov    eax,DWORD PTR [rax+0x100]
  10ccc0:	89 c2                	mov    edx,eax
  10ccc2:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10ccc6:	48 89 d6             	mov    rsi,rdx
  10ccc9:	48 89 c7             	mov    rdi,rax
  10cccc:	e8 e4 db ff ff       	call   10a8b5 <write_serial>
  write_serial("\n", 1);
  10ccd1:	be 01 00 00 00       	mov    esi,0x1
  10ccd6:	bf a2 81 10 00       	mov    edi,0x1081a2
  10ccdb:	e8 d5 db ff ff       	call   10a8b5 <write_serial>
  spinlock_release(&log->spinlock);
  10cce0:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10cce4:	48 05 20 05 01 00    	add    rax,0x10520
  10ccea:	48 89 c7             	mov    rdi,rax
  10cced:	e8 fb c4 ff ff       	call   1091ed <spinlock_release>
  10ccf2:	eb 01                	jmp    10ccf5 <klog_write_string+0x100>
  if(globals.is_logging_disabled) return;
  10ccf4:	90                   	nop
}
  10ccf5:	c9                   	leave  
  10ccf6:	c3                   	ret    

000000000010ccf7 <klog_write_fmt>:

void klog_write_fmt(Circular_Log *log, const char *fmt, ...){
  10ccf7:	55                   	push   rbp
  10ccf8:	48 89 e5             	mov    rbp,rsp
  10ccfb:	48 81 ec f0 00 00 00 	sub    rsp,0xf0
  10cd02:	48 89 bd 18 ff ff ff 	mov    QWORD PTR [rbp-0xe8],rdi
  10cd09:	48 89 b5 10 ff ff ff 	mov    QWORD PTR [rbp-0xf0],rsi
  10cd10:	48 89 95 60 ff ff ff 	mov    QWORD PTR [rbp-0xa0],rdx
  10cd17:	48 89 8d 68 ff ff ff 	mov    QWORD PTR [rbp-0x98],rcx
  10cd1e:	4c 89 85 70 ff ff ff 	mov    QWORD PTR [rbp-0x90],r8
  10cd25:	4c 89 8d 78 ff ff ff 	mov    QWORD PTR [rbp-0x88],r9
  10cd2c:	84 c0                	test   al,al
  10cd2e:	74 20                	je     10cd50 <klog_write_fmt+0x59>
  10cd30:	0f 29 45 80          	movaps XMMWORD PTR [rbp-0x80],xmm0
  10cd34:	0f 29 4d 90          	movaps XMMWORD PTR [rbp-0x70],xmm1
  10cd38:	0f 29 55 a0          	movaps XMMWORD PTR [rbp-0x60],xmm2
  10cd3c:	0f 29 5d b0          	movaps XMMWORD PTR [rbp-0x50],xmm3
  10cd40:	0f 29 65 c0          	movaps XMMWORD PTR [rbp-0x40],xmm4
  10cd44:	0f 29 6d d0          	movaps XMMWORD PTR [rbp-0x30],xmm5
  10cd48:	0f 29 75 e0          	movaps XMMWORD PTR [rbp-0x20],xmm6
  10cd4c:	0f 29 7d f0          	movaps XMMWORD PTR [rbp-0x10],xmm7
  if(globals.is_logging_disabled) return;
  10cd50:	0f b6 05 09 1a 01 00 	movzx  eax,BYTE PTR [rip+0x11a09]        # 11e760 <globals+0x10760>
  10cd57:	84 c0                	test   al,al
  10cd59:	0f 85 88 01 00 00    	jne    10cee7 <klog_write_fmt+0x1f0>

  spinlock_aquire(&log->spinlock); 
  10cd5f:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10cd66:	48 05 20 05 01 00    	add    rax,0x10520
  10cd6c:	48 89 c7             	mov    rdi,rax
  10cd6f:	e8 4a c4 ff ff       	call   1091be <spinlock_aquire>
  size_t entry_index = log->entry_write_position % CIRCULAR_LOG_ENTRY_COUNT;
  10cd74:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10cd7b:	48 8b 80 00 04 01 00 	mov    rax,QWORD PTR [rax+0x10400]
  10cd82:	25 ff 00 00 00       	and    eax,0xff
  10cd87:	48 89 85 48 ff ff ff 	mov    QWORD PTR [rbp-0xb8],rax
  Circular_Log_Entry *entry = &log->entries[entry_index];
  10cd8e:	48 8b 95 48 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xb8]
  10cd95:	48 89 d0             	mov    rax,rdx
  10cd98:	48 c1 e0 06          	shl    rax,0x6
  10cd9c:	48 01 d0             	add    rax,rdx
  10cd9f:	48 c1 e0 02          	shl    rax,0x2
  10cda3:	48 8b 95 18 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xe8]
  10cdaa:	48 01 d0             	add    rax,rdx
  10cdad:	48 89 85 40 ff ff ff 	mov    QWORD PTR [rbp-0xc0],rax
  log->entry_write_position++;
  10cdb4:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10cdbb:	48 8b 80 00 04 01 00 	mov    rax,QWORD PTR [rax+0x10400]
  10cdc2:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10cdc6:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10cdcd:	48 89 90 00 04 01 00 	mov    QWORD PTR [rax+0x10400],rdx
  if(log->current_entry_count < CIRCULAR_LOG_ENTRY_COUNT){ log->current_entry_count++; }
  10cdd4:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10cddb:	48 8b 80 08 04 01 00 	mov    rax,QWORD PTR [rax+0x10408]
  10cde2:	48 3d ff 00 00 00    	cmp    rax,0xff
  10cde8:	77 20                	ja     10ce0a <klog_write_fmt+0x113>
  10cdea:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10cdf1:	48 8b 80 08 04 01 00 	mov    rax,QWORD PTR [rax+0x10408]
  10cdf8:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10cdfc:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10ce03:	48 89 90 08 04 01 00 	mov    QWORD PTR [rax+0x10408],rdx
  spinlock_release(&log->spinlock);
  10ce0a:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10ce11:	48 05 20 05 01 00    	add    rax,0x10520
  10ce17:	48 89 c7             	mov    rdi,rax
  10ce1a:	e8 ce c3 ff ff       	call   1091ed <spinlock_release>
  
  va_list args;
  va_start(args, fmt);
  10ce1f:	c7 85 28 ff ff ff 10 	mov    DWORD PTR [rbp-0xd8],0x10
  10ce26:	00 00 00 
  10ce29:	c7 85 2c ff ff ff 30 	mov    DWORD PTR [rbp-0xd4],0x30
  10ce30:	00 00 00 
  10ce33:	48 8d 45 10          	lea    rax,[rbp+0x10]
  10ce37:	48 89 85 30 ff ff ff 	mov    QWORD PTR [rbp-0xd0],rax
  10ce3e:	48 8d 85 50 ff ff ff 	lea    rax,[rbp-0xb0]
  10ce45:	48 89 85 38 ff ff ff 	mov    QWORD PTR [rbp-0xc8],rax
  entry->length = kernel_vsnprintf(entry->message, CIRCULAR_LOG_MESSAGE_SIZE, fmt, args);
  10ce4c:	48 8b 85 40 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc0]
  10ce53:	48 8d 8d 28 ff ff ff 	lea    rcx,[rbp-0xd8]
  10ce5a:	48 8b 95 10 ff ff ff 	mov    rdx,QWORD PTR [rbp-0xf0]
  10ce61:	be 00 01 00 00       	mov    esi,0x100
  10ce66:	48 89 c7             	mov    rdi,rax
  10ce69:	e8 04 f8 ff ff       	call   10c672 <kernel_vsnprintf>
  10ce6e:	89 c2                	mov    edx,eax
  10ce70:	48 8b 85 40 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc0]
  10ce77:	89 90 00 01 00 00    	mov    DWORD PTR [rax+0x100],edx
  va_end(args);

  //NOTE(Torin: 2016-08-08) This could cause serial output to mismatch
  //console output if a cpu core formats a sufficantly small message and aquires
  //the spin lock before the first core finishes formating the message
  spinlock_aquire(&log->spinlock);
  10ce7d:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10ce84:	48 05 20 05 01 00    	add    rax,0x10520
  10ce8a:	48 89 c7             	mov    rdi,rax
  10ce8d:	e8 2c c3 ff ff       	call   1091be <spinlock_aquire>
  log->is_dirty = true;
  10ce92:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10ce99:	c6 80 24 05 01 00 01 	mov    BYTE PTR [rax+0x10524],0x1
  write_serial(entry->message, entry->length);
  10cea0:	48 8b 85 40 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc0]
  10cea7:	8b 80 00 01 00 00    	mov    eax,DWORD PTR [rax+0x100]
  10cead:	89 c2                	mov    edx,eax
  10ceaf:	48 8b 85 40 ff ff ff 	mov    rax,QWORD PTR [rbp-0xc0]
  10ceb6:	48 89 d6             	mov    rsi,rdx
  10ceb9:	48 89 c7             	mov    rdi,rax
  10cebc:	e8 f4 d9 ff ff       	call   10a8b5 <write_serial>
  write_serial("\n", 1);
  10cec1:	be 01 00 00 00       	mov    esi,0x1
  10cec6:	bf a2 81 10 00       	mov    edi,0x1081a2
  10cecb:	e8 e5 d9 ff ff       	call   10a8b5 <write_serial>
  spinlock_release(&log->spinlock);
  10ced0:	48 8b 85 18 ff ff ff 	mov    rax,QWORD PTR [rbp-0xe8]
  10ced7:	48 05 20 05 01 00    	add    rax,0x10520
  10cedd:	48 89 c7             	mov    rdi,rax
  10cee0:	e8 08 c3 ff ff       	call   1091ed <spinlock_release>
  10cee5:	eb 01                	jmp    10cee8 <klog_write_fmt+0x1f1>
  if(globals.is_logging_disabled) return;
  10cee7:	90                   	nop
}
  10cee8:	c9                   	leave  
  10cee9:	c3                   	ret    

000000000010ceea <klog_add_input_character>:

void klog_add_input_character(Circular_Log *log, const char c){
  10ceea:	55                   	push   rbp
  10ceeb:	48 89 e5             	mov    rbp,rsp
  10ceee:	48 83 ec 10          	sub    rsp,0x10
  10cef2:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  10cef6:	89 f0                	mov    eax,esi
  10cef8:	88 45 f4             	mov    BYTE PTR [rbp-0xc],al
  if(c < ' ' || c > '~') return;
  10cefb:	80 7d f4 1f          	cmp    BYTE PTR [rbp-0xc],0x1f
  10ceff:	0f 8e 8b 00 00 00    	jle    10cf90 <klog_add_input_character+0xa6>
  10cf05:	80 7d f4 7f          	cmp    BYTE PTR [rbp-0xc],0x7f
  10cf09:	0f 84 81 00 00 00    	je     10cf90 <klog_add_input_character+0xa6>
  spinlock_aquire(&log->spinlock);
  10cf0f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cf13:	48 05 20 05 01 00    	add    rax,0x10520
  10cf19:	48 89 c7             	mov    rdi,rax
  10cf1c:	e8 9d c2 ff ff       	call   1091be <spinlock_aquire>
  if(log->input_buffer_count > sizeof(log->input_buffer)) {
  10cf21:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cf25:	48 8b 80 18 05 01 00 	mov    rax,QWORD PTR [rax+0x10518]
  10cf2c:	48 3d 00 01 00 00    	cmp    rax,0x100
  10cf32:	76 14                	jbe    10cf48 <klog_add_input_character+0x5e>
    spinlock_release(&log->spinlock);
  10cf34:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cf38:	48 05 20 05 01 00    	add    rax,0x10520
  10cf3e:	48 89 c7             	mov    rdi,rax
  10cf41:	e8 a7 c2 ff ff       	call   1091ed <spinlock_release>
    return;
  10cf46:	eb 49                	jmp    10cf91 <klog_add_input_character+0xa7>
  }
  log->input_buffer[log->input_buffer_count++] = c;
  10cf48:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cf4c:	48 8b 80 18 05 01 00 	mov    rax,QWORD PTR [rax+0x10518]
  10cf53:	48 8d 48 01          	lea    rcx,[rax+0x1]
  10cf57:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10cf5b:	48 89 8a 18 05 01 00 	mov    QWORD PTR [rdx+0x10518],rcx
  10cf62:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10cf66:	0f b6 4d f4          	movzx  ecx,BYTE PTR [rbp-0xc]
  10cf6a:	88 8c 02 18 04 01 00 	mov    BYTE PTR [rdx+rax*1+0x10418],cl
  log->is_dirty = true;
  10cf71:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cf75:	c6 80 24 05 01 00 01 	mov    BYTE PTR [rax+0x10524],0x1
  spinlock_release(&log->spinlock);
  10cf7c:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cf80:	48 05 20 05 01 00    	add    rax,0x10520
  10cf86:	48 89 c7             	mov    rdi,rax
  10cf89:	e8 5f c2 ff ff       	call   1091ed <spinlock_release>
  10cf8e:	eb 01                	jmp    10cf91 <klog_add_input_character+0xa7>
  if(c < ' ' || c > '~') return;
  10cf90:	90                   	nop
}
  10cf91:	c9                   	leave  
  10cf92:	c3                   	ret    

000000000010cf93 <klog_remove_last_input_character>:

void klog_remove_last_input_character(Circular_Log *log){
  10cf93:	55                   	push   rbp
  10cf94:	48 89 e5             	mov    rbp,rsp
  10cf97:	48 83 ec 08          	sub    rsp,0x8
  10cf9b:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  spinlock_aquire(&log->spinlock);
  10cf9f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cfa3:	48 05 20 05 01 00    	add    rax,0x10520
  10cfa9:	48 89 c7             	mov    rdi,rax
  10cfac:	e8 0d c2 ff ff       	call   1091be <spinlock_aquire>
  if(log->input_buffer_count > 0) {
  10cfb1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cfb5:	48 8b 80 18 05 01 00 	mov    rax,QWORD PTR [rax+0x10518]
  10cfbc:	48 85 c0             	test   rax,rax
  10cfbf:	74 31                	je     10cff2 <klog_remove_last_input_character+0x5f>
    log->input_buffer[log->input_buffer_count] = 0;
  10cfc1:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cfc5:	48 8b 80 18 05 01 00 	mov    rax,QWORD PTR [rax+0x10518]
  10cfcc:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10cfd0:	c6 84 02 18 04 01 00 	mov    BYTE PTR [rdx+rax*1+0x10418],0x0
  10cfd7:	00 
    log->input_buffer_count -= 1;
  10cfd8:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cfdc:	48 8b 80 18 05 01 00 	mov    rax,QWORD PTR [rax+0x10518]
  10cfe3:	48 8d 50 ff          	lea    rdx,[rax-0x1]
  10cfe7:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cfeb:	48 89 90 18 05 01 00 	mov    QWORD PTR [rax+0x10518],rdx
  }
  log->is_dirty = true;
  10cff2:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10cff6:	c6 80 24 05 01 00 01 	mov    BYTE PTR [rax+0x10524],0x1
  spinlock_release(&log->spinlock);
  10cffd:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d001:	48 05 20 05 01 00    	add    rax,0x10520
  10d007:	48 89 c7             	mov    rdi,rax
  10d00a:	e8 de c1 ff ff       	call   1091ed <spinlock_release>
}
  10d00f:	90                   	nop
  10d010:	c9                   	leave  
  10d011:	c3                   	ret    

000000000010d012 <klog_submit_input_to_shell>:

void klog_submit_input_to_shell(Circular_Log *log){
  10d012:	55                   	push   rbp
  10d013:	48 89 e5             	mov    rbp,rsp
  10d016:	48 83 ec 10          	sub    rsp,0x10
  10d01a:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  if(log->input_buffer_count > 0){
  10d01e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d022:	48 8b 80 18 05 01 00 	mov    rax,QWORD PTR [rax+0x10518]
  10d029:	48 85 c0             	test   rax,rax
  10d02c:	74 3b                	je     10d069 <klog_submit_input_to_shell+0x57>
    kshell_process_command(log->input_buffer, log->input_buffer_count);
  10d02e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d032:	48 8b 80 18 05 01 00 	mov    rax,QWORD PTR [rax+0x10518]
  10d039:	48 8b 55 f8          	mov    rdx,QWORD PTR [rbp-0x8]
  10d03d:	48 81 c2 18 04 01 00 	add    rdx,0x10418
  10d044:	48 89 c6             	mov    rsi,rax
  10d047:	48 89 d7             	mov    rdi,rdx
  10d04a:	e8 d8 01 00 00       	call   10d227 <kshell_process_command>
    log->input_buffer_count = 0;
  10d04f:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d053:	48 c7 80 18 05 01 00 	mov    QWORD PTR [rax+0x10518],0x0
  10d05a:	00 00 00 00 
    log->is_dirty = true;
  10d05e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d062:	c6 80 24 05 01 00 01 	mov    BYTE PTR [rax+0x10524],0x1
  } 
}
  10d069:	90                   	nop
  10d06a:	c9                   	leave  
  10d06b:	c3                   	ret    

000000000010d06c <klog_disable>:

	

void klog_disable(){
  10d06c:	55                   	push   rbp
  10d06d:	48 89 e5             	mov    rbp,rsp
  globals.is_logging_disabled = true;
  10d070:	c6 05 e9 16 01 00 01 	mov    BYTE PTR [rip+0x116e9],0x1        # 11e760 <globals+0x10760>
}
  10d077:	90                   	nop
  10d078:	5d                   	pop    rbp
  10d079:	c3                   	ret    

000000000010d07a <klog_enable>:

void klog_enable(){
  10d07a:	55                   	push   rbp
  10d07b:	48 89 e5             	mov    rbp,rsp
  globals.is_logging_disabled = false;
  10d07e:	c6 05 db 16 01 00 00 	mov    BYTE PTR [rip+0x116db],0x0        # 11e760 <globals+0x10760>
  10d085:	90                   	nop
  10d086:	5d                   	pop    rbp
  10d087:	c3                   	ret    

000000000010d088 <kshell_help>:
KShell_Command_Metalist
#undef _
};

static void
kshell_help(const char *input, size_t length){
  10d088:	55                   	push   rbp
  10d089:	48 89 e5             	mov    rbp,rsp
  10d08c:	48 83 ec 10          	sub    rsp,0x10
  10d090:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  10d094:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
  klog_info("kshell command list:");
  10d098:	be 08 82 10 00       	mov    esi,0x108208
  10d09d:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d0a2:	b8 00 00 00 00       	mov    eax,0x0
  10d0a7:	e8 4b fc ff ff       	call   10ccf7 <klog_write_fmt>
  #define _(name, proc) \
  klog_info("  %s", #name);
  KShell_Command_Metalist
  10d0ac:	ba a4 81 10 00       	mov    edx,0x1081a4
  10d0b1:	be 1d 82 10 00       	mov    esi,0x10821d
  10d0b6:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d0bb:	b8 00 00 00 00       	mov    eax,0x0
  10d0c0:	e8 32 fc ff ff       	call   10ccf7 <klog_write_fmt>
  10d0c5:	ba a9 81 10 00       	mov    edx,0x1081a9
  10d0ca:	be 1d 82 10 00       	mov    esi,0x10821d
  10d0cf:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d0d4:	b8 00 00 00 00       	mov    eax,0x0
  10d0d9:	e8 19 fc ff ff       	call   10ccf7 <klog_write_fmt>
  10d0de:	ba b7 81 10 00       	mov    edx,0x1081b7
  10d0e3:	be 1d 82 10 00       	mov    esi,0x10821d
  10d0e8:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d0ed:	b8 00 00 00 00       	mov    eax,0x0
  10d0f2:	e8 00 fc ff ff       	call   10ccf7 <klog_write_fmt>
  10d0f7:	ba bc 81 10 00       	mov    edx,0x1081bc
  10d0fc:	be 1d 82 10 00       	mov    esi,0x10821d
  10d101:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d106:	b8 00 00 00 00       	mov    eax,0x0
  10d10b:	e8 e7 fb ff ff       	call   10ccf7 <klog_write_fmt>
  10d110:	ba cb 81 10 00       	mov    edx,0x1081cb
  10d115:	be 1d 82 10 00       	mov    esi,0x10821d
  10d11a:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d11f:	b8 00 00 00 00       	mov    eax,0x0
  10d124:	e8 ce fb ff ff       	call   10ccf7 <klog_write_fmt>
  #undef _
}
  10d129:	90                   	nop
  10d12a:	c9                   	leave  
  10d12b:	c3                   	ret    

000000000010d12c <kshell_run_test>:

static void
kshell_run_test(const char *text, size_t length){
  10d12c:	55                   	push   rbp
  10d12d:	48 89 e5             	mov    rbp,rsp
  10d130:	48 83 ec 30          	sub    rsp,0x30
  10d134:	48 89 7d d8          	mov    QWORD PTR [rbp-0x28],rdi
  10d138:	48 89 75 d0          	mov    QWORD PTR [rbp-0x30],rsi
  uintptr_t executable_virtual_address = 0x00400000;
  10d13c:	48 c7 45 f8 00 00 40 	mov    QWORD PTR [rbp-0x8],0x400000
  10d143:	00 
  uintptr_t executable_virtual_stack = 0x00600000;
  10d144:	48 c7 45 f0 00 00 60 	mov    QWORD PTR [rbp-0x10],0x600000
  10d14b:	00 
  kmem_map_physical_to_virtual_2MB_ext(0x00A00000, executable_virtual_address, PAGE_USER_ACCESS_BIT);
  10d14c:	ba 04 00 00 00       	mov    edx,0x4
  10d151:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d155:	48 89 c6             	mov    rsi,rax
  10d158:	bf 00 00 a0 00       	mov    edi,0xa00000
  10d15d:	e8 ab d7 ff ff       	call   10a90d <kmem_map_physical_to_virtual_2MB_ext>
  kmem_map_physical_to_virtual_2MB_ext(0x00C00000, executable_virtual_stack, PAGE_USER_ACCESS_BIT);
  10d162:	ba 04 00 00 00       	mov    edx,0x4
  10d167:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10d16b:	48 89 c6             	mov    rsi,rax
  10d16e:	bf 00 00 c0 00       	mov    edi,0xc00000
  10d173:	e8 95 d7 ff ff       	call   10a90d <kmem_map_physical_to_virtual_2MB_ext>
  memcpy(executable_virtual_address, TEST_PROGRAM_ELF, sizeof(TEST_PROGRAM_ELF));
  10d178:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d17c:	ba 88 05 00 00       	mov    edx,0x588
  10d181:	be e0 65 10 00       	mov    esi,0x1065e0
  10d186:	48 89 c7             	mov    rdi,rax
  10d189:	e8 b4 be ff ff       	call   109042 <__memcpy>
  uintptr_t start_address = kprocess_load_elf_executable(executable_virtual_address);
  10d18e:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d192:	48 89 c7             	mov    rdi,rax
  10d195:	e8 ac e5 ff ff       	call   10b746 <kprocess_load_elf_executable>
  10d19a:	48 98                	cdqe   
  10d19c:	48 89 45 e8          	mov    QWORD PTR [rbp-0x18],rax
  uintptr_t stack_address = executable_virtual_stack + 0x1FFFFF;
  10d1a0:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
  10d1a4:	48 05 ff ff 1f 00    	add    rax,0x1fffff
  10d1aa:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax
  asm_enter_usermode((uintptr_t)start_address, stack_address);
  10d1ae:	48 8b 55 e0          	mov    rdx,QWORD PTR [rbp-0x20]
  10d1b2:	48 8b 45 e8          	mov    rax,QWORD PTR [rbp-0x18]
  10d1b6:	48 89 d6             	mov    rsi,rdx
  10d1b9:	48 89 c7             	mov    rdi,rax
  10d1bc:	e8 42 03 00 00       	call   10d503 <asm_enter_usermode>
}
  10d1c1:	90                   	nop
  10d1c2:	c9                   	leave  
  10d1c3:	c3                   	ret    

000000000010d1c4 <kshell_ioapic_irq_map>:

static void
kshell_ioapic_irq_map(const char *text, size_t length){
  10d1c4:	55                   	push   rbp
  10d1c5:	48 89 e5             	mov    rbp,rsp
  10d1c8:	48 83 ec 10          	sub    rsp,0x10
  10d1cc:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  10d1d0:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
  kdebug_ioapic_log_irq_map(globals.system_info.ioapic_virtual_address);
  10d1d4:	48 8b 05 cd 14 01 00 	mov    rax,QWORD PTR [rip+0x114cd]        # 11e6a8 <globals+0x106a8>
  10d1db:	48 89 c7             	mov    rdi,rax
  10d1de:	e8 a8 e6 ff ff       	call   10b88b <kdebug_ioapic_log_irq_map>
}
  10d1e3:	90                   	nop
  10d1e4:	c9                   	leave  
  10d1e5:	c3                   	ret    

000000000010d1e6 <kshell_hardware_info>:

static void
kshell_hardware_info(const char *text, size_t length) {
  10d1e6:	55                   	push   rbp
  10d1e7:	48 89 e5             	mov    rbp,rsp
  10d1ea:	48 83 ec 10          	sub    rsp,0x10
  10d1ee:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  10d1f2:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi

}
  10d1f6:	90                   	nop
  10d1f7:	c9                   	leave  
  10d1f8:	c3                   	ret    

000000000010d1f9 <kshell_unimplemented_command>:

static void
kshell_unimplemented_command(const char *text, size_t length){
  10d1f9:	55                   	push   rbp
  10d1fa:	48 89 e5             	mov    rbp,rsp
  10d1fd:	48 83 ec 10          	sub    rsp,0x10
  10d201:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  10d205:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
  klog_error("%s is an unimplemented command!", text);
  10d209:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d20d:	48 89 c2             	mov    rdx,rax
  10d210:	be 28 82 10 00       	mov    esi,0x108228
  10d215:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d21a:	b8 00 00 00 00       	mov    eax,0x0
  10d21f:	e8 d3 fa ff ff       	call   10ccf7 <klog_write_fmt>
}
  10d224:	90                   	nop
  10d225:	c9                   	leave  
  10d226:	c3                   	ret    

000000000010d227 <kshell_process_command>:

void kshell_process_command(const char *input, size_t length){
  10d227:	55                   	push   rbp
  10d228:	48 89 e5             	mov    rbp,rsp
  10d22b:	48 83 ec 10          	sub    rsp,0x10
  10d22f:	48 89 7d f8          	mov    QWORD PTR [rbp-0x8],rdi
  10d233:	48 89 75 f0          	mov    QWORD PTR [rbp-0x10],rsi
  #define _(name, proc) \
  if(string_matches_string(#name, sizeof(#name)-1, input)){\
    proc(input, length);\
    return;\
  }
  KShell_Command_Metalist
  10d237:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d23b:	48 89 c2             	mov    rdx,rax
  10d23e:	be 04 00 00 00       	mov    esi,0x4
  10d243:	bf a4 81 10 00       	mov    edi,0x1081a4
  10d248:	e8 e3 be ff ff       	call   109130 <string_matches_string>
  10d24d:	85 c0                	test   eax,eax
  10d24f:	74 18                	je     10d269 <kshell_process_command+0x42>
  10d251:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  10d255:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d259:	48 89 d6             	mov    rsi,rdx
  10d25c:	48 89 c7             	mov    rdi,rax
  10d25f:	e8 24 fe ff ff       	call   10d088 <kshell_help>
  10d264:	e9 da 00 00 00       	jmp    10d343 <kshell_process_command+0x11c>
  10d269:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d26d:	48 89 c2             	mov    rdx,rax
  10d270:	be 0d 00 00 00       	mov    esi,0xd
  10d275:	bf a9 81 10 00       	mov    edi,0x1081a9
  10d27a:	e8 b1 be ff ff       	call   109130 <string_matches_string>
  10d27f:	85 c0                	test   eax,eax
  10d281:	74 18                	je     10d29b <kshell_process_command+0x74>
  10d283:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  10d287:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d28b:	48 89 d6             	mov    rsi,rdx
  10d28e:	48 89 c7             	mov    rdi,rax
  10d291:	e8 50 ff ff ff       	call   10d1e6 <kshell_hardware_info>
  10d296:	e9 a8 00 00 00       	jmp    10d343 <kshell_process_command+0x11c>
  10d29b:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d29f:	48 89 c2             	mov    rdx,rax
  10d2a2:	be 04 00 00 00       	mov    esi,0x4
  10d2a7:	bf b7 81 10 00       	mov    edi,0x1081b7
  10d2ac:	e8 7f be ff ff       	call   109130 <string_matches_string>
  10d2b1:	85 c0                	test   eax,eax
  10d2b3:	74 15                	je     10d2ca <kshell_process_command+0xa3>
  10d2b5:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  10d2b9:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d2bd:	48 89 d6             	mov    rsi,rdx
  10d2c0:	48 89 c7             	mov    rdi,rax
  10d2c3:	e8 31 ff ff ff       	call   10d1f9 <kshell_unimplemented_command>
  10d2c8:	eb 79                	jmp    10d343 <kshell_process_command+0x11c>
  10d2ca:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d2ce:	48 89 c2             	mov    rdx,rax
  10d2d1:	be 0e 00 00 00       	mov    esi,0xe
  10d2d6:	bf bc 81 10 00       	mov    edi,0x1081bc
  10d2db:	e8 50 be ff ff       	call   109130 <string_matches_string>
  10d2e0:	85 c0                	test   eax,eax
  10d2e2:	74 15                	je     10d2f9 <kshell_process_command+0xd2>
  10d2e4:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  10d2e8:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d2ec:	48 89 d6             	mov    rsi,rdx
  10d2ef:	48 89 c7             	mov    rdi,rax
  10d2f2:	e8 cd fe ff ff       	call   10d1c4 <kshell_ioapic_irq_map>
  10d2f7:	eb 4a                	jmp    10d343 <kshell_process_command+0x11c>
  10d2f9:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d2fd:	48 89 c2             	mov    rdx,rax
  10d300:	be 08 00 00 00       	mov    esi,0x8
  10d305:	bf cb 81 10 00       	mov    edi,0x1081cb
  10d30a:	e8 21 be ff ff       	call   109130 <string_matches_string>
  10d30f:	85 c0                	test   eax,eax
  10d311:	74 15                	je     10d328 <kshell_process_command+0x101>
  10d313:	48 8b 55 f0          	mov    rdx,QWORD PTR [rbp-0x10]
  10d317:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d31b:	48 89 d6             	mov    rsi,rdx
  10d31e:	48 89 c7             	mov    rdi,rax
  10d321:	e8 06 fe ff ff       	call   10d12c <kshell_run_test>
  10d326:	eb 1b                	jmp    10d343 <kshell_process_command+0x11c>
  #undef _

  klog_error("%s is not a shell command", input);
  10d328:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
  10d32c:	48 89 c2             	mov    rdx,rax
  10d32f:	be 48 82 10 00       	mov    esi,0x108248
  10d334:	bf 00 e0 10 00       	mov    edi,0x10e000
  10d339:	b8 00 00 00 00       	mov    eax,0x0
  10d33e:	e8 b4 f9 ff ff       	call   10ccf7 <klog_write_fmt>
}
  10d343:	c9                   	leave  
  10d344:	c3                   	ret    
  10d345:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10d34c:	00 00 00 
  10d34f:	90                   	nop

000000000010d350 <asm_double_fault_handler>:
  10d350:	fa                   	cli    
  10d351:	c7 04 25 00 80 0b 00 	mov    DWORD PTR ds:0xb8000,0x2064
  10d358:	64 20 00 00 
  10d35c:	c7 04 25 04 80 0b 00 	mov    DWORD PTR ds:0xb8004,0x2066
  10d363:	66 20 00 00 
  10d367:	c7 04 25 08 80 0b 00 	mov    DWORD PTR ds:0xb8008,0x206c
  10d36e:	6c 20 00 00 
  10d372:	f4                   	hlt    
  10d373:	48 cf                	iretq  

000000000010d375 <asm_debug_handler>:
  10d375:	fa                   	cli    
  10d376:	c7 04 25 00 80 0b 00 	mov    DWORD PTR ds:0xb8000,0x61
  10d37d:	61 00 00 00 
  10d381:	c7 04 25 04 80 0b 00 	mov    DWORD PTR ds:0xb8004,0x62
  10d388:	62 00 00 00 
  10d38c:	c7 04 25 08 80 0b 00 	mov    DWORD PTR ds:0xb8008,0x63
  10d393:	63 00 00 00 
  10d397:	f4                   	hlt    
  10d398:	48 cf                	iretq  

000000000010d39a <asm_irq_common_handler>:
  10d39a:	50                   	push   rax
  10d39b:	53                   	push   rbx
  10d39c:	51                   	push   rcx
  10d39d:	e8 61 ee ff ff       	call   10c203 <irq_common_handler>
  10d3a2:	59                   	pop    rcx
  10d3a3:	5b                   	pop    rbx
  10d3a4:	58                   	pop    rax
  10d3a5:	83 c4 08             	add    esp,0x8
  10d3a8:	fb                   	sti    
  10d3a9:	48 cf                	iretq  

000000000010d3ab <asm_isr_common_handler>:
  10d3ab:	50                   	push   rax
  10d3ac:	53                   	push   rbx
  10d3ad:	51                   	push   rcx
  10d3ae:	e8 a6 ed ff ff       	call   10c159 <isr_common_handler>
  10d3b3:	59                   	pop    rcx
  10d3b4:	5b                   	pop    rbx
  10d3b5:	58                   	pop    rax
  10d3b6:	83 c4 10             	add    esp,0x10
  10d3b9:	fb                   	sti    
  10d3ba:	48 cf                	iretq  

000000000010d3bc <asm_syscall_handler>:
  10d3bc:	fa                   	cli    
  10d3bd:	48 8b 04 c5 00 80 10 	mov    rax,QWORD PTR [rax*8+0x108000]
  10d3c4:	00 
  10d3c5:	ff d0                	call   rax
  10d3c7:	fb                   	sti    
  10d3c8:	48 cf                	iretq  

000000000010d3ca <asm_isr0>:
  10d3ca:	fa                   	cli    
  10d3cb:	6a 00                	push   0x0
  10d3cd:	6a 00                	push   0x0
  10d3cf:	eb da                	jmp    10d3ab <asm_isr_common_handler>

000000000010d3d1 <asm_isr1>:
  10d3d1:	fa                   	cli    
  10d3d2:	6a 00                	push   0x0
  10d3d4:	6a 01                	push   0x1
  10d3d6:	eb d3                	jmp    10d3ab <asm_isr_common_handler>

000000000010d3d8 <asm_isr2>:
  10d3d8:	fa                   	cli    
  10d3d9:	6a 00                	push   0x0
  10d3db:	6a 02                	push   0x2
  10d3dd:	eb cc                	jmp    10d3ab <asm_isr_common_handler>

000000000010d3df <asm_isr3>:
  10d3df:	fa                   	cli    
  10d3e0:	6a 00                	push   0x0
  10d3e2:	6a 03                	push   0x3
  10d3e4:	eb c5                	jmp    10d3ab <asm_isr_common_handler>

000000000010d3e6 <asm_isr4>:
  10d3e6:	fa                   	cli    
  10d3e7:	6a 00                	push   0x0
  10d3e9:	6a 04                	push   0x4
  10d3eb:	eb be                	jmp    10d3ab <asm_isr_common_handler>

000000000010d3ed <asm_isr5>:
  10d3ed:	fa                   	cli    
  10d3ee:	6a 00                	push   0x0
  10d3f0:	6a 05                	push   0x5
  10d3f2:	eb b7                	jmp    10d3ab <asm_isr_common_handler>

000000000010d3f4 <asm_isr6>:
  10d3f4:	fa                   	cli    
  10d3f5:	6a 00                	push   0x0
  10d3f7:	6a 06                	push   0x6
  10d3f9:	eb b0                	jmp    10d3ab <asm_isr_common_handler>

000000000010d3fb <asm_isr7>:
  10d3fb:	fa                   	cli    
  10d3fc:	6a 00                	push   0x0
  10d3fe:	6a 07                	push   0x7
  10d400:	eb a9                	jmp    10d3ab <asm_isr_common_handler>

000000000010d402 <asm_isr8>:
  10d402:	fa                   	cli    
  10d403:	6a 08                	push   0x8
  10d405:	eb a4                	jmp    10d3ab <asm_isr_common_handler>

000000000010d407 <asm_isr9>:
  10d407:	fa                   	cli    
  10d408:	6a 00                	push   0x0
  10d40a:	6a 09                	push   0x9
  10d40c:	eb 9d                	jmp    10d3ab <asm_isr_common_handler>

000000000010d40e <asm_isr10>:
  10d40e:	fa                   	cli    
  10d40f:	6a 0a                	push   0xa
  10d411:	eb 98                	jmp    10d3ab <asm_isr_common_handler>

000000000010d413 <asm_isr11>:
  10d413:	fa                   	cli    
  10d414:	6a 0b                	push   0xb
  10d416:	eb 93                	jmp    10d3ab <asm_isr_common_handler>

000000000010d418 <asm_isr12>:
  10d418:	fa                   	cli    
  10d419:	6a 0c                	push   0xc
  10d41b:	eb 8e                	jmp    10d3ab <asm_isr_common_handler>

000000000010d41d <asm_isr13>:
  10d41d:	fa                   	cli    
  10d41e:	6a 0d                	push   0xd
  10d420:	eb 89                	jmp    10d3ab <asm_isr_common_handler>

000000000010d422 <asm_isr14>:
  10d422:	fa                   	cli    
  10d423:	6a 0e                	push   0xe
  10d425:	eb 84                	jmp    10d3ab <asm_isr_common_handler>

000000000010d427 <asm_isr15>:
  10d427:	fa                   	cli    
  10d428:	6a 00                	push   0x0
  10d42a:	6a 0f                	push   0xf
  10d42c:	e9 7a ff ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d431 <asm_isr16>:
  10d431:	fa                   	cli    
  10d432:	6a 00                	push   0x0
  10d434:	6a 10                	push   0x10
  10d436:	e9 70 ff ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d43b <asm_isr17>:
  10d43b:	fa                   	cli    
  10d43c:	6a 11                	push   0x11
  10d43e:	e9 68 ff ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d443 <asm_isr18>:
  10d443:	fa                   	cli    
  10d444:	6a 00                	push   0x0
  10d446:	6a 12                	push   0x12
  10d448:	e9 5e ff ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d44d <asm_isr19>:
  10d44d:	fa                   	cli    
  10d44e:	6a 00                	push   0x0
  10d450:	6a 13                	push   0x13
  10d452:	e9 54 ff ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d457 <asm_isr20>:
  10d457:	fa                   	cli    
  10d458:	6a 00                	push   0x0
  10d45a:	6a 14                	push   0x14
  10d45c:	e9 4a ff ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d461 <asm_isr21>:
  10d461:	fa                   	cli    
  10d462:	6a 00                	push   0x0
  10d464:	6a 15                	push   0x15
  10d466:	e9 40 ff ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d46b <asm_isr22>:
  10d46b:	fa                   	cli    
  10d46c:	6a 00                	push   0x0
  10d46e:	6a 16                	push   0x16
  10d470:	e9 36 ff ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d475 <asm_isr23>:
  10d475:	fa                   	cli    
  10d476:	6a 00                	push   0x0
  10d478:	6a 17                	push   0x17
  10d47a:	e9 2c ff ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d47f <asm_isr24>:
  10d47f:	fa                   	cli    
  10d480:	6a 00                	push   0x0
  10d482:	6a 18                	push   0x18
  10d484:	e9 22 ff ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d489 <asm_isr25>:
  10d489:	fa                   	cli    
  10d48a:	6a 00                	push   0x0
  10d48c:	6a 19                	push   0x19
  10d48e:	e9 18 ff ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d493 <asm_isr26>:
  10d493:	fa                   	cli    
  10d494:	6a 00                	push   0x0
  10d496:	6a 1a                	push   0x1a
  10d498:	e9 0e ff ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d49d <asm_isr27>:
  10d49d:	fa                   	cli    
  10d49e:	6a 00                	push   0x0
  10d4a0:	6a 1b                	push   0x1b
  10d4a2:	e9 04 ff ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d4a7 <asm_isr28>:
  10d4a7:	fa                   	cli    
  10d4a8:	6a 00                	push   0x0
  10d4aa:	6a 1c                	push   0x1c
  10d4ac:	e9 fa fe ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d4b1 <asm_isr29>:
  10d4b1:	fa                   	cli    
  10d4b2:	6a 00                	push   0x0
  10d4b4:	6a 1d                	push   0x1d
  10d4b6:	e9 f0 fe ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d4bb <asm_isr30>:
  10d4bb:	fa                   	cli    
  10d4bc:	6a 00                	push   0x0
  10d4be:	6a 1e                	push   0x1e
  10d4c0:	e9 e6 fe ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d4c5 <asm_isr31>:
  10d4c5:	fa                   	cli    
  10d4c6:	6a 00                	push   0x0
  10d4c8:	6a 1f                	push   0x1f
  10d4ca:	e9 dc fe ff ff       	jmp    10d3ab <asm_isr_common_handler>

000000000010d4cf <asm_irq0>:
  10d4cf:	fa                   	cli    
  10d4d0:	6a 00                	push   0x0
  10d4d2:	e9 c3 fe ff ff       	jmp    10d39a <asm_irq_common_handler>

000000000010d4d7 <asm_irq1>:
  10d4d7:	fa                   	cli    
  10d4d8:	6a 01                	push   0x1
  10d4da:	e9 bb fe ff ff       	jmp    10d39a <asm_irq_common_handler>

000000000010d4df <asm_irq128>:
  10d4df:	fa                   	cli    
  10d4e0:	68 80 00 00 00       	push   0x80
  10d4e5:	e9 b0 fe ff ff       	jmp    10d39a <asm_irq_common_handler>

000000000010d4ea <asm_longmode_entry>:
  10d4ea:	66 b8 08 00          	mov    ax,0x8
  10d4ee:	8e d8                	mov    ds,eax
  10d4f0:	8e c0                	mov    es,eax
  10d4f2:	8e e0                	mov    fs,eax
  10d4f4:	8e e8                	mov    gs,eax
  10d4f6:	66 b8 00 00          	mov    ax,0x0
  10d4fa:	8e d0                	mov    ss,eax
  10d4fc:	5f                   	pop    rdi
  10d4fd:	5e                   	pop    rsi
  10d4fe:	e8 b0 e7 ff ff       	call   10bcb3 <kernel_longmode_entry>

000000000010d503 <asm_enter_usermode>:
  10d503:	fa                   	cli    
  10d504:	66 b8 13 00          	mov    ax,0x13
  10d508:	8e d8                	mov    ds,eax
  10d50a:	8e c0                	mov    es,eax
  10d50c:	8e e0                	mov    fs,eax
  10d50e:	8e e8                	mov    gs,eax
  10d510:	6a 13                	push   0x13
  10d512:	56                   	push   rsi
  10d513:	9c                   	pushf  
  10d514:	6a 23                	push   0x23
  10d516:	57                   	push   rdi
  10d517:	48 cf                	iretq  
  10d519:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000010d520 <start>:
  10d520:	fa                   	cli    
  10d521:	bc 02 70 12 00       	mov    esp,0x127002
  10d526:	3d 89 62 d7 36       	cmp    eax,0x36d76289
  10d52b:	75 02                	jne    10d52f <start.no_multiboot>
  10d52d:	eb 07                	jmp    10d536 <start.valid_multiboot>

000000000010d52f <start.no_multiboot>:
  10d52f:	b0 30                	mov    al,0x30
  10d531:	e9 cf 00 00 00       	jmp    10d605 <error_handler>

000000000010d536 <start.valid_multiboot>:
  10d536:	6a 00                	push   0x0
  10d538:	53                   	push   rbx
  10d539:	6a 00                	push   0x0
  10d53b:	50                   	push   rax
  10d53c:	e8 8a 00 00 00       	call   10d5cb <is_cpuid_supported>
  10d541:	e8 9d 00 00 00       	call   10d5e3 <is_longmode_supported>
  10d546:	e8 2b 00 00 00       	call   10d576 <setup_paging_tables>
  10d54b:	e8 50 00 00 00       	call   10d5a0 <enable_paging>
  10d550:	0f 20 c0             	mov    rax,cr0
  10d553:	66 83 e0 fb          	and    ax,0xfffb
  10d557:	66 83 c8 02          	or     ax,0x2
  10d55b:	0f 22 c0             	mov    cr0,rax
  10d55e:	0f 20 e0             	mov    rax,cr4
  10d561:	66 0d 00 06          	or     ax,0x600
  10d565:	0f 22 e0             	mov    cr4,rax
  10d568:	0f 01 15 38 8d 10 00 	lgdt   [rip+0x108d38]        # 2162a7 <stack_top+0xef2a5>
  10d56f:	ea                   	(bad)  
  10d570:	ea                   	(bad)  
  10d571:	d4                   	(bad)  
  10d572:	10 00                	adc    BYTE PTR [rax],al
  10d574:	18 00                	sbb    BYTE PTR [rax],al

000000000010d576 <setup_paging_tables>:
  10d576:	b8 00 30 12 00       	mov    eax,0x123000
  10d57b:	83 c8 07             	or     eax,0x7
  10d57e:	a3 00 20 12 00 b8 00 	movabs ds:0x124000b800122000,eax
  10d585:	40 12 
  10d587:	00 83 c8 07 a3 00    	add    BYTE PTR [rbx+0xa307c8],al
  10d58d:	30 12                	xor    BYTE PTR [rdx],dl
  10d58f:	00 b8 00 00 00 00    	add    BYTE PTR [rax+0x0],bh
  10d595:	0d 83 00 00 00       	or     eax,0x83
  10d59a:	a3                   	.byte 0xa3
  10d59b:	00 40 12             	add    BYTE PTR [rax+0x12],al
  10d59e:	00 c3                	add    bl,al

000000000010d5a0 <enable_paging>:
  10d5a0:	b8 00 20 12 00       	mov    eax,0x122000
  10d5a5:	0f 22 d8             	mov    cr3,rax
  10d5a8:	0f 20 e0             	mov    rax,cr4
  10d5ab:	83 c8 20             	or     eax,0x20
  10d5ae:	0f 22 e0             	mov    cr4,rax
  10d5b1:	b9 80 00 00 c0       	mov    ecx,0xc0000080
  10d5b6:	0f 32                	rdmsr  
  10d5b8:	0d 00 01 00 00       	or     eax,0x100
  10d5bd:	0f 30                	wrmsr  
  10d5bf:	0f 20 c0             	mov    rax,cr0
  10d5c2:	0d 00 00 00 80       	or     eax,0x80000000
  10d5c7:	0f 22 c0             	mov    cr0,rax
  10d5ca:	c3                   	ret    

000000000010d5cb <is_cpuid_supported>:
  10d5cb:	9c                   	pushf  
  10d5cc:	58                   	pop    rax
  10d5cd:	89 c1                	mov    ecx,eax
  10d5cf:	35 00 00 20 00       	xor    eax,0x200000
  10d5d4:	50                   	push   rax
  10d5d5:	9d                   	popf   
  10d5d6:	9c                   	pushf  
  10d5d7:	58                   	pop    rax
  10d5d8:	51                   	push   rcx
  10d5d9:	9d                   	popf   
  10d5da:	31 c8                	xor    eax,ecx
  10d5dc:	74 01                	je     10d5df <is_cpuid_supported.no_cpuid>
  10d5de:	c3                   	ret    

000000000010d5df <is_cpuid_supported.no_cpuid>:
  10d5df:	b0 37                	mov    al,0x37
  10d5e1:	eb 22                	jmp    10d605 <error_handler>

000000000010d5e3 <is_longmode_supported>:
  10d5e3:	b8 00 00 00 80       	mov    eax,0x80000000
  10d5e8:	0f a2                	cpuid  
  10d5ea:	3d 01 00 00 80       	cmp    eax,0x80000001
  10d5ef:	72 10                	jb     10d601 <is_longmode_supported.no_longmode>
  10d5f1:	b8 01 00 00 80       	mov    eax,0x80000001
  10d5f6:	0f a2                	cpuid  
  10d5f8:	f7 c2 00 00 00 20    	test   edx,0x20000000
  10d5fe:	74 01                	je     10d601 <is_longmode_supported.no_longmode>
  10d600:	c3                   	ret    

000000000010d601 <is_longmode_supported.no_longmode>:
  10d601:	b0 32                	mov    al,0x32
  10d603:	eb 00                	jmp    10d605 <error_handler>

000000000010d605 <error_handler>:
  10d605:	c7 05 00 80 0b 00 45 	mov    DWORD PTR [rip+0xb8000],0x4f524f45        # 1c560f <stack_top+0x9e60d>
  10d60c:	4f 52 4f 
  10d60f:	c7 05 04 80 0b 00 52 	mov    DWORD PTR [rip+0xb8004],0x4f3a4f52        # 1c561d <stack_top+0x9e61b>
  10d616:	4f 3a 4f 
  10d619:	c7 05 08 80 0b 00 20 	mov    DWORD PTR [rip+0xb8008],0x4f204f20        # 1c562b <stack_top+0x9e629>
  10d620:	4f 20 4f 
  10d623:	a2                   	.byte 0xa2
  10d624:	0a                   	.byte 0xa
  10d625:	80 0b 00             	or     BYTE PTR [rbx],0x0
  10d628:	f4                   	hlt    
