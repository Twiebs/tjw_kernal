
bin/kernel:     file format elf64-x86-64

Decoded dump of debug contents of section .debug_line:

CU: src/interrupt_handler.c:
File name                            Line number    Starting address
interrupt_handler.c                           40            0x109000

interrupt_handler.c                           46            0x109000
interrupt_handler.c                           48            0x109007
interrupt_handler.c                           50            0x109010
interrupt_handler.c                           51            0x109010

src/utility.h:
utility.h                                     20            0x109040

utility.h                                     21            0x109040
utility.h                                     22            0x109050
utility.h                                     21            0x109057
utility.h                                     26            0x109060
utility.h                                     27            0x109060
utility.h                                     28            0x109070
utility.h                                     27            0x109077
utility.h                                     65            0x109090
utility.h                                     66            0x109090
utility.h                                     72            0x10909f

src/kernel_graphics.c:
kernel_graphics.c                             25            0x1090a0
kernel_graphics.c                             26            0x1090a0
kernel_graphics.c                             25            0x1090a4
kernel_graphics.c                             26            0x1090a9
kernel_graphics.c                             25            0x1090c8
kernel_graphics.c                             30            0x1090d0
kernel_graphics.c                             31            0x1090d7
kernel_graphics.c                             32            0x1090ec
kernel_graphics.c                             33            0x1090f5
kernel_graphics.c                             34            0x109103
kernel_graphics.c                             28            0x109111
kernel_graphics.c                             27            0x10911e
kernel_graphics.c                             38            0x109123
kernel_graphics.c                             41            0x109130
kernel_graphics.c                             42            0x109130
kernel_graphics.c                             43            0x10913a

/usr/lib/gcc/x86_64-pc-linux-gnu/6.2.1/include/emmintrin.h:
emmintrin.h                                  710            0x10913e

src/kernel_graphics.c:
kernel_graphics.c                             42            0x109142
kernel_graphics.c                             45            0x109145
kernel_graphics.c                             42            0x109147
kernel_graphics.c                             45            0x10914a
kernel_graphics.c                             42            0x10914c
kernel_graphics.c                             45            0x10914e

/usr/lib/gcc/x86_64-pc-linux-gnu/6.2.1/include/emmintrin.h:
emmintrin.h                                  710            0x109158

src/kernel_graphics.c:
kernel_graphics.c                             45            0x10915c
kernel_graphics.c                            170            0x109170
kernel_graphics.c                            171            0x109170
kernel_graphics.c                            174            0x10917d
kernel_graphics.c                            172            0x109185
kernel_graphics.c                            174            0x10918c
kernel_graphics.c                            170            0x109192
kernel_graphics.c                            180            0x109196
kernel_graphics.c                            170            0x10919b
kernel_graphics.c                            180            0x10919f
kernel_graphics.c                            170            0x1091a1
kernel_graphics.c                            180            0x1091aa
kernel_graphics.c                            181            0x1091b0
kernel_graphics.c                            182            0x1091b9
kernel_graphics.c                            181            0x1091bd
kernel_graphics.c                            182            0x1091c1
kernel_graphics.c                            180            0x1091c8
kernel_graphics.c                            182            0x1091ce
kernel_graphics.c                            183            0x1091d5
kernel_graphics.c                            185            0x1091e0
kernel_graphics.c                            187            0x1091f4
kernel_graphics.c                            188            0x109213
kernel_graphics.c                            187            0x109215
kernel_graphics.c                            188            0x109218
kernel_graphics.c                            189            0x109220
kernel_graphics.c                            188            0x109231
kernel_graphics.c                            189            0x109235
kernel_graphics.c                            188            0x10923d
kernel_graphics.c                            183            0x109246
kernel_graphics.c                            193            0x10924c
kernel_graphics.c                            194            0x10925e
kernel_graphics.c                            195            0x109280
kernel_graphics.c                            194            0x10929d
kernel_graphics.c                            201            0x1092a2

src/utility.h:
utility.h                                     22            0x1092b4
utility.h                                     21            0x1092bb

src/kernel_graphics.c:
kernel_graphics.c                             95            0x1092c7
kernel_graphics.c                            100            0x1092d3
kernel_graphics.c                             95            0x1092d9
kernel_graphics.c                             96            0x1092df
kernel_graphics.c                             95            0x1092e4
kernel_graphics.c                             96            0x1092e7
kernel_graphics.c                             98            0x1092e9
kernel_graphics.c                            100            0x1092fd
kernel_graphics.c                            101            0x10931c
kernel_graphics.c                            100            0x10931e
kernel_graphics.c                            101            0x109321
kernel_graphics.c                             84            0x109330
kernel_graphics.c                             85            0x109334
kernel_graphics.c                             84            0x10933c
kernel_graphics.c                            101            0x109343
kernel_graphics.c                             96            0x109350
kernel_graphics.c                            106            0x109356
kernel_graphics.c                            107            0x10936b
kernel_graphics.c                             84            0x109372
kernel_graphics.c                             85            0x10937a
kernel_graphics.c                             84            0x109382
kernel_graphics.c                            107            0x109389

src/usb_ehci.c:
usb_ehci.c                                    69            0x1093a0

src/hardware_serial.c:
hardware_serial.c                             18            0x1093b0

src/kernel.h:
kernel.h                                      29            0x1093b0


src/hardware_serial.c:
hardware_serial.c                             28            0x109400

src/kernel.h:
kernel.h                                      41            0x109400


src/hardware_serial.c:
hardware_serial.c                             29            0x109406
hardware_serial.c                             30            0x10940c
hardware_serial.c                             39            0x109410
hardware_serial.c                             40            0x109410

src/kernel.h:
kernel.h                                      41            0x109418
kernel.h                                      29            0x10941d
kernel.h                                      41            0x109428

src/hardware_serial.c:
hardware_serial.c                             41            0x10942b

src/kernel.h:
kernel.h                                      29            0x10942f

src/hardware_serial.c:
hardware_serial.c                             40            0x10943a

src/kernel_memory.c:
kernel_memory.c                               68            0x109450
kernel_memory.c                               69            0x109450

src/kernel_entry.c:
kernel_entry.c                               216            0x109470
kernel_entry.c                               217            0x109470

src/elf64.h:
elf64.h                                      304            0x109480
elf64.h                                      305            0x109480
elf64.h                                      305            0x109489
elf64.h                                      305            0x109492
elf64.h                                      305            0x10949b
elf64.h                                      305            0x1094a4
elf64.h                                      305            0x1094ad
elf64.h                                      305            0x1094b6
elf64.h                                      305            0x1094bf
elf64.h                                      305            0x1094c8
elf64.h                                      305            0x1094d1
elf64.h                                      305            0x1094da
elf64.h                                      305            0x1094e3
elf64.h                                      305            0x1094ec
elf64.h                                      305            0x1094f5
elf64.h                                      305            0x1094fe
elf64.h                                      305            0x109507
elf64.h                                      305            0x109510
elf64.h                                      305            0x109519
elf64.h                                      305            0x109522
elf64.h                                      305            0x10952b
elf64.h                                      305            0x109534
elf64.h                                      305            0x10953d
elf64.h                                      305            0x109546
elf64.h                                      305            0x10954f
elf64.h                                      305            0x109558
elf64.h                                      305            0x109561
elf64.h                                      305            0x10956a
elf64.h                                      305            0x109573
elf64.h                                      305            0x10957c
elf64.h                                      305            0x109585
elf64.h                                      305            0x10958e
elf64.h                                      305            0x109597
elf64.h                                      305            0x1095a0
elf64.h                                      305            0x1095a9
elf64.h                                      305            0x1095b2
elf64.h                                      305            0x1095bb
elf64.h                                      305            0x1095c4
elf64.h                                      305            0x1095cd
elf64.h                                      305            0x1095d6
elf64.h                                      305            0x1095df
elf64.h                                      305            0x1095e8
elf64.h                                      305            0x1095f1
elf64.h                                      305            0x1095fa
elf64.h                                      305            0x109603
elf64.h                                      305            0x10960c
elf64.h                                      305            0x109615
elf64.h                                      305            0x10961e
elf64.h                                      305            0x109627
elf64.h                                      305            0x109630
elf64.h                                      305            0x109639
elf64.h                                      305            0x109642
elf64.h                                      305            0x10964b
elf64.h                                      305            0x109654
elf64.h                                      305            0x10965d
elf64.h                                      305            0x109666
elf64.h                                      305            0x10966f
elf64.h                                      305            0x109678
elf64.h                                      305            0x109681
elf64.h                                      305            0x10968a
elf64.h                                      305            0x109693
elf64.h                                      305            0x10969c
elf64.h                                      306            0x1096a8
elf64.h                                      305            0x1096c0
elf64.h                                      307            0x10982b
elf64.h                                      305            0x10982c
elf64.h                                      309            0x1098b0
elf64.h                                      310            0x1098b0
elf64.h                                      310            0x1098b9
elf64.h                                      310            0x1098c2
elf64.h                                      310            0x1098cb
elf64.h                                      310            0x1098d4
elf64.h                                      310            0x1098dd
elf64.h                                      310            0x1098e6
elf64.h                                      310            0x1098ef
elf64.h                                      310            0x1098f8
elf64.h                                      310            0x109901
elf64.h                                      310            0x10990a
elf64.h                                      310            0x109913
elf64.h                                      310            0x10991c
elf64.h                                      310            0x109925
elf64.h                                      310            0x10992e
elf64.h                                      310            0x109937
elf64.h                                      310            0x109940
elf64.h                                      310            0x109949
elf64.h                                      310            0x109952
elf64.h                                      310            0x10995b
elf64.h                                      310            0x109964
elf64.h                                      310            0x10996d
elf64.h                                      310            0x109976
elf64.h                                      310            0x10997f
elf64.h                                      310            0x109988
elf64.h                                      310            0x109991
elf64.h                                      310            0x10999a
elf64.h                                      310            0x1099a3
elf64.h                                      310            0x1099ac
elf64.h                                      310            0x1099b5
elf64.h                                      310            0x1099be
elf64.h                                      310            0x1099c7
elf64.h                                      310            0x1099d0
elf64.h                                      310            0x1099d9
elf64.h                                      310            0x1099e2
elf64.h                                      310            0x1099eb
elf64.h                                      310            0x1099f4
elf64.h                                      310            0x1099fd
elf64.h                                      310            0x109a06
elf64.h                                      310            0x109a0f
elf64.h                                      310            0x109a18
elf64.h                                      310            0x109a21
elf64.h                                      310            0x109a2a
elf64.h                                      310            0x109a33
elf64.h                                      310            0x109a3c
elf64.h                                      310            0x109a45
elf64.h                                      310            0x109a4e
elf64.h                                      310            0x109a57
elf64.h                                      310            0x109a60
elf64.h                                      310            0x109a69
elf64.h                                      310            0x109a72
elf64.h                                      310            0x109a7b
elf64.h                                      310            0x109a84
elf64.h                                      310            0x109a8d
elf64.h                                      310            0x109a96
elf64.h                                      310            0x109a9f
elf64.h                                      310            0x109aa8
elf64.h                                      310            0x109ab1
elf64.h                                      310            0x109aba
elf64.h                                      310            0x109ac3
elf64.h                                      310            0x109acc
elf64.h                                      310            0x109ad5
elf64.h                                      310            0x109ade
elf64.h                                      310            0x109ae7
elf64.h                                      310            0x109af0
elf64.h                                      310            0x109af9
elf64.h                                      310            0x109b02
elf64.h                                      310            0x109b0b
elf64.h                                      310            0x109b14
elf64.h                                      310            0x109b1d
elf64.h                                      310            0x109b26
elf64.h                                      310            0x109b2f
elf64.h                                      310            0x109b38
elf64.h                                      310            0x109b41
elf64.h                                      310            0x109b4a
elf64.h                                      310            0x109b53
elf64.h                                      310            0x109b5c
elf64.h                                      310            0x109b65
elf64.h                                      310            0x109b6e
elf64.h                                      310            0x109b77
elf64.h                                      310            0x109b80
elf64.h                                      310            0x109b89
elf64.h                                      310            0x109b92
elf64.h                                      310            0x109b9b
elf64.h                                      310            0x109ba4
elf64.h                                      310            0x109bad
elf64.h                                      310            0x109bb6
elf64.h                                      310            0x109bbf
elf64.h                                      310            0x109bc8
elf64.h                                      310            0x109bd1
elf64.h                                      310            0x109bda
elf64.h                                      310            0x109be3
elf64.h                                      310            0x109bec
elf64.h                                      311            0x109bf8
elf64.h                                      310            0x109c10
elf64.h                                      312            0x109d7b
elf64.h                                      310            0x109d7c
elf64.h                                      314            0x109ec0
elf64.h                                      315            0x109ec0
elf64.h                                      315            0x109ec9
elf64.h                                      315            0x109ed2
elf64.h                                      315            0x109edb
elf64.h                                      315            0x109ee4
elf64.h                                      315            0x109eed
elf64.h                                      315            0x109ef6
elf64.h                                      315            0x109eff
elf64.h                                      315            0x109f08
elf64.h                                      315            0x109f11
elf64.h                                      315            0x109f1a
elf64.h                                      315            0x109f23
elf64.h                                      315            0x109f2c
elf64.h                                      315            0x109f35
elf64.h                                      315            0x109f3e
elf64.h                                      315            0x109f47
elf64.h                                      315            0x109f50
elf64.h                                      315            0x109f59
elf64.h                                      315            0x109f62
elf64.h                                      315            0x109f6b
elf64.h                                      315            0x109f74
elf64.h                                      315            0x109f7d
elf64.h                                      315            0x109f86
elf64.h                                      315            0x109f8f
elf64.h                                      316            0x109f98
elf64.h                                      315            0x109fb0
elf64.h                                      317            0x10a0c1

src/kernel_task.c:
kernel_task.c                                 92            0x10a0d0
kernel_task.c                                 94            0x10a0d0
kernel_task.c                                 99            0x10a0f4
kernel_task.c                                101            0x10a0f9
kernel_task.c                                108            0x10a0fe
kernel_task.c                                 99            0x10a106
kernel_task.c                                105            0x10a10b
kernel_task.c                                107            0x10a110
kernel_task.c                                108            0x10a110

src/kernel_log.c:
kernel_log.c                                 157            0x10a120

src/kernel_synch.h:
kernel_synch.h                                 7            0x10a127
kernel_synch.h                                 8            0x10a138

src/kernel_log.c:
kernel_log.c                                 159            0x10a13b
kernel_log.c                                 161            0x10a145
kernel_log.c                                 162            0x10a150
kernel_log.c                                 160            0x10a157
kernel_log.c                                 162            0x10a161
kernel_log.c                                 160            0x10a168
kernel_log.c                                 162            0x10a16c
kernel_log.c                                 163            0x10a16e

src/kernel_synch.h:
kernel_synch.h                                13            0x10a179
kernel_synch.h                                14            0x10a17c

src/kernel_log.c:
kernel_log.c                                 167            0x10a186
kernel_log.c                                 188            0x10a190
kernel_log.c                                 189            0x10a19c
kernel_log.c                                 188            0x10a1a3
kernel_log.c                                 189            0x10a1b7
kernel_log.c                                 215            0x10a1b9
kernel_log.c                                 191            0x10a1d0

src/kernel_synch.h:
kernel_synch.h                                 7            0x10a1d8
kernel_synch.h                                 8            0x10a1e9

src/kernel_log.c:
kernel_log.c                                 193            0x10a1ec
kernel_log.c                                 195            0x10a1f7
kernel_log.c                                 196            0x10a202
kernel_log.c                                 196            0x10a211

src/kernel_synch.h:
kernel_synch.h                                13            0x10a21c
kernel_synch.h                                14            0x10a21f

src/kernel_log.c:
kernel_log.c                                 198            0x10a229
kernel_log.c                                 201            0x10a22a
kernel_log.c                                  86            0x10a23a
kernel_log.c                                  85            0x10a23d
kernel_log.c                                  55            0x10a240
kernel_log.c                                 201            0x10a24a
kernel_log.c                                 202            0x10a259
kernel_log.c                                  87            0x10a26a
kernel_log.c                                  88            0x10a26e
kernel_log.c                                 144            0x10a280
kernel_log.c                                 145            0x10a284
kernel_log.c                                 144            0x10a288
kernel_log.c                                 148            0x10a294
kernel_log.c                                 149            0x10a29a

src/utility.h:
utility.h                                     27            0x10a2a7
utility.h                                     28            0x10a2c0
utility.h                                     27            0x10a2c9

src/kernel_log.c:
kernel_log.c                                 145            0x10a2d7

src/utility.h:
utility.h                                     27            0x10a2da

src/kernel_log.c:
kernel_log.c                                  87            0x10a2dd
kernel_log.c                                 202            0x10a2e1
kernel_log.c                                 208            0x10a2f3

src/kernel_synch.h:
kernel_synch.h                                 7            0x10a2f4

src/kernel_log.c:
kernel_log.c                                 211            0x10a308

src/kernel_synch.h:
kernel_synch.h                                 8            0x10a30b

src/kernel_log.c:
kernel_log.c                                 210            0x10a30e
kernel_log.c                                 211            0x10a315

src/hardware_serial.c:
hardware_serial.c                             40            0x10a324

src/kernel.h:
kernel.h                                      41            0x10a32b
kernel.h                                      29            0x10a330
kernel.h                                      41            0x10a340

src/hardware_serial.c:
hardware_serial.c                             41            0x10a343

src/kernel.h:
kernel.h                                      29            0x10a347

src/hardware_serial.c:
hardware_serial.c                             40            0x10a350

src/kernel.h:
kernel.h                                      41            0x10a359

src/hardware_serial.c:
hardware_serial.c                             41            0x10a361

src/kernel.h:
kernel.h                                      29            0x10a365

src/kernel_synch.h:
kernel_synch.h                                13            0x10a370
kernel_synch.h                                14            0x10a373

src/kernel_log.c:
kernel_log.c                                 214            0x10a37d
kernel_log.c                                 215            0x10a37e
kernel_log.c                                  91            0x10a38b
kernel_log.c                                  89            0x10a391
kernel_log.c                                  91            0x10a395
kernel_log.c                                 102            0x10a399
kernel_log.c                                 110            0x10a3a1
kernel_log.c                                 119            0x10a3a9
kernel_log.c                                 126            0x10a3b1
kernel_log.c                                 129            0x10a3b9
kernel_log.c                                 145            0x10a3c1

src/utility.h:
utility.h                                     27            0x10a3c4

src/kernel_log.c:
kernel_log.c                                  93            0x10a3cc
kernel_log.c                                  92            0x10a3d2
kernel_log.c                                  93            0x10a3d6
kernel_log.c                                  94            0x10a3da
kernel_log.c                                  95            0x10a3fb
kernel_log.c                                  49            0x10a40b
kernel_log.c                                  96            0x10a411
kernel_log.c                                  49            0x10a415
kernel_log.c                                  50            0x10a41b
kernel_log.c                                  51            0x10a41e
kernel_log.c                                  97            0x10a424
kernel_log.c                                  96            0x10a428
kernel_log.c                                 128            0x10a438
kernel_log.c                                 127            0x10a43e
kernel_log.c                                 128            0x10a442
kernel_log.c                                 130            0x10a44a
kernel_log.c                                 129            0x10a450
kernel_log.c                                 130            0x10a454
kernel_log.c                                 132            0x10a45c
kernel_log.c                                 131            0x10a460
kernel_log.c                                 132            0x10a464
kernel_log.c                                 133            0x10a477
kernel_log.c                                 132            0x10a47a
kernel_log.c                                 133            0x10a47e
kernel_log.c                                 134            0x10a493
kernel_log.c                                 133            0x10a497
kernel_log.c                                 134            0x10a49a

src/utility.h:
utility.h                                     27            0x10a4a7
utility.h                                     28            0x10a4b1
utility.h                                     27            0x10a4ba

src/kernel_log.c:
kernel_log.c                                 103            0x10a4d0
kernel_log.c                                 104            0x10a4f0
kernel_log.c                                  49            0x10a500
kernel_log.c                                 105            0x10a506
kernel_log.c                                  49            0x10a50a
kernel_log.c                                  50            0x10a50c
kernel_log.c                                  51            0x10a511
kernel_log.c                                 106            0x10a517
kernel_log.c                                 105            0x10a51b
kernel_log.c                                  55            0x10a528
kernel_log.c                                  53            0x10a546
kernel_log.c                                  55            0x10a549
kernel_log.c                                  56            0x10a550
kernel_log.c                                  55            0x10a553
kernel_log.c                                  53            0x10a558
kernel_log.c                                  39            0x10a55a
kernel_log.c                                  41            0x10a570
kernel_log.c                                  40            0x10a574
kernel_log.c                                  41            0x10a580
kernel_log.c                                  42            0x10a584
kernel_log.c                                  39            0x10a588
kernel_log.c                                 103            0x10a58f
kernel_log.c                                 120            0x10a5a2
kernel_log.c                                 121            0x10a5c3
kernel_log.c                                  49            0x10a5d3
kernel_log.c                                 122            0x10a5d8
kernel_log.c                                  49            0x10a5dc
kernel_log.c                                  50            0x10a5de
kernel_log.c                                  51            0x10a5e1
kernel_log.c                                 123            0x10a5e6
kernel_log.c                                 122            0x10a5ea
kernel_log.c                                  55            0x10a5f7
kernel_log.c                                  56            0x10a601
kernel_log.c                                  55            0x10a605
kernel_log.c                                  53            0x10a609
kernel_log.c                                  55            0x10a60c
kernel_log.c                                  53            0x10a619
kernel_log.c                                  39            0x10a61b
kernel_log.c                                  41            0x10a62d
kernel_log.c                                  40            0x10a631
kernel_log.c                                  41            0x10a63d
kernel_log.c                                  42            0x10a641
kernel_log.c                                  39            0x10a645
kernel_log.c                                 120            0x10a64c
kernel_log.c                                  55            0x10a660
kernel_log.c                                  53            0x10a67f
kernel_log.c                                  55            0x10a682
kernel_log.c                                  56            0x10a68a
kernel_log.c                                  55            0x10a68d
kernel_log.c                                  53            0x10a692
kernel_log.c                                  39            0x10a694
kernel_log.c                                  41            0x10a6ab
kernel_log.c                                  40            0x10a6af
kernel_log.c                                  41            0x10a6bb
kernel_log.c                                  42            0x10a6bf
kernel_log.c                                  39            0x10a6c3
kernel_log.c                                  94            0x10a6cd
kernel_log.c                                 111            0x10a6e0

src/utility.h:
utility.h                                     35            0x10a701
utility.h                                     36            0x10a70a
utility.h                                     35            0x10a70e

src/kernel_log.c:
kernel_log.c                                 113            0x10a715

src/utility.h:
utility.h                                     28            0x10a72b
utility.h                                     27            0x10a734

src/kernel_log.c:
kernel_log.c                                 116            0x10a73d
kernel_log.c                                 113            0x10a74e
kernel_log.c                                 116            0x10a75e
kernel_log.c                                 111            0x10a76f
kernel_log.c                                  39            0x10a782
kernel_log.c                                 133            0x10a7a7

kernel_log.c                                 132            0x10a7b5

src/kernel_memory.c:
kernel_memory.c                               37            0x10a7d0
kernel_memory.c                               38            0x10a7d0
kernel_memory.c                               37            0x10a7d6
kernel_memory.c                               37            0x10a7e0
kernel_memory.c                               38            0x10a7e3
kernel_memory.c                               39            0x10a7e5
kernel_memory.c                               39            0x10a7ee
kernel_memory.c                               42            0x10a81b
kernel_memory.c                               46            0x10a81f
kernel_memory.c                               42            0x10a826
kernel_memory.c                               46            0x10a82c
kernel_memory.c                               47            0x10a834
kernel_memory.c                               38            0x10a840
kernel_memory.c                               60            0x10a880

kernel_memory.c                               62            0x10a881
kernel_memory.c                               63            0x10a88a
kernel_memory.c                               64            0x10a88d
kernel_memory.c                               66            0x10a892

src/kernel_acpi.c:
kernel_acpi.c                                 41            0x10a8a0
kernel_acpi.c                                 45            0x10a8a0
kernel_acpi.c                                 46            0x10a8a5
kernel_acpi.c                                 42            0x10a8c0
kernel_acpi.c                                 42            0x10a8c6
kernel_acpi.c                                 43            0x10a8cc
kernel_acpi.c                                 43            0x10a8d2
kernel_acpi.c                                 44            0x10a8d8
kernel_acpi.c                                 44            0x10a8de
kernel_acpi.c                                 45            0x10a8e4
kernel_acpi.c                                 41            0x10a8ea

src/kernel_memory.c:
kernel_memory.c                               64            0x10a8ee

src/kernel_acpi.c:
kernel_acpi.c                                 41            0x10a8f0

src/kernel_memory.c:
kernel_memory.c                               64            0x10a8fc

src/kernel_acpi.c:
kernel_acpi.c                                 41            0x10a901
kernel_acpi.c                                 52            0x10a905

src/kernel_memory.c:
kernel_memory.c                               62            0x10a908
kernel_memory.c                               63            0x10a912
kernel_memory.c                               64            0x10a915

src/kernel_acpi.c:
kernel_acpi.c                                 53            0x10a91a
kernel_acpi.c                                 54            0x10a925
kernel_acpi.c                                 56            0x10a936
kernel_acpi.c                                148            0x10a950
kernel_acpi.c                                 56            0x10a95f
kernel_acpi.c                                 58            0x10a96a
kernel_acpi.c                                 59            0x10a96e
kernel_acpi.c                                 57            0x10a975
kernel_acpi.c                                 59            0x10a97c
kernel_acpi.c                                 65            0x10a97f
kernel_acpi.c                                 81            0x10a98a
kernel_acpi.c                                 78            0x10a98f
kernel_acpi.c                                 80            0x10a994
kernel_acpi.c                                 81            0x10a999
kernel_acpi.c                                 78            0x10a9a0
kernel_acpi.c                                 81            0x10a9a3
kernel_acpi.c                                104            0x10a9b0
kernel_acpi.c                                132            0x10a9b4
kernel_acpi.c                                135            0x10a9bb
kernel_acpi.c                                144            0x10a9c2
kernel_acpi.c                                 81            0x10a9c9
kernel_acpi.c                                144            0x10a9cc
kernel_acpi.c                                 81            0x10a9cf
kernel_acpi.c                                104            0x10a9d7
kernel_acpi.c                                110            0x10a9df
kernel_acpi.c                                111            0x10a9e8
kernel_acpi.c                                112            0x10a9ef
kernel_acpi.c                                111            0x10a9f2
kernel_acpi.c                                112            0x10a9f7
kernel_acpi.c                                133            0x10aa00
kernel_acpi.c                                114            0x10aa20
kernel_acpi.c                                149            0x10aa40
kernel_acpi.c                                 56            0x10aa55
kernel_acpi.c                                154            0x10aa60

src/usb_ehci.c:
usb_ehci.c                                   100            0x10aa70
usb_ehci.c                                   101            0x10aa74
usb_ehci.c                                   100            0x10aa76
usb_ehci.c                                   101            0x10aa7b

src/kernel_memory.c:
kernel_memory.c                               62            0x10aa80

src/usb_ehci.c:
usb_ehci.c                                   101            0x10aa83

src/kernel_memory.c:
kernel_memory.c                               62            0x10aa8d
kernel_memory.c                               63            0x10aa93
kernel_memory.c                               64            0x10aa96
kernel_memory.c                               63            0x10aa98
kernel_memory.c                               64            0x10aa9b

src/usb_ehci.c:
usb_ehci.c                                   106            0x10aaa0

src/kernel_memory.c:
kernel_memory.c                               64            0x10aaa7

src/usb_ehci.c:
usb_ehci.c                                   109            0x10aaac
usb_ehci.c                                   110            0x10aac4
usb_ehci.c                                   132            0x10aace
usb_ehci.c                                   133            0x10aad8
usb_ehci.c                                   144            0x10aae9
usb_ehci.c                                   148            0x10aaed
usb_ehci.c                                   144            0x10aaff
usb_ehci.c                                   148            0x10ab02
usb_ehci.c                                   145            0x10ab0a
usb_ehci.c                                   149            0x10ab0d
usb_ehci.c                                   145            0x10ab14
usb_ehci.c                                   149            0x10ab17
usb_ehci.c                                   145            0x10ab1c
usb_ehci.c                                   149            0x10ab1f

src/utility.h:
utility.h                                     22            0x10ab30
utility.h                                     21            0x10ab37
utility.h                                     22            0x10ab40
utility.h                                     21            0x10ab47

src/usb_ehci.c:
usb_ehci.c                                   160            0x10ab4f
usb_ehci.c                                   161            0x10ab54
usb_ehci.c                                   162            0x10ab5e
usb_ehci.c                                   160            0x10ab68
usb_ehci.c                                   163            0x10ab6e
usb_ehci.c                                   160            0x10ab78
usb_ehci.c                                   164            0x10ab83
usb_ehci.c                                   166            0x10ab8f
usb_ehci.c                                   167            0x10ab99
usb_ehci.c                                   168            0x10aba3
usb_ehci.c                                   169            0x10abad
usb_ehci.c                                   173            0x10abc8
usb_ehci.c                                   172            0x10abce
usb_ehci.c                                   177            0x10abd3
usb_ehci.c                                   201            0x10abe4
usb_ehci.c                                   192            0x10abe8
usb_ehci.c                                   190            0x10abed
usb_ehci.c                                   191            0x10abf4
usb_ehci.c                                   192            0x10abfb
usb_ehci.c                                   193            0x10abfe
usb_ehci.c                                   194            0x10ac02
usb_ehci.c                                   195            0x10ac09
usb_ehci.c                                   197            0x10ac0f
usb_ehci.c                                   201            0x10ac16
usb_ehci.c                                   205            0x10ac18
usb_ehci.c                                   214            0x10ac29
usb_ehci.c                                   216            0x10ac3d
usb_ehci.c                                   224            0x10ac41
usb_ehci.c                                   225            0x10ac4a
usb_ehci.c                                   226            0x10ac53
usb_ehci.c                                   207            0x10ac60
usb_ehci.c                                   135            0x10ac73
usb_ehci.c                                   244            0x10ac89
usb_ehci.c                                   247            0x10ac9a
usb_ehci.c                                   246            0x10aca0

src/kernel_memory.c:
kernel_memory.c                               49            0x10acb0
kernel_memory.c                               50            0x10acb0
kernel_memory.c                               49            0x10acb6
kernel_memory.c                               49            0x10acbd
kernel_memory.c                               50            0x10acc0
kernel_memory.c                               51            0x10acc6
kernel_memory.c                               52            0x10acd3
kernel_memory.c                               54            0x10acd6
kernel_memory.c                               53            0x10acd9
kernel_memory.c                               52            0x10acdd
kernel_memory.c                               54            0x10ace1
kernel_memory.c                               55            0x10ace5
kernel_memory.c                               54            0x10ace8
kernel_memory.c                               55            0x10acee
kernel_memory.c                               56            0x10acf6
kernel_memory.c                               56            0x10ad01
kernel_memory.c                               57            0x10ad2e
kernel_memory.c                               58            0x10ad3a
kernel_memory.c                               55            0x10ad40
kernel_memory.c                               51            0x10ad78

kernel_memory.c                               50            0x10adb0

src/kernel_task.c:
kernel_task.c                                 15            0x10adf0

kernel_task.c                                 19            0x10adf4
kernel_task.c                                 19            0x10ae00
kernel_task.c                                 21            0x10ae0e
kernel_task.c                                 20            0x10ae13
kernel_task.c                                 28            0x10ae1b
kernel_task.c                                 15            0x10ae20
kernel_task.c                                 31            0x10ae29
kernel_task.c                                 32            0x10ae31
kernel_task.c                                 33            0x10ae42
kernel_task.c                                 44            0x10ae49
kernel_task.c                                 16            0x10ae50
kernel_task.c                                 36            0x10ae60
kernel_task.c                                 39            0x10ae64

src/utility.h:
utility.h                                     27            0x10ae81
utility.h                                     28            0x10ae97
utility.h                                     27            0x10ae9d

src/kernel_task.c:
kernel_task.c                                 41            0x10aeaa
kernel_task.c                                 42            0x10aeb6
kernel_task.c                                 43            0x10aeba
kernel_task.c                                 48            0x10aec0
kernel_task.c                                 51            0x10aecb
kernel_task.c                                 48            0x10aecd
kernel_task.c                                 48            0x10aed2
kernel_task.c                                 50            0x10aed5
kernel_task.c                                 49            0x10aed7
kernel_task.c                                 53            0x10aee0
kernel_task.c                                 51            0x10aeec
kernel_task.c                                 59            0x10aefa
kernel_task.c                                 66            0x10aeff
kernel_task.c                                 69            0x10af13
kernel_task.c                                 70            0x10af1b
kernel_task.c                                 76            0x10af23
kernel_task.c                                 71            0x10af26
kernel_task.c                                 72            0x10af2a
kernel_task.c                                 73            0x10af2e
kernel_task.c                                 76            0x10af31
kernel_task.c                                 60            0x10af38
kernel_task.c                                 61            0x10af49

src/interrupt_handler.c:
interrupt_handler.c                          112            0x10af60

src/kernel.h:
kernel.h                                      41            0x10af60


src/interrupt_handler.c:
interrupt_handler.c                          116            0x10af62
interrupt_handler.c                          112            0x10af66

src/kernel.h:
kernel.h                                      41            0x10af67

src/interrupt_handler.c:
interrupt_handler.c                          118            0x10af69

src/kernel.h:
kernel.h                                      41            0x10af70

src/interrupt_handler.c:
interrupt_handler.c                          118            0x10af72
interrupt_handler.c                          124            0x10af74
interrupt_handler.c                          129            0x10af81
interrupt_handler.c                          130            0x10af86
interrupt_handler.c                          131            0x10af89
interrupt_handler.c                          138            0x10af93
interrupt_handler.c                          140            0x10afa8
interrupt_handler.c                          133            0x10afb0
interrupt_handler.c                          119            0x10afc0
interrupt_handler.c                          124            0x10afd4
interrupt_handler.c                          140            0x10afe1
interrupt_handler.c                          125            0x10afe2
interrupt_handler.c                          178            0x10b000
interrupt_handler.c                          180            0x10b000
interrupt_handler.c                          179            0x10b00c
interrupt_handler.c                          180            0x10b014
interrupt_handler.c                          181            0x10b019

src/kernel.h:
kernel.h                                      29            0x10b023

src/interrupt_handler.c:
interrupt_handler.c                           24            0x10b030

src/kernel_entry.c:
kernel_entry.c                                57            0x10b030


src/kernel_apic.c:
kernel_apic.c                                 58            0x10b036

src/kernel_entry.c:
kernel_entry.c                                57            0x10b03d

src/kernel_apic.c:
kernel_apic.c                                 59            0x10b03f

src/kernel_entry.c:
kernel_entry.c                                57            0x10b042
kernel_entry.c                                58            0x10b044
kernel_entry.c                                60            0x10b04c
kernel_entry.c                                61            0x10b05d

src/interrupt_handler.c:
interrupt_handler.c                           27            0x10b069

src/kernel_task.c:
kernel_task.c                                 94            0x10b073
kernel_task.c                                 99            0x10b08a
kernel_task.c                                101            0x10b092
kernel_task.c                                108            0x10b097
kernel_task.c                                 99            0x10b09f

src/interrupt_handler.c:
interrupt_handler.c                           29            0x10b0a7
interrupt_handler.c                           30            0x10b0b8

src/kernel_apic.c:
kernel_apic.c                                 53            0x10b0bf

src/interrupt_handler.c:
interrupt_handler.c                           31            0x10b0dd
interrupt_handler.c                           32            0x10b0e0
interrupt_handler.c                           61            0x10b0f0
interrupt_handler.c                           62            0x10b0f9
interrupt_handler.c                           63            0x10b115
interrupt_handler.c                           64            0x10b12e
interrupt_handler.c                           65            0x10b147
interrupt_handler.c                           66            0x10b154
interrupt_handler.c                           68            0x10b164
interrupt_handler.c                           66            0x10b165
interrupt_handler.c                           68            0x10b170

src/kernel_exceptions.c:
kernel_exceptions.c                           87            0x10b180
kernel_exceptions.c                           95            0x10b18e
kernel_exceptions.c                           96            0x10b191
kernel_exceptions.c                          106            0x10b19b
kernel_exceptions.c                          114            0x10b208
kernel_exceptions.c                          122            0x10b20f
kernel_exceptions.c                          123            0x10b220
kernel_exceptions.c                          125            0x10b22c
kernel_exceptions.c                           97            0x10b238
kernel_exceptions.c                           41            0x10b260

kernel_exceptions.c                           71            0x10b261
kernel_exceptions.c                           72            0x10b269
kernel_exceptions.c                           73            0x10b271
kernel_exceptions.c                           74            0x10b282
kernel_exceptions.c                           75            0x10b2a4
kernel_exceptions.c                           76            0x10b2c4
kernel_exceptions.c                           77            0x10b2e0
kernel_exceptions.c                           84            0x10b2ec
kernel_exceptions.c                           82            0x10b2f0
kernel_exceptions.c                           84            0x10b2fc

src/interrupt_handler.c:
interrupt_handler.c                           71            0x10b300
interrupt_handler.c                           72            0x10b300
interrupt_handler.c                           73            0x10b311

src/kernel.h:
kernel.h                                      29            0x10b31b

src/kernel_log.c:
kernel_log.c                                 169            0x10b330
kernel_log.c                                 170            0x10b330
kernel_log.c                                 169            0x10b337
kernel_log.c                                 169            0x10b338
kernel_log.c                                 170            0x10b33e
kernel_log.c                                 176            0x10b344
kernel_log.c                                 186            0x10b34d
kernel_log.c                                 177            0x10b353

src/utility.h:
utility.h                                     27            0x10b35b
utility.h                                     28            0x10b362
utility.h                                     27            0x10b369

src/kernel_log.c:
kernel_log.c                                 179            0x10b379

src/kernel_synch.h:
kernel_synch.h                                 7            0x10b380
kernel_synch.h                                 8            0x10b398

src/kernel_log.c:
kernel_log.c                                 183            0x10b39b
kernel_log.c                                 182            0x10b3a2

src/hardware_serial.c:
hardware_serial.c                             40            0x10b3aa

src/kernel.h:
kernel.h                                      41            0x10b3b1
kernel.h                                      29            0x10b3b6
kernel.h                                      41            0x10b3c0

src/hardware_serial.c:
hardware_serial.c                             41            0x10b3c3

src/kernel.h:
kernel.h                                      29            0x10b3c7

src/hardware_serial.c:
hardware_serial.c                             40            0x10b3cf

src/kernel.h:
kernel.h                                      41            0x10b3d8

src/hardware_serial.c:
hardware_serial.c                             41            0x10b3e1

src/kernel.h:
kernel.h                                      29            0x10b3e5

src/kernel_synch.h:
kernel_synch.h                                13            0x10b3f0
kernel_synch.h                                14            0x10b3f3

src/kernel_log.c:
kernel_log.c                                 186            0x10b3fe
kernel_log.c                                 171            0x10b400
kernel_log.c                                 172            0x10b411
kernel_log.c                                 186            0x10b41e
kernel_log.c                                 172            0x10b41f

src/interrupt_handler.c:
interrupt_handler.c                           35            0x10b430
interrupt_handler.c                           35            0x10b430

interrupt_handler.c                           36            0x10b433
interrupt_handler.c                           38            0x10b440

src/kernel_entry.c:
kernel_entry.c                               227            0x10b450

src/kernel.h:
kernel.h                                      29            0x10b454

src/kernel_entry.c:
kernel_entry.c                               227            0x10b457

src/kernel.h:
kernel.h                                      29            0x10b459

src/kernel_entry.c:
kernel_entry.c                               227            0x10b45f

src/kernel.h:
kernel.h                                      29            0x10b462

src/kernel_entry.c:
kernel_entry.c                               227            0x10b468

src/kernel.h:
kernel.h                                      29            0x10b46c

src/kernel_entry.c:
kernel_entry.c                               111            0x10b4ff

kernel_entry.c                               107            0x10b505
kernel_entry.c                               108            0x10b508
kernel_entry.c                               109            0x10b50c
kernel_entry.c                               110            0x10b50f
kernel_entry.c                               111            0x10b517
kernel_entry.c                               112            0x10b51c
kernel_entry.c                               120            0x10b520
kernel_entry.c                               158            0x10b528
kernel_entry.c                               111            0x10b52d
kernel_entry.c                               108            0x10b537
kernel_entry.c                               107            0x10b53a
kernel_entry.c                               109            0x10b541
kernel_entry.c                               108            0x10b545
kernel_entry.c                               109            0x10b549
kernel_entry.c                               159            0x10b54f
kernel_entry.c                               108            0x10b554
kernel_entry.c                               111            0x10b55b
kernel_entry.c                               107            0x10b560
kernel_entry.c                               111            0x10b567
kernel_entry.c                               108            0x10b56e
kernel_entry.c                               109            0x10b571
kernel_entry.c                               108            0x10b575
kernel_entry.c                               109            0x10b579
kernel_entry.c                               160            0x10b57f
kernel_entry.c                               108            0x10b584
kernel_entry.c                               107            0x10b58b
kernel_entry.c                               108            0x10b592
kernel_entry.c                               109            0x10b595
kernel_entry.c                               108            0x10b599
kernel_entry.c                               111            0x10b59d
kernel_entry.c                               109            0x10b5a3
kernel_entry.c                               161            0x10b5a9
kernel_entry.c                               108            0x10b5ae
kernel_entry.c                               107            0x10b5b5
kernel_entry.c                               108            0x10b5bc
kernel_entry.c                               109            0x10b5bf
kernel_entry.c                               108            0x10b5c3
kernel_entry.c                               109            0x10b5c7
kernel_entry.c                               162            0x10b5cd
kernel_entry.c                               108            0x10b5d2
kernel_entry.c                               107            0x10b5d9
kernel_entry.c                               108            0x10b5e0
kernel_entry.c                               109            0x10b5e3
kernel_entry.c                               108            0x10b5e7
kernel_entry.c                               111            0x10b5eb
kernel_entry.c                               109            0x10b5f1
kernel_entry.c                               163            0x10b5f7
kernel_entry.c                               108            0x10b5fc
kernel_entry.c                               107            0x10b606
kernel_entry.c                               109            0x10b60d
kernel_entry.c                               108            0x10b611
kernel_entry.c                               111            0x10b615
kernel_entry.c                               108            0x10b639
kernel_entry.c                               110            0x10b640
kernel_entry.c                               111            0x10b647
kernel_entry.c                               112            0x10b64d
kernel_entry.c                               110            0x10b654
kernel_entry.c                               111            0x10b65b
kernel_entry.c                               112            0x10b660
kernel_entry.c                               110            0x10b667
kernel_entry.c                               111            0x10b66e
kernel_entry.c                               112            0x10b674
kernel_entry.c                               110            0x10b67b
kernel_entry.c                               111            0x10b682
kernel_entry.c                               112            0x10b688
kernel_entry.c                               110            0x10b68f
kernel_entry.c                               111            0x10b696
kernel_entry.c                               112            0x10b69b
kernel_entry.c                               109            0x10b6a2
kernel_entry.c                               164            0x10b6a8
kernel_entry.c                               107            0x10b6ad
kernel_entry.c                               108            0x10b6b4
kernel_entry.c                               109            0x10b6b7
kernel_entry.c                               108            0x10b6bb
kernel_entry.c                               109            0x10b6bf
kernel_entry.c                               165            0x10b6c5
kernel_entry.c                               108            0x10b6ca
kernel_entry.c                               107            0x10b6d1
kernel_entry.c                               108            0x10b6d8
kernel_entry.c                               109            0x10b6db
kernel_entry.c                               108            0x10b6df
kernel_entry.c                               111            0x10b6e3
kernel_entry.c                               109            0x10b6eb
kernel_entry.c                               166            0x10b6f1
kernel_entry.c                               108            0x10b6f6
kernel_entry.c                               107            0x10b6fd
kernel_entry.c                               108            0x10b704
kernel_entry.c                               109            0x10b707
kernel_entry.c                               108            0x10b70b
kernel_entry.c                               109            0x10b70f
kernel_entry.c                               167            0x10b715
kernel_entry.c                               108            0x10b71a
kernel_entry.c                               107            0x10b721
kernel_entry.c                               108            0x10b728
kernel_entry.c                               109            0x10b72b
kernel_entry.c                               108            0x10b72f
kernel_entry.c                               111            0x10b733
kernel_entry.c                               109            0x10b73b
kernel_entry.c                               168            0x10b741
kernel_entry.c                               108            0x10b746
kernel_entry.c                               107            0x10b74d
kernel_entry.c                               108            0x10b754
kernel_entry.c                               109            0x10b757
kernel_entry.c                               111            0x10b761
kernel_entry.c                               108            0x10b766
kernel_entry.c                               111            0x10b76a
kernel_entry.c                               169            0x10b771
kernel_entry.c                               111            0x10b776
kernel_entry.c                               108            0x10b792
kernel_entry.c                               110            0x10b799
kernel_entry.c                               108            0x10b7a0
kernel_entry.c                               112            0x10b7a3
kernel_entry.c                               110            0x10b7aa
kernel_entry.c                               108            0x10b7b1
kernel_entry.c                               112            0x10b7b5
kernel_entry.c                               110            0x10b7bc
kernel_entry.c                               111            0x10b7c3
kernel_entry.c                               112            0x10b7c9
kernel_entry.c                               110            0x10b7d0
kernel_entry.c                               111            0x10b7d7
kernel_entry.c                               112            0x10b7dd
kernel_entry.c                               110            0x10b7e4
kernel_entry.c                               111            0x10b7eb
kernel_entry.c                               112            0x10b7f1
kernel_entry.c                               110            0x10b7f8
kernel_entry.c                               111            0x10b7ff
kernel_entry.c                               112            0x10b805
kernel_entry.c                               107            0x10b80c
kernel_entry.c                               109            0x10b813
kernel_entry.c                               111            0x10b81d
kernel_entry.c                               108            0x10b822
kernel_entry.c                               111            0x10b829
kernel_entry.c                               170            0x10b830
kernel_entry.c                               110            0x10b835
kernel_entry.c                               107            0x10b83c
kernel_entry.c                               108            0x10b843
kernel_entry.c                               109            0x10b846
kernel_entry.c                               111            0x10b850
kernel_entry.c                               108            0x10b855
kernel_entry.c                               111            0x10b859
kernel_entry.c                               171            0x10b860
kernel_entry.c                               108            0x10b865
kernel_entry.c                               107            0x10b86c
kernel_entry.c                               108            0x10b873
kernel_entry.c                               109            0x10b876
kernel_entry.c                               111            0x10b880
kernel_entry.c                               108            0x10b885
kernel_entry.c                               111            0x10b889
kernel_entry.c                               172            0x10b890
kernel_entry.c                               108            0x10b895
kernel_entry.c                               107            0x10b89c
kernel_entry.c                               108            0x10b8a3
kernel_entry.c                               109            0x10b8a6
kernel_entry.c                               111            0x10b8b0
kernel_entry.c                               108            0x10b8b5
kernel_entry.c                               111            0x10b8b9
kernel_entry.c                               173            0x10b8c0
kernel_entry.c                               108            0x10b8c5
kernel_entry.c                               107            0x10b8cc
kernel_entry.c                               108            0x10b8d3
kernel_entry.c                               109            0x10b8d6
kernel_entry.c                               111            0x10b8e0
kernel_entry.c                               108            0x10b8e5
kernel_entry.c                               111            0x10b8e9
kernel_entry.c                               174            0x10b8f0
kernel_entry.c                               108            0x10b8f5
kernel_entry.c                               107            0x10b8ff
kernel_entry.c                               112            0x10b906
kernel_entry.c                               108            0x10b90d
kernel_entry.c                               109            0x10b911
kernel_entry.c                               110            0x10b915
kernel_entry.c                               108            0x10b91c
kernel_entry.c                               112            0x10b923
kernel_entry.c                               111            0x10b92a
kernel_entry.c                               110            0x10b92f
kernel_entry.c                               112            0x10b936
kernel_entry.c                               111            0x10b93d
kernel_entry.c                               110            0x10b942
kernel_entry.c                               112            0x10b949
kernel_entry.c                               111            0x10b950
kernel_entry.c                               110            0x10b956
kernel_entry.c                               112            0x10b95d
kernel_entry.c                               111            0x10b964
kernel_entry.c                               109            0x10b96a
kernel_entry.c                               175            0x10b970
kernel_entry.c                               111            0x10b975
kernel_entry.c                               107            0x10b97c
kernel_entry.c                               108            0x10b983
kernel_entry.c                               109            0x10b986
kernel_entry.c                               108            0x10b98a
kernel_entry.c                               109            0x10b98e
kernel_entry.c                               176            0x10b994
kernel_entry.c                               108            0x10b999
kernel_entry.c                               107            0x10b9a0
kernel_entry.c                               108            0x10b9a7
kernel_entry.c                               109            0x10b9aa
kernel_entry.c                               108            0x10b9ae
kernel_entry.c                               111            0x10b9b2
kernel_entry.c                               109            0x10b9b9
kernel_entry.c                               177            0x10b9bf
kernel_entry.c                               108            0x10b9c4
kernel_entry.c                               107            0x10b9cb
kernel_entry.c                               108            0x10b9d2
kernel_entry.c                               109            0x10b9d5
kernel_entry.c                               108            0x10b9d9
kernel_entry.c                               109            0x10b9dd
kernel_entry.c                               178            0x10b9e3
kernel_entry.c                               108            0x10b9e8
kernel_entry.c                               107            0x10b9ef
kernel_entry.c                               108            0x10b9f6
kernel_entry.c                               109            0x10b9f9
kernel_entry.c                               108            0x10b9fd
kernel_entry.c                               111            0x10ba01
kernel_entry.c                               109            0x10ba08
kernel_entry.c                               179            0x10ba0e
kernel_entry.c                               108            0x10ba13
kernel_entry.c                               107            0x10ba1a
kernel_entry.c                               108            0x10ba21
kernel_entry.c                               109            0x10ba24
kernel_entry.c                               108            0x10ba28
kernel_entry.c                               109            0x10ba2c
kernel_entry.c                               180            0x10ba32
kernel_entry.c                               111            0x10ba37
kernel_entry.c                               108            0x10ba4c
kernel_entry.c                               111            0x10ba53
kernel_entry.c                               108            0x10ba5b
kernel_entry.c                               110            0x10ba5e
kernel_entry.c                               112            0x10ba65
kernel_entry.c                               108            0x10ba6c
kernel_entry.c                               110            0x10ba70
kernel_entry.c                               112            0x10ba77

src/kernel_descriptor.c:
kernel_descriptor.c                          115            0x10ba7e

src/kernel_entry.c:
kernel_entry.c                               110            0x10ba83
kernel_entry.c                               112            0x10ba8a

src/kernel_descriptor.c:
kernel_descriptor.c                          115            0x10ba91

src/kernel_entry.c:
kernel_entry.c                               110            0x10ba97
kernel_entry.c                               112            0x10ba9e
kernel_entry.c                               273            0x10baa5
kernel_entry.c                               110            0x10baab
kernel_entry.c                               112            0x10bab2
kernel_entry.c                               110            0x10bab9
kernel_entry.c                               112            0x10bac0
kernel_entry.c                               107            0x10bac7
kernel_entry.c                               109            0x10bace
kernel_entry.c                               108            0x10bad2
kernel_entry.c                               109            0x10bad9
kernel_entry.c                               181            0x10badf
kernel_entry.c                               111            0x10bae4
kernel_entry.c                               107            0x10baec
kernel_entry.c                               108            0x10baf3
kernel_entry.c                               109            0x10baf6
kernel_entry.c                               108            0x10bafa
kernel_entry.c                               109            0x10bafe
kernel_entry.c                               182            0x10bb04
kernel_entry.c                               108            0x10bb09
kernel_entry.c                               107            0x10bb10
kernel_entry.c                               108            0x10bb17
kernel_entry.c                               109            0x10bb1a
kernel_entry.c                               108            0x10bb1e
kernel_entry.c                               111            0x10bb22
kernel_entry.c                               109            0x10bb29
kernel_entry.c                               183            0x10bb2f
kernel_entry.c                               108            0x10bb34
kernel_entry.c                               107            0x10bb3b
kernel_entry.c                               108            0x10bb42
kernel_entry.c                               109            0x10bb45
kernel_entry.c                               108            0x10bb49
kernel_entry.c                               109            0x10bb4d
kernel_entry.c                               184            0x10bb53
kernel_entry.c                               108            0x10bb58
kernel_entry.c                               107            0x10bb5f
kernel_entry.c                               108            0x10bb66
kernel_entry.c                               109            0x10bb69
kernel_entry.c                               108            0x10bb6d
kernel_entry.c                               111            0x10bb71
kernel_entry.c                               109            0x10bb79
kernel_entry.c                               111            0x10bb7f
kernel_entry.c                               108            0x10bb84
kernel_entry.c                               111            0x10bb8b
kernel_entry.c                               185            0x10bb92
kernel_entry.c                               111            0x10bb97
kernel_entry.c                               108            0x10bb9f
kernel_entry.c                               107            0x10bba2
kernel_entry.c                               109            0x10bba9
kernel_entry.c                               108            0x10bbad
kernel_entry.c                               110            0x10bbb1
kernel_entry.c                               112            0x10bbb8
kernel_entry.c                               108            0x10bbbf
kernel_entry.c                               110            0x10bbc6
kernel_entry.c                               112            0x10bbcd
kernel_entry.c                               110            0x10bbd4
kernel_entry.c                               112            0x10bbdb
kernel_entry.c                               110            0x10bbe2
kernel_entry.c                               112            0x10bbe9
kernel_entry.c                               110            0x10bbf0
kernel_entry.c                               112            0x10bbf7
kernel_entry.c                               109            0x10bbfe
kernel_entry.c                               111            0x10bc04
kernel_entry.c                               186            0x10bc10
kernel_entry.c                               110            0x10bc15
kernel_entry.c                               107            0x10bc1c
kernel_entry.c                               108            0x10bc23
kernel_entry.c                               109            0x10bc26
kernel_entry.c                               111            0x10bc30
kernel_entry.c                               108            0x10bc35
kernel_entry.c                               111            0x10bc39
kernel_entry.c                               187            0x10bc40
kernel_entry.c                               108            0x10bc45
kernel_entry.c                               107            0x10bc4c
kernel_entry.c                               108            0x10bc53
kernel_entry.c                               109            0x10bc56
kernel_entry.c                               111            0x10bc60
kernel_entry.c                               108            0x10bc65
kernel_entry.c                               111            0x10bc69
kernel_entry.c                               188            0x10bc70
kernel_entry.c                               108            0x10bc75
kernel_entry.c                               107            0x10bc7c
kernel_entry.c                               108            0x10bc83
kernel_entry.c                               109            0x10bc86
kernel_entry.c                               111            0x10bc90
kernel_entry.c                               108            0x10bc95
kernel_entry.c                               111            0x10bc99
kernel_entry.c                               189            0x10bca0
kernel_entry.c                               108            0x10bca5
kernel_entry.c                               107            0x10bcac
kernel_entry.c                               108            0x10bcb3
kernel_entry.c                               109            0x10bcb6
kernel_entry.c                               111            0x10bcc0
kernel_entry.c                               108            0x10bcc5
kernel_entry.c                               111            0x10bcc9
kernel_entry.c                               204            0x10bcd0
kernel_entry.c                               108            0x10bcd5
kernel_entry.c                               107            0x10bcdf
kernel_entry.c                               112            0x10bce6
kernel_entry.c                               108            0x10bced
kernel_entry.c                               109            0x10bcf1
kernel_entry.c                               110            0x10bcf5
kernel_entry.c                               108            0x10bcfc
kernel_entry.c                               109            0x10bd03
kernel_entry.c                               111            0x10bd09
kernel_entry.c                               205            0x10bd0e
kernel_entry.c                               111            0x10bd13
kernel_entry.c                               112            0x10bd1a
kernel_entry.c                               108            0x10bd21
kernel_entry.c                               110            0x10bd24
kernel_entry.c                               112            0x10bd2b
kernel_entry.c                               110            0x10bd32
kernel_entry.c                               112            0x10bd39
kernel_entry.c                               108            0x10bd40
kernel_entry.c                               110            0x10bd44
kernel_entry.c                               112            0x10bd4b
kernel_entry.c                               110            0x10bd52
kernel_entry.c                               112            0x10bd59
kernel_entry.c                               107            0x10bd60
kernel_entry.c                               109            0x10bd67
kernel_entry.c                               108            0x10bd6b
kernel_entry.c                               109            0x10bd72
kernel_entry.c                               206            0x10bd78
kernel_entry.c                               110            0x10bd7d

src/kernel_descriptor.c:
kernel_descriptor.c                          111            0x10bd84
kernel_descriptor.c                          112            0x10bd8b
kernel_descriptor.c                          113            0x10bd8e
kernel_descriptor.c                          112            0x10bd92
kernel_descriptor.c                          113            0x10bd96

src/kernel_entry.c:
kernel_entry.c                               207            0x10bd9c

src/kernel_descriptor.c:
kernel_descriptor.c                          112            0x10bda1
kernel_descriptor.c                          111            0x10bdab
kernel_descriptor.c                          112            0x10bdb2
kernel_descriptor.c                          113            0x10bdb6

src/kernel_entry.c:
kernel_entry.c                               111            0x10bdba
kernel_entry.c                               112            0x10bdc1

src/kernel_descriptor.c:
kernel_descriptor.c                          114            0x10bdc8
kernel_descriptor.c                          115            0x10bdcf
kernel_descriptor.c                          116            0x10bdd6
kernel_descriptor.c                          112            0x10bddd
kernel_descriptor.c                          113            0x10bde4
kernel_descriptor.c                          114            0x10bdea
kernel_descriptor.c                          115            0x10bdf1
kernel_descriptor.c                          116            0x10bdf9

src/kernel_entry.c:
kernel_entry.c                               273            0x10be00
kernel_entry.c                               274            0x10be0e
kernel_entry.c                               275            0x10be12

src/kernel_memory.c:
kernel_memory.c                               69            0x10be13

src/kernel_entry.c:
kernel_entry.c                               282            0x10be18

src/kernel_memory.c:
kernel_memory.c                               69            0x10be23

src/kernel_entry.c:
kernel_entry.c                               285            0x10be27

src/kernel_memory.c:
kernel_memory.c                               69            0x10be2e

src/kernel_entry.c:
kernel_entry.c                               285            0x10be35
kernel_entry.c                               286            0x10be37
kernel_entry.c                               287            0x10be48
kernel_entry.c                               290            0x10be54
kernel_entry.c                               298            0x10be5d
kernel_entry.c                               297            0x10be60
kernel_entry.c                               298            0x10be64
kernel_entry.c                               299            0x10be72
kernel_entry.c                               335            0x10be7e
kernel_entry.c                               298            0x10be8a
kernel_entry.c                               299            0x10be90
kernel_entry.c                               306            0x10be95
kernel_entry.c                               307            0x10be99
kernel_entry.c                               339            0x10be9b
kernel_entry.c                               343            0x10bea7
kernel_entry.c                               344            0x10beb1
kernel_entry.c                               360            0x10bec2
kernel_entry.c                               365            0x10becb
kernel_entry.c                               372            0x10bedd

src/utility.h:
utility.h                                     21            0x10bee8
utility.h                                     22            0x10beea
utility.h                                     21            0x10bef1

src/kernel_entry.c:
kernel_entry.c                               376            0x10befb
kernel_entry.c                               374            0x10bf0c
kernel_entry.c                               375            0x10bf17
kernel_entry.c                               376            0x10bf22

src/kernel_descriptor.c:
kernel_descriptor.c                           83            0x10bf27
kernel_descriptor.c                           81            0x10bf2a
kernel_descriptor.c                           82            0x10bf33
kernel_descriptor.c                           83            0x10bf38
kernel_descriptor.c                           81            0x10bf3c
kernel_descriptor.c                           91            0x10bf41
kernel_descriptor.c                           83            0x10bf46
kernel_descriptor.c                           84            0x10bf4a
kernel_descriptor.c                           85            0x10bf4d
kernel_descriptor.c                           84            0x10bf51
kernel_descriptor.c                           85            0x10bf55
kernel_descriptor.c                           93            0x10bf59
kernel_descriptor.c                           84            0x10bf5e
kernel_descriptor.c                           87            0x10bf67

src/utility.h:
utility.h                                     27            0x10bf70
utility.h                                     28            0x10bf72
utility.h                                     27            0x10bf76
utility.h                                     28            0x10bf7a
utility.h                                     27            0x10bf80

src/kernel_descriptor.c:
kernel_descriptor.c                           96            0x10bf86
kernel_descriptor.c                           97            0x10bf9c
kernel_descriptor.c                          126            0x10bfb2
kernel_descriptor.c                          143            0x10bfb3
kernel_descriptor.c                          145            0x10bfc9
kernel_descriptor.c                          146            0x10bfd1

src/kernel_entry.c:
kernel_entry.c                               388            0x10bfd2
kernel_entry.c                               386            0x10bfde
kernel_entry.c                               387            0x10bfe9

src/kernel.h:
kernel.h                                      29            0x10bff4

src/kernel_entry.c:
kernel_entry.c                               388            0x10bffa
kernel_entry.c                               389            0x10bfff

src/kernel.h:
kernel.h                                      29            0x10c012

src/kernel_entry.c:
kernel_entry.c                               391            0x10c029
kernel_entry.c                               392            0x10c02a
kernel_entry.c                               393            0x10c03b
kernel_entry.c                               394            0x10c045

src/kernel.h:
kernel.h                                      29            0x10c046

src/kernel_entry.c:
kernel_entry.c                               397            0x10c05a

src/kernel_apic.c:
kernel_apic.c                                 77            0x10c05b

src/kernel.h:
kernel.h                                      29            0x10c05c

src/kernel_apic.c:
kernel_apic.c                                 52            0x10c06a
kernel_apic.c                                 53            0x10c071
kernel_apic.c                                 95            0x10c07b

src/kernel_entry.c:
kernel_entry.c                               407            0x10c07c

src/kernel_apic.c:
kernel_apic.c                                 64            0x10c083
kernel_apic.c                                 39            0x10c084
kernel_apic.c                                 40            0x10c08a
kernel_apic.c                                 39            0x10c091
kernel_apic.c                                 40            0x10c097
kernel_apic.c                                 72            0x10c09e

src/kernel_entry.c:
kernel_entry.c                               408            0x10c09f
kernel_entry.c                               437            0x10c0b0
kernel_entry.c                               361            0x10c0b3
kernel_entry.c                               347            0x10c0e5


src/kernel_memory.c:
kernel_memory.c                               64            0x10c0e9
kernel_memory.c                               62            0x10c0f3
kernel_memory.c                               63            0x10c0fd
kernel_memory.c                               64            0x10c103

src/kernel_entry.c:
kernel_entry.c                               348            0x10c108
kernel_entry.c                               351            0x10c125
kernel_entry.c                               352            0x10c128
kernel_entry.c                               356            0x10c12b
kernel_entry.c                               353            0x10c130
kernel_entry.c                               356            0x10c13b
kernel_entry.c                               351            0x10c140
kernel_entry.c                               352            0x10c146
kernel_entry.c                               354            0x10c14c
kernel_entry.c                               355            0x10c15c
kernel_entry.c                               356            0x10c15f
kernel_entry.c                               355            0x10c163
kernel_entry.c                               356            0x10c169
kernel_entry.c                               298            0x10c175
kernel_entry.c                               296            0x10c178
kernel_entry.c                               340            0x10c17a
kernel_entry.c                               291            0x10c1ae

kernel_entry.c                               292            0x10c1bf

src/kernel_task.c:
kernel_task.c                                 82            0x10c1d0

src/kernel_entry.c:
kernel_entry.c                                57            0x10c1dc

src/kernel_apic.c:
kernel_apic.c                                 58            0x10c1e2

src/kernel_entry.c:
kernel_entry.c                                57            0x10c1e9

src/kernel_apic.c:
kernel_apic.c                                 59            0x10c1eb

src/kernel_entry.c:
kernel_entry.c                                57            0x10c1ee
kernel_entry.c                                58            0x10c1f0
kernel_entry.c                                60            0x10c1f8
kernel_entry.c                                61            0x10c209

src/kernel_task.c:
kernel_task.c                                 85            0x10c215
kernel_task.c                                 89            0x10c22d
kernel_task.c                                 90            0x10c23e
kernel_task.c                                 89            0x10c244

src/kernel_log.c:
kernel_log.c                                 217            0x10c250
kernel_log.c                                 218            0x10c250

src/kernel_synch.h:
kernel_synch.h                                 7            0x10c260
kernel_synch.h                                 8            0x10c279

src/kernel_log.c:
kernel_log.c                                 220            0x10c27c
kernel_log.c                                 224            0x10c28b
kernel_log.c                                 225            0x10c29e

src/kernel_synch.h:
kernel_synch.h                                13            0x10c2a5
kernel_synch.h                                14            0x10c2a8

src/kernel_log.c:
kernel_log.c                                 229            0x10c2c0

src/kernel_synch.h:
kernel_synch.h                                 7            0x10c2c7
kernel_synch.h                                 8            0x10c2d8

src/kernel_log.c:
kernel_log.c                                 231            0x10c2db
kernel_log.c                                 232            0x10c2e7
kernel_log.c                                 233            0x10c2ef
kernel_log.c                                 235            0x10c2fa

src/kernel_synch.h:
kernel_synch.h                                13            0x10c301
kernel_synch.h                                14            0x10c304

src/kernel_log.c:
kernel_log.c                                 250            0x10c310
kernel_log.c                                 251            0x10c310
kernel_log.c                                 254            0x10c320
kernel_log.c                                 255            0x10c320

src/kernel_shell.c:
kernel_shell.c                                76            0x10c330

src/utility.h:
utility.h                                     59            0x10c334

src/kernel_shell.c:
kernel_shell.c                                76            0x10c336

src/utility.h:
utility.h                                     60            0x10c33c
utility.h                                     59            0x10c34c

src/kernel_shell.c:
kernel_shell.c                                43            0x10c356
kernel_shell.c                                46            0x10c367
kernel_shell.c                                86            0x10c3c9

kernel_shell.c                                85            0x10c3cd
kernel_shell.c                                86            0x10c3d4
kernel_shell.c                                85            0x10c3da

src/utility.h:
utility.h                                     60            0x10c3e0
utility.h                                     59            0x10c3f4

src/kernel_shell.c:
kernel_shell.c                                86            0x10c3fe

src/utility.h:
utility.h                                     60            0x10c410
utility.h                                     59            0x10c41e

src/kernel_shell.c:
kernel_shell.c                                73            0x10c428

src/utility.h:
utility.h                                     60            0x10c438
utility.h                                     59            0x10c44d

src/kernel_shell.c:
kernel_shell.c                                63            0x10c45e

src/kernel_debug.c:
kernel_debug.c                                23            0x10c464

src/kernel_apic.c:
kernel_apic.c                                 46            0x10c466
kernel_apic.c                                 47            0x10c46a

src/kernel_debug.c:
kernel_debug.c                                28            0x10c46e
kernel_debug.c                                29            0x10c481
kernel_debug.c                                30            0x10c490
kernel_debug.c                                23            0x10c493
kernel_debug.c                                29            0x10c497
kernel_debug.c                                30            0x10c49c
kernel_debug.c                                23            0x10c4b6

src/utility.h:
utility.h                                     60            0x10c4c8
utility.h                                     59            0x10c4e0

src/kernel_shell.c:
kernel_shell.c                                52            0x10c4ea
kernel_shell.c                                54            0x10c4f1

src/kernel_apic.c:
kernel_apic.c                                 53            0x10c4fb

src/kernel_shell.c:
kernel_shell.c                                54            0x10c519
kernel_shell.c                                55            0x10c51e
kernel_shell.c                                57            0x10c528

src/kernel_entry.c:
kernel_entry.c                                57            0x10c541

src/kernel_shell.c:
kernel_shell.c                                57            0x10c547

src/kernel_apic.c:
kernel_apic.c                                 58            0x10c54a

src/kernel_entry.c:
kernel_entry.c                                57            0x10c551

src/kernel_apic.c:
kernel_apic.c                                 59            0x10c553

src/kernel_entry.c:
kernel_entry.c                                57            0x10c556
kernel_entry.c                                58            0x10c558
kernel_entry.c                                60            0x10c560
kernel_entry.c                                61            0x10c571

src/kernel_task.c:
kernel_task.c                                 85            0x10c57d
kernel_task.c                                 89            0x10c58c
kernel_task.c                                 85            0x10c5a0

src/kernel_shell.c:
kernel_shell.c                                86            0x10c5a7

src/kernel_task.c:
kernel_task.c                                 89            0x10c5b1

src/kernel_shell.c:
kernel_shell.c                                85            0x10c5c0

src/kernel_log.c:
kernel_log.c                                 239            0x10c5d0
kernel_log.c                                 240            0x10c5d0
kernel_log.c                                 241            0x10c5e0
kernel_log.c                                 243            0x10c5e7
kernel_log.c                                 244            0x10c5f2


Disassembly of section .text:

0000000000109000 <syscall_handler_exit_process>:
  extern void asm_exit_usermode(void);
  stack.ss = GDT_RING0_DATA;
  stack.cs = GDT_RING0_CODE;
  stack.rip = (uintptr_t)asm_exit_usermode;
  stack.rsp = (uintptr_t)globals.system_info.kernel_stack_address;
  asm volatile("mov $0x00, %rdi");
  109000:	48 c7 c7 00 00 00 00 	mov    rdi,0x0
  return 0;
}
  109007:	31 c0                	xor    eax,eax
  109009:	c3                   	ret    
  10900a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000109010 <syscall_handler_get_framebuffer>:

static void syscall_handler_get_framebuffer(Framebuffer *fb){
  *fb = globals.framebuffer;
  109010:	48 8b 05 51 78 01 00 	mov    rax,QWORD PTR [rip+0x17851]        # 120868 <globals+0x10708>
  109017:	48 89 07             	mov    QWORD PTR [rdi],rax
  10901a:	48 8b 05 4f 78 01 00 	mov    rax,QWORD PTR [rip+0x1784f]        # 120870 <globals+0x10710>
  109021:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
  109025:	48 8b 05 4c 78 01 00 	mov    rax,QWORD PTR [rip+0x1784c]        # 120878 <globals+0x10718>
  10902c:	48 89 47 10          	mov    QWORD PTR [rdi+0x10],rax
  109030:	c3                   	ret    
  109031:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  109036:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10903d:	00 00 00 

0000000000109040 <__memset>:

#define memcpy(dest,src,size) __memcpy((uint8_t*)dest, (uint8_t*)src, size)
#define memset(dest,value,size) __memset((uint8_t*)dest, value, size)

void __memset(uint8_t *dest, uint8_t value, size_t size) {
  for (size_t i = 0; i < size; i++) {
  109040:	48 85 d2             	test   rdx,rdx
  109043:	48 8d 04 17          	lea    rax,[rdi+rdx*1]
  109047:	74 13                	je     10905c <__memset+0x1c>
  109049:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		dest[i] = value;
  109050:	40 88 37             	mov    BYTE PTR [rdi],sil
  109053:	48 83 c7 01          	add    rdi,0x1
  for (size_t i = 0; i < size; i++) {
  109057:	48 39 c7             	cmp    rdi,rax
  10905a:	75 f4                	jne    109050 <__memset+0x10>
  10905c:	f3 c3                	repz ret 
  10905e:	66 90                	xchg   ax,ax

0000000000109060 <__memcpy>:
	}
}

void __memcpy(uint8_t *dest, uint8_t *src, size_t size) {
	for (size_t i = 0; i < size; i++) {
  109060:	31 c0                	xor    eax,eax
  109062:	48 85 d2             	test   rdx,rdx
  109065:	74 19                	je     109080 <__memcpy+0x20>
  109067:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  10906e:	00 00 
		dest[i] = src[i];
  109070:	0f b6 0c 06          	movzx  ecx,BYTE PTR [rsi+rax*1]
  109074:	88 0c 07             	mov    BYTE PTR [rdi+rax*1],cl
	for (size_t i = 0; i < size; i++) {
  109077:	48 83 c0 01          	add    rax,0x1
  10907b:	48 39 c2             	cmp    rdx,rax
  10907e:	75 f0                	jne    109070 <__memcpy+0x10>
  109080:	f3 c3                	repz ret 
  109082:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  109086:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10908d:	00 00 00 

0000000000109090 <is_char_alpha>:
  return 1;
}


int is_char_alpha(char c) {
	if ((c >= 'A' && c <= 'Z') ||
  109090:	83 e7 df             	and    edi,0xffffffdf
  109093:	31 c0                	xor    eax,eax
  109095:	83 ef 41             	sub    edi,0x41
  109098:	40 80 ff 19          	cmp    dil,0x19
  10909c:	0f 96 c0             	setbe  al
			(c >= 'a' && c <= 'z')) {
		return 1;
	}

	return 0;
}
  10909f:	c3                   	ret    

00000000001090a0 <kgfx_draw_character>:
  }
}

#else
void kgfx_draw_character(char c, size_t x_orign, size_t y_origin, Framebuffer *fb) {
  const uint8_t *character_data = &INCONSOLATA16[(c - ' ') * 256];
  1090a0:	40 0f be c7          	movsx  eax,dil
void kgfx_draw_character(char c, size_t x_orign, size_t y_origin, Framebuffer *fb) {
  1090a4:	53                   	push   rbx
  1090a5:	4c 8d 56 10          	lea    r10,[rsi+0x10]
  const uint8_t *character_data = &INCONSOLATA16[(c - ' ') * 256];
  1090a9:	83 e8 20             	sub    eax,0x20
  1090ac:	c1 e0 08             	shl    eax,0x8
  1090af:	48 98                	cdqe   
  1090b1:	48 05 80 20 10 00    	add    rax,0x102080
  1090b7:	49 89 c1             	mov    r9,rax
  1090ba:	49 29 f1             	sub    r9,rsi
  1090bd:	49 8d 99 00 01 00 00 	lea    rbx,[r9+0x100]
  1090c4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
void kgfx_draw_character(char c, size_t x_orign, size_t y_origin, Framebuffer *fb) {
  1090c8:	48 89 f0             	mov    rax,rsi
  1090cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  for(size_t i = 0; i < 16; i++){
    for(size_t j = 0; j < 16; j++){
      size_t char_index = j + i*16; 
      if(character_data[char_index] > 0){
  1090d0:	41 80 3c 01 00       	cmp    BYTE PTR [r9+rax*1],0x0
  1090d5:	74 36                	je     10910d <kgfx_draw_character+0x6d>
        size_t fb_index = ((j+x_orign)*fb->depth) + ((i+y_origin)*fb->pitch);
  1090d7:	0f b6 79 0c          	movzx  edi,BYTE PTR [rcx+0xc]
  1090db:	48 0f af f8          	imul   rdi,rax
  1090df:	49 89 f8             	mov    r8,rdi
  1090e2:	8b 79 08             	mov    edi,DWORD PTR [rcx+0x8]
  1090e5:	48 0f af fa          	imul   rdi,rdx
  1090e9:	4c 01 c7             	add    rdi,r8
        fb->buffer[fb_index + 0] = 0x00;
  1090ec:	4c 8b 41 10          	mov    r8,QWORD PTR [rcx+0x10]
  1090f0:	41 c6 04 38 00       	mov    BYTE PTR [r8+rdi*1],0x0
        fb->buffer[fb_index + 1] = character_data[char_index];
  1090f5:	45 0f b6 1c 01       	movzx  r11d,BYTE PTR [r9+rax*1]
  1090fa:	4c 8b 41 10          	mov    r8,QWORD PTR [rcx+0x10]
  1090fe:	45 88 5c 38 01       	mov    BYTE PTR [r8+rdi*1+0x1],r11b
        fb->buffer[fb_index + 2] = 0x00;
  109103:	4c 8b 41 10          	mov    r8,QWORD PTR [rcx+0x10]
  109107:	41 c6 44 38 02 00    	mov    BYTE PTR [r8+rdi*1+0x2],0x0
  10910d:	48 83 c0 01          	add    rax,0x1
    for(size_t j = 0; j < 16; j++){
  109111:	4c 39 d0             	cmp    rax,r10
  109114:	75 ba                	jne    1090d0 <kgfx_draw_character+0x30>
  109116:	49 83 c1 10          	add    r9,0x10
  10911a:	48 83 c2 01          	add    rdx,0x1
  for(size_t i = 0; i < 16; i++){
  10911e:	49 39 d9             	cmp    r9,rbx
  109121:	75 a5                	jne    1090c8 <kgfx_draw_character+0x28>
      }
    }
  }
}
  109123:	5b                   	pop    rbx
  109124:	c3                   	ret    
  109125:	90                   	nop
  109126:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10912d:	00 00 00 

0000000000109130 <kgfx_clear_framebuffer>:
#endif

void kgfx_clear_framebuffer(Framebuffer *fb){
  size_t step_count = (fb->width * fb->height * fb->depth) / 16;
  109130:	8b 37                	mov    esi,DWORD PTR [rdi]
  109132:	0f b6 47 0c          	movzx  eax,BYTE PTR [rdi+0xc]
  109136:	0f af 77 04          	imul   esi,DWORD PTR [rdi+0x4]
  __m128i *write_ptr = (__m128i *)fb->buffer; 
  10913a:	48 8b 57 10          	mov    rdx,QWORD PTR [rdi+0x10]
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_si128 (__m128i *__P, __m128i __B)
{
  *__P = __B;
  10913e:	66 0f ef c0          	pxor   xmm0,xmm0
  size_t step_count = (fb->width * fb->height * fb->depth) / 16;
  109142:	0f af f0             	imul   esi,eax
  __m128i clear_value = _mm_setzero_si128();
  for(size_t i = 0; i < step_count; i++){
  109145:	31 c0                	xor    eax,eax
  size_t step_count = (fb->width * fb->height * fb->depth) / 16;
  109147:	c1 ee 04             	shr    esi,0x4
  for(size_t i = 0; i < step_count; i++){
  10914a:	85 f6                	test   esi,esi
  size_t step_count = (fb->width * fb->height * fb->depth) / 16;
  10914c:	89 f1                	mov    ecx,esi
  for(size_t i = 0; i < step_count; i++){
  10914e:	74 11                	je     109161 <kgfx_clear_framebuffer+0x31>
  109150:	48 83 c0 01          	add    rax,0x1
  109154:	48 83 c2 10          	add    rdx,0x10
  109158:	0f 29 42 f0          	movaps XMMWORD PTR [rdx-0x10],xmm0
  10915c:	48 39 c1             	cmp    rcx,rax
  10915f:	75 ef                	jne    109150 <kgfx_clear_framebuffer+0x20>
  109161:	f3 c3                	repz ret 
  109163:	0f 1f 00             	nop    DWORD PTR [rax]
  109166:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10916d:	00 00 00 

0000000000109170 <kgfx_draw_log_if_dirty>:
  }
}
#endif

void kgfx_draw_log_if_dirty(Circular_Log *log){
  if(log->is_dirty == false) return;
  109170:	80 bf 24 05 01 00 00 	cmp    BYTE PTR [rdi+0x10524],0x0
  109177:	0f 84 33 01 00 00    	je     1092b0 <kgfx_draw_log_if_dirty+0x140>
  log->is_dirty = false;

  if(globals.framebuffer.buffer != 0){
  10917d:	48 83 3d f3 76 01 00 	cmp    QWORD PTR [rip+0x176f3],0x0        # 120878 <globals+0x10718>
  109184:	00 
  log->is_dirty = false;
  109185:	c6 87 24 05 01 00 00 	mov    BYTE PTR [rdi+0x10524],0x0
  if(globals.framebuffer.buffer != 0){
  10918c:	0f 84 20 01 00 00    	je     1092b2 <kgfx_draw_log_if_dirty+0x142>
void kgfx_draw_log_if_dirty(Circular_Log *log){
  109192:	41 57                	push   r15
  109194:	41 56                	push   r14
    static const uint32_t FONT_SIZE = 16;
    static const uint32_t ROW_SPACING = 0;
    static const uint32_t CHARACTER_SPACING = 10;
    Framebuffer *fb = &globals.framebuffer;
    //kgfx_clear_framebuffer(fb);
    const uint32_t total_column_count = fb->width / CHARACTER_SPACING;
  109196:	ba cd cc cc cc       	mov    edx,0xcccccccd
void kgfx_draw_log_if_dirty(Circular_Log *log){
  10919b:	41 55                	push   r13
  10919d:	41 54                	push   r12
    const uint32_t total_column_count = fb->width / CHARACTER_SPACING;
  10919f:	89 d0                	mov    eax,edx
void kgfx_draw_log_if_dirty(Circular_Log *log){
  1091a1:	55                   	push   rbp
  1091a2:	53                   	push   rbx
  1091a3:	49 89 fd             	mov    r13,rdi
  1091a6:	48 83 ec 08          	sub    rsp,0x8
    const uint32_t total_column_count = fb->width / CHARACTER_SPACING;
  1091aa:	f7 25 b8 76 01 00    	mul    DWORD PTR [rip+0x176b8]        # 120868 <globals+0x10708>
    const uint32_t max_row_count = fb->height / (FONT_SIZE + ROW_SPACING);
  1091b0:	8b 05 b6 76 01 00    	mov    eax,DWORD PTR [rip+0x176b6]        # 12086c <globals+0x1070c>
  1091b6:	c1 e8 04             	shr    eax,0x4
    const uint32_t total_lines_to_draw = min(log->current_entry_count, max_row_count - 1); 
  1091b9:	44 8d 70 ff          	lea    r14d,[rax-0x1]
    const uint32_t max_row_count = fb->height / (FONT_SIZE + ROW_SPACING);
  1091bd:	89 44 24 04          	mov    DWORD PTR [rsp+0x4],eax
    const uint32_t total_lines_to_draw = min(log->current_entry_count, max_row_count - 1); 
  1091c1:	48 8b 87 08 04 01 00 	mov    rax,QWORD PTR [rdi+0x10408]
    const uint32_t total_column_count = fb->width / CHARACTER_SPACING;
  1091c8:	c1 ea 03             	shr    edx,0x3
  1091cb:	89 14 24             	mov    DWORD PTR [rsp],edx
    const uint32_t total_lines_to_draw = min(log->current_entry_count, max_row_count - 1); 
  1091ce:	49 39 c6             	cmp    r14,rax
  1091d1:	4c 0f 47 f0          	cmova  r14,rax
    for(size_t i = 0; i < total_lines_to_draw; i++){
  1091d5:	31 ed                	xor    ebp,ebp
  1091d7:	4d 85 f6             	test   r14,r14
  1091da:	74 70                	je     10924c <kgfx_draw_log_if_dirty+0xdc>
  1091dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
      size_t entry_offset = total_lines_to_draw - i; 
      size_t entry_index = (log->entry_write_position - entry_offset - log->scroll_offset) % CIRCULAR_LOG_ENTRY_COUNT;
  1091e0:	49 8b 85 00 04 01 00 	mov    rax,QWORD PTR [r13+0x10400]
  1091e7:	4c 29 f0             	sub    rax,r14
  1091ea:	49 2b 85 10 04 01 00 	sub    rax,QWORD PTR [r13+0x10410]
  1091f1:	0f b6 c0             	movzx  eax,al
      Circular_Log_Entry *entry = &log->entries[entry_index];  
      size_t chars_to_write = min(entry->length, total_column_count);
  1091f4:	48 89 c2             	mov    rdx,rax
  1091f7:	48 c1 e2 06          	shl    rdx,0x6
  1091fb:	48 01 d0             	add    rax,rdx
  1091fe:	49 8d 5c 85 00       	lea    rbx,[r13+rax*4+0x0]
  109203:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  109206:	39 83 00 01 00 00    	cmp    DWORD PTR [rbx+0x100],eax
  10920c:	0f 46 83 00 01 00 00 	cmovbe eax,DWORD PTR [rbx+0x100]
      for(size_t j = 0; j < chars_to_write; j++){
  109213:	85 c0                	test   eax,eax
      size_t chars_to_write = min(entry->length, total_column_count);
  109215:	41 89 c4             	mov    r12d,eax
      for(size_t j = 0; j < chars_to_write; j++){
  109218:	74 28                	je     109242 <kgfx_draw_log_if_dirty+0xd2>
  10921a:	45 31 ff             	xor    r15d,r15d
  10921d:	0f 1f 00             	nop    DWORD PTR [rax]
        kgfx_draw_character(entry->message[j], j*CHARACTER_SPACING, i*(FONT_SIZE + ROW_SPACING), fb);
  109220:	42 0f be 3c 3b       	movsx  edi,BYTE PTR [rbx+r15*1]
  109225:	4b 8d 34 bf          	lea    rsi,[r15+r15*4]
  109229:	b9 68 08 12 00       	mov    ecx,0x120868
  10922e:	48 89 ea             	mov    rdx,rbp
      for(size_t j = 0; j < chars_to_write; j++){
  109231:	49 83 c7 01          	add    r15,0x1
        kgfx_draw_character(entry->message[j], j*CHARACTER_SPACING, i*(FONT_SIZE + ROW_SPACING), fb);
  109235:	48 01 f6             	add    rsi,rsi
  109238:	e8 63 fe ff ff       	call   1090a0 <kgfx_draw_character>
      for(size_t j = 0; j < chars_to_write; j++){
  10923d:	4d 39 fc             	cmp    r12,r15
  109240:	75 de                	jne    109220 <kgfx_draw_log_if_dirty+0xb0>
  109242:	48 83 c5 10          	add    rbp,0x10
    for(size_t i = 0; i < total_lines_to_draw; i++){
  109246:	49 83 ee 01          	sub    r14,0x1
  10924a:	75 94                	jne    1091e0 <kgfx_draw_log_if_dirty+0x70>
      }
    }

    size_t input_buffer_to_write = min(total_column_count, log->input_buffer_count);
  10924c:	8b 04 24             	mov    eax,DWORD PTR [rsp]
  10924f:	49 39 85 18 05 01 00 	cmp    QWORD PTR [r13+0x10518],rax
  109256:	49 0f 46 85 18 05 01 	cmovbe rax,QWORD PTR [r13+0x10518]
  10925d:	00 
    for(size_t i = 0; i < input_buffer_to_write; i++){
  10925e:	48 85 c0             	test   rax,rax
  109261:	74 3f                	je     1092a2 <kgfx_draw_log_if_dirty+0x132>
  109263:	8b 6c 24 04          	mov    ebp,DWORD PTR [rsp+0x4]
  109267:	4c 8d 24 80          	lea    r12,[rax+rax*4]
  10926b:	49 81 c5 18 04 01 00 	add    r13,0x10418
  109272:	31 db                	xor    ebx,ebx
  109274:	4d 01 e4             	add    r12,r12
  109277:	81 c5 ff ff ff 0f    	add    ebp,0xfffffff
  10927d:	c1 e5 04             	shl    ebp,0x4
      kgfx_draw_character(log->input_buffer[i], i*CHARACTER_SPACING, (FONT_SIZE+ROW_SPACING)*(max_row_count - 1), fb); 
  109280:	41 0f be 7d 00       	movsx  edi,BYTE PTR [r13+0x0]
  109285:	48 89 de             	mov    rsi,rbx
  109288:	b9 68 08 12 00       	mov    ecx,0x120868
  10928d:	48 89 ea             	mov    rdx,rbp
  109290:	48 83 c3 0a          	add    rbx,0xa
  109294:	49 83 c5 01          	add    r13,0x1
  109298:	e8 03 fe ff ff       	call   1090a0 <kgfx_draw_character>
    for(size_t i = 0; i < input_buffer_to_write; i++){
  10929d:	49 39 dc             	cmp    r12,rbx
  1092a0:	75 de                	jne    109280 <kgfx_draw_log_if_dirty+0x110>
    }

  } else {
    draw_vga_text_terminal(log);
  }
  1092a2:	48 83 c4 08          	add    rsp,0x8
  1092a6:	5b                   	pop    rbx
  1092a7:	5d                   	pop    rbp
  1092a8:	41 5c                	pop    r12
  1092aa:	41 5d                	pop    r13
  1092ac:	41 5e                	pop    r14
  1092ae:	41 5f                	pop    r15
  1092b0:	f3 c3                	repz ret 
  1092b2:	31 c0                	xor    eax,eax
		dest[i] = value;
  1092b4:	c6 80 00 80 0b 00 00 	mov    BYTE PTR [rax+0xb8000],0x0
  for (size_t i = 0; i < size; i++) {
  1092bb:	48 83 c0 01          	add    rax,0x1
  1092bf:	48 3d a0 0f 00 00    	cmp    rax,0xfa0
  1092c5:	75 ed                	jne    1092b4 <kgfx_draw_log_if_dirty+0x144>
  size_t entries_to_draw = min((uint32_t)(VGA_TEXT_ROW_COUNT - 1), (uint32_t)log->current_entry_count);
  1092c7:	48 8b 87 08 04 01 00 	mov    rax,QWORD PTR [rdi+0x10408]
  1092ce:	ba 18 00 00 00       	mov    edx,0x18
    size_t chars_to_write = min(entry->length, VGA_TEXT_COLUMN_COUNT);
  1092d3:	41 bb 50 00 00 00    	mov    r11d,0x50
  size_t entries_to_draw = min((uint32_t)(VGA_TEXT_ROW_COUNT - 1), (uint32_t)log->current_entry_count);
  1092d9:	83 f8 18             	cmp    eax,0x18
  1092dc:	0f 47 c2             	cmova  eax,edx
  for(size_t i = 0; i < entries_to_draw; i++){
  1092df:	45 31 d2             	xor    r10d,r10d
  1092e2:	85 c0                	test   eax,eax
  size_t entries_to_draw = min((uint32_t)(VGA_TEXT_ROW_COUNT - 1), (uint32_t)log->current_entry_count);
  1092e4:	41 89 c1             	mov    r9d,eax
  for(size_t i = 0; i < entries_to_draw; i++){
  1092e7:	74 6d                	je     109356 <kgfx_draw_log_if_dirty+0x1e6>
    size_t entry_index = (log->entry_write_position - entry_offset - log->scroll_offset) % CIRCULAR_LOG_ENTRY_COUNT;
  1092e9:	48 8b 87 00 04 01 00 	mov    rax,QWORD PTR [rdi+0x10400]
  1092f0:	4c 29 c8             	sub    rax,r9
  1092f3:	48 2b 87 10 04 01 00 	sub    rax,QWORD PTR [rdi+0x10410]
  1092fa:	0f b6 c0             	movzx  eax,al
    size_t chars_to_write = min(entry->length, VGA_TEXT_COLUMN_COUNT);
  1092fd:	48 89 c2             	mov    rdx,rax
  109300:	48 c1 e2 06          	shl    rdx,0x6
  109304:	48 01 d0             	add    rax,rdx
  109307:	48 8d 34 87          	lea    rsi,[rdi+rax*4]
  10930b:	44 89 d8             	mov    eax,r11d
  10930e:	83 be 00 01 00 00 50 	cmp    DWORD PTR [rsi+0x100],0x50
  109315:	0f 46 86 00 01 00 00 	cmovbe eax,DWORD PTR [rsi+0x100]
    for(size_t j = 0; j < chars_to_write; j++){
  10931c:	85 c0                	test   eax,eax
    size_t chars_to_write = min(entry->length, VGA_TEXT_COLUMN_COUNT);
  10931e:	41 89 c0             	mov    r8d,eax
    for(size_t j = 0; j < chars_to_write; j++){
  109321:	74 29                	je     10934c <kgfx_draw_log_if_dirty+0x1dc>
  109323:	43 8d 14 12          	lea    edx,[r10+r10*1]
  109327:	31 c0                	xor    eax,eax
  109329:	48 63 d2             	movsxd rdx,edx
  10932c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  VGA_TEXT_BUFFER[vga_index+0] = c;
  109330:	0f b6 0c 06          	movzx  ecx,BYTE PTR [rsi+rax*1]
  VGA_TEXT_BUFFER[vga_index+1] = color;
  109334:	c6 84 42 01 80 0b 00 	mov    BYTE PTR [rdx+rax*2+0xb8001],0x2
  10933b:	02 
  VGA_TEXT_BUFFER[vga_index+0] = c;
  10933c:	88 8c 42 00 80 0b 00 	mov    BYTE PTR [rdx+rax*2+0xb8000],cl
    for(size_t j = 0; j < chars_to_write; j++){
  109343:	48 83 c0 01          	add    rax,0x1
  109347:	49 39 c0             	cmp    r8,rax
  10934a:	75 e4                	jne    109330 <kgfx_draw_log_if_dirty+0x1c0>
  10934c:	41 83 c2 50          	add    r10d,0x50
  for(size_t i = 0; i < entries_to_draw; i++){
  109350:	49 83 e9 01          	sub    r9,0x1
  109354:	75 93                	jne    1092e9 <kgfx_draw_log_if_dirty+0x179>
  size_t input_buffer_to_write = min(VGA_TEXT_COLUMN_COUNT, log->input_buffer_count);
  109356:	48 83 bf 18 05 01 00 	cmp    QWORD PTR [rdi+0x10518],0x50
  10935d:	50 
  10935e:	b9 50 00 00 00       	mov    ecx,0x50
  109363:	48 0f 46 8f 18 05 01 	cmovbe rcx,QWORD PTR [rdi+0x10518]
  10936a:	00 
  for(size_t i = 0; i < input_buffer_to_write; i++){
  10936b:	48 85 c9             	test   rcx,rcx
  10936e:	74 24                	je     109394 <kgfx_draw_log_if_dirty+0x224>
  109370:	31 c0                	xor    eax,eax
  VGA_TEXT_BUFFER[vga_index+0] = c;
  109372:	0f b6 94 07 18 04 01 	movzx  edx,BYTE PTR [rdi+rax*1+0x10418]
  109379:	00 
  VGA_TEXT_BUFFER[vga_index+1] = color;
  10937a:	c6 84 00 01 8f 0b 00 	mov    BYTE PTR [rax+rax*1+0xb8f01],0x4
  109381:	04 
  VGA_TEXT_BUFFER[vga_index+0] = c;
  109382:	88 94 00 00 8f 0b 00 	mov    BYTE PTR [rax+rax*1+0xb8f00],dl
  for(size_t i = 0; i < input_buffer_to_write; i++){
  109389:	48 83 c0 01          	add    rax,0x1
  10938d:	48 39 c1             	cmp    rcx,rax
  109390:	75 e0                	jne    109372 <kgfx_draw_log_if_dirty+0x202>
  109392:	f3 c3                	repz ret 
  109394:	c3                   	ret    
  109395:	90                   	nop
  109396:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10939d:	00 00 00 

00000000001093a0 <ehci_control_transaction>:
    return -1;
  }
  return 1;
}

void ehci_control_transaction(){
  1093a0:	f3 c3                	repz ret 
  1093a2:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  1093a6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  1093ad:	00 00 00 

00000000001093b0 <serial_debug_init>:
	asm volatile ("cli"); \
	asm volatile ("hlt")

static inline 
void write_port_uint8(uint16_t port, uint8_t value) {
	asm volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
  1093b0:	ba f9 03 00 00       	mov    edx,0x3f9
  1093b5:	31 c0                	xor    eax,eax
  1093b7:	ee                   	out    dx,al
  1093b8:	ba fb 03 00 00       	mov    edx,0x3fb
  1093bd:	b8 80 ff ff ff       	mov    eax,0xffffff80
  1093c2:	ee                   	out    dx,al
  1093c3:	ba f8 03 00 00       	mov    edx,0x3f8
  1093c8:	b8 01 00 00 00       	mov    eax,0x1
  1093cd:	ee                   	out    dx,al
  1093ce:	ba f9 03 00 00       	mov    edx,0x3f9
  1093d3:	31 c0                	xor    eax,eax
  1093d5:	ee                   	out    dx,al
  1093d6:	ba fb 03 00 00       	mov    edx,0x3fb
  1093db:	b8 03 00 00 00       	mov    eax,0x3
  1093e0:	ee                   	out    dx,al
  1093e1:	ba fa 03 00 00       	mov    edx,0x3fa
  1093e6:	b8 c7 ff ff ff       	mov    eax,0xffffffc7
  1093eb:	ee                   	out    dx,al
  1093ec:	ba fc 03 00 00       	mov    edx,0x3fc
  1093f1:	b8 0b 00 00 00       	mov    eax,0xb
  1093f6:	ee                   	out    dx,al
  1093f7:	c3                   	ret    
  1093f8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  1093ff:	00 

0000000000109400 <is_transmit_empty>:


static inline
uint8_t read_port_uint8(uint16_t port) {
	uint8_t result;
	asm volatile ("inb %1, %0" : "=a"(result) : "Nd"(port));
  109400:	ba fd 03 00 00       	mov    edx,0x3fd
  109405:	ec                   	in     al,dx
   write_port_uint8(PORT + 2, 0xC7);    // Enable FIFO, clear them, with 14-byte threshold
   write_port_uint8(PORT + 4, 0x0B);    // IRQs enabled, RTS/DSR set
}

int is_transmit_empty() {
   return read_port_uint8(PORT + 5) & 0x20;
  109406:	83 e0 20             	and    eax,0x20
  109409:	0f b6 c0             	movzx  eax,al
}
  10940c:	c3                   	ret    
  10940d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000109410 <write_serial>:
   write_port(PORT,a);
}
#endif

void write_serial(const char *src, size_t length){
  for(size_t i = 0; i < length; i++){
  109410:	48 85 f6             	test   rsi,rsi
  109413:	74 2a                	je     10943f <write_serial+0x2f>
  109415:	48 01 fe             	add    rsi,rdi
  109418:	b9 fd 03 00 00       	mov    ecx,0x3fd
	asm volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
  10941d:	41 b8 f8 03 00 00    	mov    r8d,0x3f8
  109423:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	asm volatile ("inb %1, %0" : "=a"(result) : "Nd"(port));
  109428:	89 ca                	mov    edx,ecx
  10942a:	ec                   	in     al,dx
    while(is_transmit_empty() == 0) {}
  10942b:	a8 20                	test   al,0x20
  10942d:	74 f9                	je     109428 <write_serial+0x18>
	asm volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
  10942f:	0f b6 07             	movzx  eax,BYTE PTR [rdi]
  109432:	44 89 c2             	mov    edx,r8d
  109435:	ee                   	out    dx,al
  109436:	48 83 c7 01          	add    rdi,0x1
  for(size_t i = 0; i < length; i++){
  10943a:	48 39 f7             	cmp    rdi,rsi
  10943d:	75 e9                	jne    109428 <write_serial+0x18>
  10943f:	f3 c3                	repz ret 
  109441:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  109446:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10944d:	00 00 00 

0000000000109450 <kmem_initalize>:
  kmem_map_physical_to_virtual_2MB_ext(physical_address_to_map, virtual_address, flags);
  return displacement_from_page_boundray;
}

void kmem_initalize(){
  g_p2_table.entries[1] = (uintptr_t)&g_p1_table.entries[0] | PAGE_WRITEABLE_BIT | PAGE_PRESENT_BIT;
  109450:	b8 00 d0 10 00       	mov    eax,0x10d000
  109455:	48 83 c8 03          	or     rax,0x3
  109459:	48 89 05 a8 ab 01 00 	mov    QWORD PTR [rip+0x1aba8],rax        # 124008 <g_p2_table+0x8>
  109460:	c3                   	ret    
  109461:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  109466:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10946d:	00 00 00 

0000000000109470 <ap_entry_procedure>:
#include "hardware_serial.c"
#include "kernel_memory.c"

extern void
ap_entry_procedure(void){
  asm volatile("hlt");
  109470:	f4                   	hlt    
  109471:	c3                   	ret    
  109472:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  109476:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10947d:	00 00 00 

0000000000109480 <dw_get_tag_string>:
else if (attrib_value == value) { \
  return #attrib_name; \
}

const char *dw_get_tag_string(uint32_t value) {
  if (0) {} DW_TAG_META_LIST
  109480:	83 ff 01             	cmp    edi,0x1
  109483:	0f 84 47 02 00 00    	je     1096d0 <dw_get_tag_string+0x250>
  109489:	83 ff 02             	cmp    edi,0x2
  10948c:	0f 84 4e 02 00 00    	je     1096e0 <dw_get_tag_string+0x260>
  109492:	83 ff 03             	cmp    edi,0x3
  109495:	0f 84 55 02 00 00    	je     1096f0 <dw_get_tag_string+0x270>
  10949b:	83 ff 04             	cmp    edi,0x4
  10949e:	0f 84 1c 02 00 00    	je     1096c0 <dw_get_tag_string+0x240>
  1094a4:	83 ff 05             	cmp    edi,0x5
  1094a7:	0f 84 53 02 00 00    	je     109700 <dw_get_tag_string+0x280>
  1094ad:	83 ff 08             	cmp    edi,0x8
  1094b0:	0f 84 5a 02 00 00    	je     109710 <dw_get_tag_string+0x290>
  1094b6:	83 ff 0a             	cmp    edi,0xa
  1094b9:	0f 84 61 02 00 00    	je     109720 <dw_get_tag_string+0x2a0>
  1094bf:	83 ff 0b             	cmp    edi,0xb
  1094c2:	0f 84 68 02 00 00    	je     109730 <dw_get_tag_string+0x2b0>
  1094c8:	83 ff 0d             	cmp    edi,0xd
  1094cb:	0f 84 7f 02 00 00    	je     109750 <dw_get_tag_string+0x2d0>
  1094d1:	83 ff 0f             	cmp    edi,0xf
  1094d4:	0f 84 86 02 00 00    	je     109760 <dw_get_tag_string+0x2e0>
  1094da:	83 ff 10             	cmp    edi,0x10
  1094dd:	0f 84 8d 02 00 00    	je     109770 <dw_get_tag_string+0x2f0>
  1094e3:	83 ff 11             	cmp    edi,0x11
  1094e6:	0f 84 94 02 00 00    	je     109780 <dw_get_tag_string+0x300>
  1094ec:	83 ff 12             	cmp    edi,0x12
  1094ef:	0f 84 9b 02 00 00    	je     109790 <dw_get_tag_string+0x310>
  1094f5:	83 ff 13             	cmp    edi,0x13
  1094f8:	0f 84 42 02 00 00    	je     109740 <dw_get_tag_string+0x2c0>
  1094fe:	83 ff 15             	cmp    edi,0x15
  109501:	0f 84 8f 02 00 00    	je     109796 <dw_get_tag_string+0x316>
  109507:	83 ff 16             	cmp    edi,0x16
  10950a:	0f 84 8c 02 00 00    	je     10979c <dw_get_tag_string+0x31c>
  109510:	83 ff 17             	cmp    edi,0x17
  109513:	0f 84 89 02 00 00    	je     1097a2 <dw_get_tag_string+0x322>
  109519:	83 ff 18             	cmp    edi,0x18
  10951c:	0f 84 86 02 00 00    	je     1097a8 <dw_get_tag_string+0x328>
  109522:	83 ff 19             	cmp    edi,0x19
  109525:	0f 84 83 02 00 00    	je     1097ae <dw_get_tag_string+0x32e>
  10952b:	83 ff 1a             	cmp    edi,0x1a
  10952e:	0f 84 80 02 00 00    	je     1097b4 <dw_get_tag_string+0x334>
  109534:	83 ff 1b             	cmp    edi,0x1b
  109537:	0f 84 7d 02 00 00    	je     1097ba <dw_get_tag_string+0x33a>
  10953d:	83 ff 1c             	cmp    edi,0x1c
  109540:	0f 84 7a 02 00 00    	je     1097c0 <dw_get_tag_string+0x340>
  109546:	83 ff 1d             	cmp    edi,0x1d
  109549:	0f 84 77 02 00 00    	je     1097c6 <dw_get_tag_string+0x346>
  10954f:	83 ff 1e             	cmp    edi,0x1e
  109552:	0f 84 74 02 00 00    	je     1097cc <dw_get_tag_string+0x34c>
  109558:	83 ff 1f             	cmp    edi,0x1f
  10955b:	0f 84 71 02 00 00    	je     1097d2 <dw_get_tag_string+0x352>
  109561:	83 ff 20             	cmp    edi,0x20
  109564:	0f 84 6e 02 00 00    	je     1097d8 <dw_get_tag_string+0x358>
  10956a:	83 ff 21             	cmp    edi,0x21
  10956d:	0f 84 6b 02 00 00    	je     1097de <dw_get_tag_string+0x35e>
  109573:	83 ff 22             	cmp    edi,0x22
  109576:	0f 84 68 02 00 00    	je     1097e4 <dw_get_tag_string+0x364>
  10957c:	83 ff 23             	cmp    edi,0x23
  10957f:	0f 84 65 02 00 00    	je     1097ea <dw_get_tag_string+0x36a>
  109585:	83 ff 24             	cmp    edi,0x24
  109588:	0f 84 62 02 00 00    	je     1097f0 <dw_get_tag_string+0x370>
  10958e:	83 ff 25             	cmp    edi,0x25
  109591:	0f 84 5f 02 00 00    	je     1097f6 <dw_get_tag_string+0x376>
  109597:	83 ff 26             	cmp    edi,0x26
  10959a:	0f 84 5c 02 00 00    	je     1097fc <dw_get_tag_string+0x37c>
  1095a0:	83 ff 27             	cmp    edi,0x27
  1095a3:	0f 84 59 02 00 00    	je     109802 <dw_get_tag_string+0x382>
  1095a9:	83 ff 28             	cmp    edi,0x28
  1095ac:	0f 84 56 02 00 00    	je     109808 <dw_get_tag_string+0x388>
  1095b2:	83 ff 29             	cmp    edi,0x29
  1095b5:	0f 84 65 02 00 00    	je     109820 <dw_get_tag_string+0x3a0>
  1095bb:	83 ff 2a             	cmp    edi,0x2a
  1095be:	0f 84 56 02 00 00    	je     10981a <dw_get_tag_string+0x39a>
  1095c4:	83 ff 2b             	cmp    edi,0x2b
  1095c7:	0f 84 47 02 00 00    	je     109814 <dw_get_tag_string+0x394>
  1095cd:	83 ff 2c             	cmp    edi,0x2c
  1095d0:	0f 84 38 02 00 00    	je     10980e <dw_get_tag_string+0x38e>
  1095d6:	83 ff 2d             	cmp    edi,0x2d
  1095d9:	0f 84 cb 02 00 00    	je     1098aa <dw_get_tag_string+0x42a>
  1095df:	83 ff 2e             	cmp    edi,0x2e
  1095e2:	0f 84 bc 02 00 00    	je     1098a4 <dw_get_tag_string+0x424>
  1095e8:	83 ff 2f             	cmp    edi,0x2f
  1095eb:	0f 84 ad 02 00 00    	je     10989e <dw_get_tag_string+0x41e>
  1095f1:	83 ff 30             	cmp    edi,0x30
  1095f4:	0f 84 9e 02 00 00    	je     109898 <dw_get_tag_string+0x418>
  1095fa:	83 ff 31             	cmp    edi,0x31
  1095fd:	0f 84 8f 02 00 00    	je     109892 <dw_get_tag_string+0x412>
  109603:	83 ff 32             	cmp    edi,0x32
  109606:	0f 84 80 02 00 00    	je     10988c <dw_get_tag_string+0x40c>
  10960c:	83 ff 33             	cmp    edi,0x33
  10960f:	0f 84 71 02 00 00    	je     109886 <dw_get_tag_string+0x406>
  109615:	83 ff 34             	cmp    edi,0x34
  109618:	0f 84 62 02 00 00    	je     109880 <dw_get_tag_string+0x400>
  10961e:	83 ff 35             	cmp    edi,0x35
  109621:	0f 84 53 02 00 00    	je     10987a <dw_get_tag_string+0x3fa>
  109627:	83 ff 36             	cmp    edi,0x36
  10962a:	0f 84 44 02 00 00    	je     109874 <dw_get_tag_string+0x3f4>
  109630:	83 ff 37             	cmp    edi,0x37
  109633:	0f 84 35 02 00 00    	je     10986e <dw_get_tag_string+0x3ee>
  109639:	83 ff 38             	cmp    edi,0x38
  10963c:	0f 84 26 02 00 00    	je     109868 <dw_get_tag_string+0x3e8>
  109642:	83 ff 39             	cmp    edi,0x39
  109645:	0f 84 17 02 00 00    	je     109862 <dw_get_tag_string+0x3e2>
  10964b:	83 ff 3a             	cmp    edi,0x3a
  10964e:	0f 84 08 02 00 00    	je     10985c <dw_get_tag_string+0x3dc>
  109654:	83 ff 3b             	cmp    edi,0x3b
  109657:	0f 84 f9 01 00 00    	je     109856 <dw_get_tag_string+0x3d6>
  10965d:	83 ff 3c             	cmp    edi,0x3c
  109660:	0f 84 ea 01 00 00    	je     109850 <dw_get_tag_string+0x3d0>
  109666:	83 ff 3d             	cmp    edi,0x3d
  109669:	0f 84 db 01 00 00    	je     10984a <dw_get_tag_string+0x3ca>
  10966f:	83 ff 3f             	cmp    edi,0x3f
  109672:	0f 84 cc 01 00 00    	je     109844 <dw_get_tag_string+0x3c4>
  109678:	83 ff 40             	cmp    edi,0x40
  10967b:	0f 84 bd 01 00 00    	je     10983e <dw_get_tag_string+0x3be>
  109681:	83 ff 41             	cmp    edi,0x41
  109684:	0f 84 ae 01 00 00    	je     109838 <dw_get_tag_string+0x3b8>
  10968a:	83 ff 42             	cmp    edi,0x42
  10968d:	0f 84 9f 01 00 00    	je     109832 <dw_get_tag_string+0x3b2>
  109693:	83 ff 43             	cmp    edi,0x43
  109696:	0f 84 90 01 00 00    	je     10982c <dw_get_tag_string+0x3ac>
  10969c:	81 ff 80 40 00 00    	cmp    edi,0x4080
  1096a2:	0f 84 7e 01 00 00    	je     109826 <dw_get_tag_string+0x3a6>
  else { return "INVALID!!!"; }
  1096a8:	81 ff ff ff 00 00    	cmp    edi,0xffff
  1096ae:	ba cb 04 10 00       	mov    edx,0x1004cb
  1096b3:	b8 bc 04 10 00       	mov    eax,0x1004bc
  1096b8:	48 0f 45 c2          	cmovne rax,rdx
  1096bc:	c3                   	ret    
  1096bd:	0f 1f 00             	nop    DWORD PTR [rax]
  if (0) {} DW_TAG_META_LIST
  1096c0:	b8 63 00 10 00       	mov    eax,0x100063
  1096c5:	c3                   	ret    
  1096c6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  1096cd:	00 00 00 
  1096d0:	b8 2c 00 10 00       	mov    eax,0x10002c
  1096d5:	c3                   	ret    
  1096d6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  1096dd:	00 00 00 
  1096e0:	b8 3e 00 10 00       	mov    eax,0x10003e
  1096e5:	c3                   	ret    
  1096e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  1096ed:	00 00 00 
  1096f0:	b8 50 00 10 00       	mov    eax,0x100050
  1096f5:	c3                   	ret    
  1096f6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  1096fd:	00 00 00 
  109700:	b8 7b 00 10 00       	mov    eax,0x10007b
  109705:	c3                   	ret    
  109706:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10970d:	00 00 00 
  109710:	b8 93 00 10 00       	mov    eax,0x100093
  109715:	c3                   	ret    
  109716:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10971d:	00 00 00 
  109720:	b8 af 00 10 00       	mov    eax,0x1000af
  109725:	c3                   	ret    
  109726:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10972d:	00 00 00 
  109730:	b8 bc 00 10 00       	mov    eax,0x1000bc
  109735:	c3                   	ret    
  109736:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10973d:	00 00 00 
  109740:	b8 30 01 10 00       	mov    eax,0x100130
  109745:	c3                   	ret    
  109746:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10974d:	00 00 00 
  109750:	b8 d1 00 10 00       	mov    eax,0x1000d1
  109755:	c3                   	ret    
  109756:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10975d:	00 00 00 
  109760:	b8 df 00 10 00       	mov    eax,0x1000df
  109765:	c3                   	ret    
  109766:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10976d:	00 00 00 
  109770:	b8 f3 00 10 00       	mov    eax,0x1000f3
  109775:	c3                   	ret    
  109776:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10977d:	00 00 00 
  109780:	b8 09 01 10 00       	mov    eax,0x100109
  109785:	c3                   	ret    
  109786:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10978d:	00 00 00 
  109790:	b8 1d 01 10 00       	mov    eax,0x10011d
  109795:	c3                   	ret    
  109796:	b8 46 01 10 00       	mov    eax,0x100146
  10979b:	c3                   	ret    
  10979c:	b8 5d 01 10 00       	mov    eax,0x10015d
  1097a1:	c3                   	ret    
  1097a2:	b8 6c 01 10 00       	mov    eax,0x10016c
  1097a7:	c3                   	ret    
  1097a8:	b8 7e 01 10 00       	mov    eax,0x10017e
  1097ad:	c3                   	ret    
  1097ae:	b8 9c 01 10 00       	mov    eax,0x10019c
  1097b3:	c3                   	ret    
  1097b4:	b8 ab 01 10 00       	mov    eax,0x1001ab
  1097b9:	c3                   	ret    
  1097ba:	b8 bf 01 10 00       	mov    eax,0x1001bf
  1097bf:	c3                   	ret    
  1097c0:	b8 d7 01 10 00       	mov    eax,0x1001d7
  1097c5:	c3                   	ret    
  1097c6:	b8 ea 01 10 00       	mov    eax,0x1001ea
  1097cb:	c3                   	ret    
  1097cc:	b8 04 02 10 00       	mov    eax,0x100204
  1097d1:	c3                   	ret    
  1097d2:	b8 12 02 10 00       	mov    eax,0x100212
  1097d7:	c3                   	ret    
  1097d8:	b8 2c 02 10 00       	mov    eax,0x10022c
  1097dd:	c3                   	ret    
  1097de:	b8 3c 02 10 00       	mov    eax,0x10023c
  1097e3:	c3                   	ret    
  1097e4:	b8 51 02 10 00       	mov    eax,0x100251
  1097e9:	c3                   	ret    
  1097ea:	b8 62 02 10 00       	mov    eax,0x100262
  1097ef:	c3                   	ret    
  1097f0:	b8 7c 02 10 00       	mov    eax,0x10027c
  1097f5:	c3                   	ret    
  1097f6:	b8 8d 02 10 00       	mov    eax,0x10028d
  1097fb:	c3                   	ret    
  1097fc:	b8 a0 02 10 00       	mov    eax,0x1002a0
  109801:	c3                   	ret    
  109802:	b8 b2 02 10 00       	mov    eax,0x1002b2
  109807:	c3                   	ret    
  109808:	b8 c2 02 10 00       	mov    eax,0x1002c2
  10980d:	c3                   	ret    
  10980e:	b8 03 03 10 00       	mov    eax,0x100303
  109813:	c3                   	ret    
  109814:	b8 f3 02 10 00       	mov    eax,0x1002f3
  109819:	c3                   	ret    
  10981a:	b8 e5 02 10 00       	mov    eax,0x1002e5
  10981f:	c3                   	ret    
  109820:	b8 d4 02 10 00       	mov    eax,0x1002d4
  109825:	c3                   	ret    
  109826:	b8 ad 04 10 00       	mov    eax,0x1004ad
}
  10982b:	c3                   	ret    
  if (0) {} DW_TAG_META_LIST
  10982c:	b8 97 04 10 00       	mov    eax,0x100497
  109831:	c3                   	ret    
  109832:	b8 7a 04 10 00       	mov    eax,0x10047a
  109837:	c3                   	ret    
  109838:	b8 69 04 10 00       	mov    eax,0x100469
  10983d:	c3                   	ret    
  10983e:	b8 56 04 10 00       	mov    eax,0x100456
  109843:	c3                   	ret    
  109844:	b8 45 04 10 00       	mov    eax,0x100445
  109849:	c3                   	ret    
  10984a:	b8 30 04 10 00       	mov    eax,0x100430
  10984f:	c3                   	ret    
  109850:	b8 1c 04 10 00       	mov    eax,0x10041c
  109855:	c3                   	ret    
  109856:	b8 04 04 10 00       	mov    eax,0x100404
  10985b:	c3                   	ret    
  10985c:	b8 ed 03 10 00       	mov    eax,0x1003ed
  109861:	c3                   	ret    
  109862:	b8 dc 03 10 00       	mov    eax,0x1003dc
  109867:	c3                   	ret    
  109868:	b8 c6 03 10 00       	mov    eax,0x1003c6
  10986d:	c3                   	ret    
  10986e:	b8 b1 03 10 00       	mov    eax,0x1003b1
  109873:	c3                   	ret    
  109874:	b8 9a 03 10 00       	mov    eax,0x10039a
  109879:	c3                   	ret    
  10987a:	b8 85 03 10 00       	mov    eax,0x100385
  10987f:	c3                   	ret    
  109880:	b8 75 03 10 00       	mov    eax,0x100375
  109885:	c3                   	ret    
  109886:	b8 61 03 10 00       	mov    eax,0x100361
  10988b:	c3                   	ret    
  10988c:	b8 50 03 10 00       	mov    eax,0x100350
  109891:	c3                   	ret    
  109892:	b8 3d 03 10 00       	mov    eax,0x10033d
  109897:	c3                   	ret    
  109898:	b8 38 12 10 00       	mov    eax,0x101238
  10989d:	c3                   	ret    
  10989e:	b8 18 12 10 00       	mov    eax,0x101218
  1098a3:	c3                   	ret    
  1098a4:	b8 2b 03 10 00       	mov    eax,0x10032b
  1098a9:	c3                   	ret    
  1098aa:	b8 18 03 10 00       	mov    eax,0x100318
  1098af:	c3                   	ret    

00000000001098b0 <dw_get_attrib_string>:

const char *dw_get_attrib_string(uint32_t value) {
  if (0) {} DW_AT_META_LIST
  1098b0:	83 ff 01             	cmp    edi,0x1
  1098b3:	0f 84 67 03 00 00    	je     109c20 <dw_get_attrib_string+0x370>
  1098b9:	83 ff 02             	cmp    edi,0x2
  1098bc:	0f 84 6e 03 00 00    	je     109c30 <dw_get_attrib_string+0x380>
  1098c2:	83 ff 03             	cmp    edi,0x3
  1098c5:	0f 84 75 03 00 00    	je     109c40 <dw_get_attrib_string+0x390>
  1098cb:	83 ff 09             	cmp    edi,0x9
  1098ce:	0f 84 3c 03 00 00    	je     109c10 <dw_get_attrib_string+0x360>
  1098d4:	83 ff 0b             	cmp    edi,0xb
  1098d7:	0f 84 73 03 00 00    	je     109c50 <dw_get_attrib_string+0x3a0>
  1098dd:	83 ff 0c             	cmp    edi,0xc
  1098e0:	0f 84 7a 03 00 00    	je     109c60 <dw_get_attrib_string+0x3b0>
  1098e6:	83 ff 0d             	cmp    edi,0xd
  1098e9:	0f 84 81 03 00 00    	je     109c70 <dw_get_attrib_string+0x3c0>
  1098ef:	83 ff 10             	cmp    edi,0x10
  1098f2:	0f 84 88 03 00 00    	je     109c80 <dw_get_attrib_string+0x3d0>
  1098f8:	83 ff 11             	cmp    edi,0x11
  1098fb:	0f 84 9f 03 00 00    	je     109ca0 <dw_get_attrib_string+0x3f0>
  109901:	83 ff 12             	cmp    edi,0x12
  109904:	0f 84 a6 03 00 00    	je     109cb0 <dw_get_attrib_string+0x400>
  10990a:	83 ff 13             	cmp    edi,0x13
  10990d:	0f 84 ad 03 00 00    	je     109cc0 <dw_get_attrib_string+0x410>
  109913:	83 ff 15             	cmp    edi,0x15
  109916:	0f 84 b4 03 00 00    	je     109cd0 <dw_get_attrib_string+0x420>
  10991c:	83 ff 16             	cmp    edi,0x16
  10991f:	0f 84 bb 03 00 00    	je     109ce0 <dw_get_attrib_string+0x430>
  109925:	83 ff 17             	cmp    edi,0x17
  109928:	0f 84 62 03 00 00    	je     109c90 <dw_get_attrib_string+0x3e0>
  10992e:	83 ff 18             	cmp    edi,0x18
  109931:	0f 84 af 03 00 00    	je     109ce6 <dw_get_attrib_string+0x436>
  109937:	83 ff 19             	cmp    edi,0x19
  10993a:	0f 84 ac 03 00 00    	je     109cec <dw_get_attrib_string+0x43c>
  109940:	83 ff 1a             	cmp    edi,0x1a
  109943:	0f 84 a9 03 00 00    	je     109cf2 <dw_get_attrib_string+0x442>
  109949:	83 ff 1b             	cmp    edi,0x1b
  10994c:	0f 84 a6 03 00 00    	je     109cf8 <dw_get_attrib_string+0x448>
  109952:	83 ff 1c             	cmp    edi,0x1c
  109955:	0f 84 a3 03 00 00    	je     109cfe <dw_get_attrib_string+0x44e>
  10995b:	83 ff 1d             	cmp    edi,0x1d
  10995e:	0f 84 a0 03 00 00    	je     109d04 <dw_get_attrib_string+0x454>
  109964:	83 ff 1e             	cmp    edi,0x1e
  109967:	0f 84 9d 03 00 00    	je     109d0a <dw_get_attrib_string+0x45a>
  10996d:	83 ff 20             	cmp    edi,0x20
  109970:	0f 84 9a 03 00 00    	je     109d10 <dw_get_attrib_string+0x460>
  109976:	83 ff 21             	cmp    edi,0x21
  109979:	0f 84 97 03 00 00    	je     109d16 <dw_get_attrib_string+0x466>
  10997f:	83 ff 22             	cmp    edi,0x22
  109982:	0f 84 94 03 00 00    	je     109d1c <dw_get_attrib_string+0x46c>
  109988:	83 ff 25             	cmp    edi,0x25
  10998b:	0f 84 91 03 00 00    	je     109d22 <dw_get_attrib_string+0x472>
  109991:	83 ff 27             	cmp    edi,0x27
  109994:	0f 84 8e 03 00 00    	je     109d28 <dw_get_attrib_string+0x478>
  10999a:	83 ff 2a             	cmp    edi,0x2a
  10999d:	0f 84 8b 03 00 00    	je     109d2e <dw_get_attrib_string+0x47e>
  1099a3:	83 ff 2c             	cmp    edi,0x2c
  1099a6:	0f 84 88 03 00 00    	je     109d34 <dw_get_attrib_string+0x484>
  1099ac:	83 ff 2e             	cmp    edi,0x2e
  1099af:	0f 84 85 03 00 00    	je     109d3a <dw_get_attrib_string+0x48a>
  1099b5:	83 ff 2f             	cmp    edi,0x2f
  1099b8:	0f 84 82 03 00 00    	je     109d40 <dw_get_attrib_string+0x490>
  1099be:	83 ff 31             	cmp    edi,0x31
  1099c1:	0f 84 7f 03 00 00    	je     109d46 <dw_get_attrib_string+0x496>
  1099c7:	83 ff 32             	cmp    edi,0x32
  1099ca:	0f 84 7c 03 00 00    	je     109d4c <dw_get_attrib_string+0x49c>
  1099d0:	83 ff 33             	cmp    edi,0x33
  1099d3:	0f 84 79 03 00 00    	je     109d52 <dw_get_attrib_string+0x4a2>
  1099d9:	83 ff 34             	cmp    edi,0x34
  1099dc:	0f 84 76 03 00 00    	je     109d58 <dw_get_attrib_string+0x4a8>
  1099e2:	83 ff 35             	cmp    edi,0x35
  1099e5:	0f 84 85 03 00 00    	je     109d70 <dw_get_attrib_string+0x4c0>
  1099eb:	83 ff 36             	cmp    edi,0x36
  1099ee:	0f 84 76 03 00 00    	je     109d6a <dw_get_attrib_string+0x4ba>
  1099f4:	83 ff 37             	cmp    edi,0x37
  1099f7:	0f 84 67 03 00 00    	je     109d64 <dw_get_attrib_string+0x4b4>
  1099fd:	83 ff 38             	cmp    edi,0x38
  109a00:	0f 84 58 03 00 00    	je     109d5e <dw_get_attrib_string+0x4ae>
  109a06:	83 ff 39             	cmp    edi,0x39
  109a09:	0f 84 eb 03 00 00    	je     109dfa <dw_get_attrib_string+0x54a>
  109a0f:	83 ff 3a             	cmp    edi,0x3a
  109a12:	0f 84 dc 03 00 00    	je     109df4 <dw_get_attrib_string+0x544>
  109a18:	83 ff 3b             	cmp    edi,0x3b
  109a1b:	0f 84 cd 03 00 00    	je     109dee <dw_get_attrib_string+0x53e>
  109a21:	83 ff 3c             	cmp    edi,0x3c
  109a24:	0f 84 be 03 00 00    	je     109de8 <dw_get_attrib_string+0x538>
  109a2a:	83 ff 3d             	cmp    edi,0x3d
  109a2d:	0f 84 af 03 00 00    	je     109de2 <dw_get_attrib_string+0x532>
  109a33:	83 ff 3e             	cmp    edi,0x3e
  109a36:	0f 84 a0 03 00 00    	je     109ddc <dw_get_attrib_string+0x52c>
  109a3c:	83 ff 3f             	cmp    edi,0x3f
  109a3f:	0f 84 91 03 00 00    	je     109dd6 <dw_get_attrib_string+0x526>
  109a45:	83 ff 40             	cmp    edi,0x40
  109a48:	0f 84 82 03 00 00    	je     109dd0 <dw_get_attrib_string+0x520>
  109a4e:	83 ff 41             	cmp    edi,0x41
  109a51:	0f 84 63 04 00 00    	je     109eba <dw_get_attrib_string+0x60a>
  109a57:	83 ff 42             	cmp    edi,0x42
  109a5a:	0f 84 54 04 00 00    	je     109eb4 <dw_get_attrib_string+0x604>
  109a60:	83 ff 43             	cmp    edi,0x43
  109a63:	0f 84 45 04 00 00    	je     109eae <dw_get_attrib_string+0x5fe>
  109a69:	83 ff 44             	cmp    edi,0x44
  109a6c:	0f 84 36 04 00 00    	je     109ea8 <dw_get_attrib_string+0x5f8>
  109a72:	83 ff 45             	cmp    edi,0x45
  109a75:	0f 84 27 04 00 00    	je     109ea2 <dw_get_attrib_string+0x5f2>
  109a7b:	83 ff 46             	cmp    edi,0x46
  109a7e:	0f 84 18 04 00 00    	je     109e9c <dw_get_attrib_string+0x5ec>
  109a84:	83 ff 47             	cmp    edi,0x47
  109a87:	0f 84 09 04 00 00    	je     109e96 <dw_get_attrib_string+0x5e6>
  109a8d:	83 ff 48             	cmp    edi,0x48
  109a90:	0f 84 fa 03 00 00    	je     109e90 <dw_get_attrib_string+0x5e0>
  109a96:	83 ff 49             	cmp    edi,0x49
  109a99:	0f 84 eb 03 00 00    	je     109e8a <dw_get_attrib_string+0x5da>
  109a9f:	83 ff 4a             	cmp    edi,0x4a
  109aa2:	0f 84 dc 03 00 00    	je     109e84 <dw_get_attrib_string+0x5d4>
  109aa8:	83 ff 4b             	cmp    edi,0x4b
  109aab:	0f 84 cd 03 00 00    	je     109e7e <dw_get_attrib_string+0x5ce>
  109ab1:	83 ff 4c             	cmp    edi,0x4c
  109ab4:	0f 84 be 03 00 00    	je     109e78 <dw_get_attrib_string+0x5c8>
  109aba:	83 ff 4d             	cmp    edi,0x4d
  109abd:	0f 84 af 03 00 00    	je     109e72 <dw_get_attrib_string+0x5c2>
  109ac3:	83 ff 4e             	cmp    edi,0x4e
  109ac6:	0f 84 a0 03 00 00    	je     109e6c <dw_get_attrib_string+0x5bc>
  109acc:	83 ff 4f             	cmp    edi,0x4f
  109acf:	0f 84 91 03 00 00    	je     109e66 <dw_get_attrib_string+0x5b6>
  109ad5:	83 ff 50             	cmp    edi,0x50
  109ad8:	0f 84 82 03 00 00    	je     109e60 <dw_get_attrib_string+0x5b0>
  109ade:	83 ff 51             	cmp    edi,0x51
  109ae1:	0f 84 73 03 00 00    	je     109e5a <dw_get_attrib_string+0x5aa>
  109ae7:	83 ff 52             	cmp    edi,0x52
  109aea:	0f 84 64 03 00 00    	je     109e54 <dw_get_attrib_string+0x5a4>
  109af0:	83 ff 53             	cmp    edi,0x53
  109af3:	0f 84 55 03 00 00    	je     109e4e <dw_get_attrib_string+0x59e>
  109af9:	83 ff 54             	cmp    edi,0x54
  109afc:	0f 84 46 03 00 00    	je     109e48 <dw_get_attrib_string+0x598>
  109b02:	83 ff 55             	cmp    edi,0x55
  109b05:	0f 84 37 03 00 00    	je     109e42 <dw_get_attrib_string+0x592>
  109b0b:	83 ff 56             	cmp    edi,0x56
  109b0e:	0f 84 28 03 00 00    	je     109e3c <dw_get_attrib_string+0x58c>
  109b14:	83 ff 57             	cmp    edi,0x57
  109b17:	0f 84 19 03 00 00    	je     109e36 <dw_get_attrib_string+0x586>
  109b1d:	83 ff 58             	cmp    edi,0x58
  109b20:	0f 84 0a 03 00 00    	je     109e30 <dw_get_attrib_string+0x580>
  109b26:	83 ff 59             	cmp    edi,0x59
  109b29:	0f 84 fb 02 00 00    	je     109e2a <dw_get_attrib_string+0x57a>
  109b2f:	83 ff 5a             	cmp    edi,0x5a
  109b32:	0f 84 ec 02 00 00    	je     109e24 <dw_get_attrib_string+0x574>
  109b38:	83 ff 5b             	cmp    edi,0x5b
  109b3b:	0f 84 dd 02 00 00    	je     109e1e <dw_get_attrib_string+0x56e>
  109b41:	83 ff 5c             	cmp    edi,0x5c
  109b44:	0f 84 ce 02 00 00    	je     109e18 <dw_get_attrib_string+0x568>
  109b4a:	83 ff 5d             	cmp    edi,0x5d
  109b4d:	0f 84 bf 02 00 00    	je     109e12 <dw_get_attrib_string+0x562>
  109b53:	83 ff 5e             	cmp    edi,0x5e
  109b56:	0f 84 b0 02 00 00    	je     109e0c <dw_get_attrib_string+0x55c>
  109b5c:	83 ff 5f             	cmp    edi,0x5f
  109b5f:	0f 84 a1 02 00 00    	je     109e06 <dw_get_attrib_string+0x556>
  109b65:	83 ff 60             	cmp    edi,0x60
  109b68:	0f 84 92 02 00 00    	je     109e00 <dw_get_attrib_string+0x550>
  109b6e:	83 ff 61             	cmp    edi,0x61
  109b71:	0f 84 53 02 00 00    	je     109dca <dw_get_attrib_string+0x51a>
  109b77:	83 ff 62             	cmp    edi,0x62
  109b7a:	0f 84 44 02 00 00    	je     109dc4 <dw_get_attrib_string+0x514>
  109b80:	83 ff 63             	cmp    edi,0x63
  109b83:	0f 84 35 02 00 00    	je     109dbe <dw_get_attrib_string+0x50e>
  109b89:	83 ff 64             	cmp    edi,0x64
  109b8c:	0f 84 26 02 00 00    	je     109db8 <dw_get_attrib_string+0x508>
  109b92:	83 ff 65             	cmp    edi,0x65
  109b95:	0f 84 17 02 00 00    	je     109db2 <dw_get_attrib_string+0x502>
  109b9b:	83 ff 66             	cmp    edi,0x66
  109b9e:	0f 84 08 02 00 00    	je     109dac <dw_get_attrib_string+0x4fc>
  109ba4:	83 ff 67             	cmp    edi,0x67
  109ba7:	0f 84 f9 01 00 00    	je     109da6 <dw_get_attrib_string+0x4f6>
  109bad:	83 ff 68             	cmp    edi,0x68
  109bb0:	0f 84 ea 01 00 00    	je     109da0 <dw_get_attrib_string+0x4f0>
  109bb6:	83 ff 69             	cmp    edi,0x69
  109bb9:	0f 84 db 01 00 00    	je     109d9a <dw_get_attrib_string+0x4ea>
  109bbf:	83 ff 6a             	cmp    edi,0x6a
  109bc2:	0f 84 cc 01 00 00    	je     109d94 <dw_get_attrib_string+0x4e4>
  109bc8:	83 ff 6b             	cmp    edi,0x6b
  109bcb:	0f 84 bd 01 00 00    	je     109d8e <dw_get_attrib_string+0x4de>
  109bd1:	83 ff 6c             	cmp    edi,0x6c
  109bd4:	0f 84 ae 01 00 00    	je     109d88 <dw_get_attrib_string+0x4d8>
  109bda:	83 ff 6d             	cmp    edi,0x6d
  109bdd:	0f 84 9f 01 00 00    	je     109d82 <dw_get_attrib_string+0x4d2>
  109be3:	83 ff 6e             	cmp    edi,0x6e
  109be6:	0f 84 90 01 00 00    	je     109d7c <dw_get_attrib_string+0x4cc>
  109bec:	81 ff 00 20 00 00    	cmp    edi,0x2000
  109bf2:	0f 84 7e 01 00 00    	je     109d76 <dw_get_attrib_string+0x4c6>
  else { return "INVALID!!!"; }
  109bf8:	81 ff ff 3f 00 00    	cmp    edi,0x3fff
  109bfe:	ba cb 04 10 00       	mov    edx,0x1004cb
  109c03:	b8 18 0b 10 00       	mov    eax,0x100b18
  109c08:	48 0f 45 c2          	cmovne rax,rdx
  109c0c:	c3                   	ret    
  109c0d:	0f 1f 00             	nop    DWORD PTR [rax]
  if (0) {} DW_AT_META_LIST
  109c10:	b8 fe 04 10 00       	mov    eax,0x1004fe
  109c15:	c3                   	ret    
  109c16:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109c1d:	00 00 00 
  109c20:	b8 d6 04 10 00       	mov    eax,0x1004d6
  109c25:	c3                   	ret    
  109c26:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109c2d:	00 00 00 
  109c30:	b8 e4 04 10 00       	mov    eax,0x1004e4
  109c35:	c3                   	ret    
  109c36:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109c3d:	00 00 00 
  109c40:	b8 f3 04 10 00       	mov    eax,0x1004f3
  109c45:	c3                   	ret    
  109c46:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109c4d:	00 00 00 
  109c50:	b8 0d 05 10 00       	mov    eax,0x10050d
  109c55:	c3                   	ret    
  109c56:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109c5d:	00 00 00 
  109c60:	b8 1d 05 10 00       	mov    eax,0x10051d
  109c65:	c3                   	ret    
  109c66:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109c6d:	00 00 00 
  109c70:	b8 2e 05 10 00       	mov    eax,0x10052e
  109c75:	c3                   	ret    
  109c76:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109c7d:	00 00 00 
  109c80:	b8 3d 05 10 00       	mov    eax,0x10053d
  109c85:	c3                   	ret    
  109c86:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109c8d:	00 00 00 
  109c90:	b8 95 05 10 00       	mov    eax,0x100595
  109c95:	c3                   	ret    
  109c96:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109c9d:	00 00 00 
  109ca0:	b8 4d 05 10 00       	mov    eax,0x10054d
  109ca5:	c3                   	ret    
  109ca6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109cad:	00 00 00 
  109cb0:	b8 5a 05 10 00       	mov    eax,0x10055a
  109cb5:	c3                   	ret    
  109cb6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109cbd:	00 00 00 
  109cc0:	b8 68 05 10 00       	mov    eax,0x100568
  109cc5:	c3                   	ret    
  109cc6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109ccd:	00 00 00 
  109cd0:	b8 77 05 10 00       	mov    eax,0x100577
  109cd5:	c3                   	ret    
  109cd6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109cdd:	00 00 00 
  109ce0:	b8 83 05 10 00       	mov    eax,0x100583
  109ce5:	c3                   	ret    
  109ce6:	b8 a6 05 10 00       	mov    eax,0x1005a6
  109ceb:	c3                   	ret    
  109cec:	b8 b3 05 10 00       	mov    eax,0x1005b3
  109cf1:	c3                   	ret    
  109cf2:	b8 c7 05 10 00       	mov    eax,0x1005c7
  109cf7:	c3                   	ret    
  109cf8:	b8 de 05 10 00       	mov    eax,0x1005de
  109cfd:	c3                   	ret    
  109cfe:	b8 ed 05 10 00       	mov    eax,0x1005ed
  109d03:	c3                   	ret    
  109d04:	b8 ff 05 10 00       	mov    eax,0x1005ff
  109d09:	c3                   	ret    
  109d0a:	b8 15 06 10 00       	mov    eax,0x100615
  109d0f:	c3                   	ret    
  109d10:	b8 29 06 10 00       	mov    eax,0x100629
  109d15:	c3                   	ret    
  109d16:	b8 36 06 10 00       	mov    eax,0x100636
  109d1b:	c3                   	ret    
  109d1c:	b8 48 06 10 00       	mov    eax,0x100648
  109d21:	c3                   	ret    
  109d22:	b8 5a 06 10 00       	mov    eax,0x10065a
  109d27:	c3                   	ret    
  109d28:	b8 69 06 10 00       	mov    eax,0x100669
  109d2d:	c3                   	ret    
  109d2e:	b8 7a 06 10 00       	mov    eax,0x10067a
  109d33:	c3                   	ret    
  109d34:	b8 8c 06 10 00       	mov    eax,0x10068c
  109d39:	c3                   	ret    
  109d3a:	b8 9e 06 10 00       	mov    eax,0x10069e
  109d3f:	c3                   	ret    
  109d40:	b8 af 06 10 00       	mov    eax,0x1006af
  109d45:	c3                   	ret    
  109d46:	b8 c1 06 10 00       	mov    eax,0x1006c1
  109d4b:	c3                   	ret    
  109d4c:	b8 d7 06 10 00       	mov    eax,0x1006d7
  109d51:	c3                   	ret    
  109d52:	b8 eb 06 10 00       	mov    eax,0x1006eb
  109d57:	c3                   	ret    
  109d58:	b8 ff 06 10 00       	mov    eax,0x1006ff
  109d5d:	c3                   	ret    
  109d5e:	b8 46 07 10 00       	mov    eax,0x100746
  109d63:	c3                   	ret    
  109d64:	b8 3a 07 10 00       	mov    eax,0x10073a
  109d69:	c3                   	ret    
  109d6a:	b8 21 07 10 00       	mov    eax,0x100721
  109d6f:	c3                   	ret    
  109d70:	b8 10 07 10 00       	mov    eax,0x100710
  109d75:	c3                   	ret    
  109d76:	b8 0a 0b 10 00       	mov    eax,0x100b0a
}
  109d7b:	c3                   	ret    
  if (0) {} DW_AT_META_LIST
  109d7c:	b8 f7 0a 10 00       	mov    eax,0x100af7
  109d81:	c3                   	ret    
  109d82:	b8 e6 0a 10 00       	mov    eax,0x100ae6
  109d87:	c3                   	ret    
  109d88:	b8 d5 0a 10 00       	mov    eax,0x100ad5
  109d8d:	c3                   	ret    
  109d8e:	b8 bf 0a 10 00       	mov    eax,0x100abf
  109d93:	c3                   	ret    
  109d94:	b8 a9 0a 10 00       	mov    eax,0x100aa9
  109d99:	c3                   	ret    
  109d9a:	b8 99 0a 10 00       	mov    eax,0x100a99
  109d9f:	c3                   	ret    
  109da0:	b8 89 0a 10 00       	mov    eax,0x100a89
  109da5:	c3                   	ret    
  109da6:	b8 7e 0a 10 00       	mov    eax,0x100a7e
  109dab:	c3                   	ret    
  109dac:	b8 6e 0a 10 00       	mov    eax,0x100a6e
  109db1:	c3                   	ret    
  109db2:	b8 5e 0a 10 00       	mov    eax,0x100a5e
  109db7:	c3                   	ret    
  109db8:	b8 49 0a 10 00       	mov    eax,0x100a49
  109dbd:	c3                   	ret    
  109dbe:	b8 3a 0a 10 00       	mov    eax,0x100a3a
  109dc3:	c3                   	ret    
  109dc4:	b8 25 0a 10 00       	mov    eax,0x100a25
  109dc9:	c3                   	ret    
  109dca:	b8 17 0a 10 00       	mov    eax,0x100a17
  109dcf:	c3                   	ret    
  109dd0:	b8 d4 07 10 00       	mov    eax,0x1007d4
  109dd5:	c3                   	ret    
  109dd6:	b8 c5 07 10 00       	mov    eax,0x1007c5
  109ddb:	c3                   	ret    
  109ddc:	b8 b6 07 10 00       	mov    eax,0x1007b6
  109de1:	c3                   	ret    
  109de2:	b8 a5 07 10 00       	mov    eax,0x1007a5
  109de7:	c3                   	ret    
  109de8:	b8 93 07 10 00       	mov    eax,0x100793
  109ded:	c3                   	ret    
  109dee:	b8 83 07 10 00       	mov    eax,0x100783
  109df3:	c3                   	ret    
  109df4:	b8 73 07 10 00       	mov    eax,0x100773
  109df9:	c3                   	ret    
  109dfa:	b8 61 07 10 00       	mov    eax,0x100761
  109dff:	c3                   	ret    
  109e00:	b8 02 0a 10 00       	mov    eax,0x100a02
  109e05:	c3                   	ret    
  109e06:	b8 f0 09 10 00       	mov    eax,0x1009f0
  109e0b:	c3                   	ret    
  109e0c:	b8 dd 09 10 00       	mov    eax,0x1009dd
  109e11:	c3                   	ret    
  109e12:	b8 d1 09 10 00       	mov    eax,0x1009d1
  109e17:	c3                   	ret    
  109e18:	b8 bd 09 10 00       	mov    eax,0x1009bd
  109e1d:	c3                   	ret    
  109e1e:	b8 aa 09 10 00       	mov    eax,0x1009aa
  109e23:	c3                   	ret    
  109e24:	b8 98 09 10 00       	mov    eax,0x100998
  109e29:	c3                   	ret    
  109e2a:	b8 88 09 10 00       	mov    eax,0x100988
  109e2f:	c3                   	ret    
  109e30:	b8 78 09 10 00       	mov    eax,0x100978
  109e35:	c3                   	ret    
  109e36:	b8 66 09 10 00       	mov    eax,0x100966
  109e3b:	c3                   	ret    
  109e3c:	b8 55 09 10 00       	mov    eax,0x100955
  109e41:	c3                   	ret    
  109e42:	b8 48 09 10 00       	mov    eax,0x100948
  109e47:	c3                   	ret    
  109e48:	b8 38 09 10 00       	mov    eax,0x100938
  109e4d:	c3                   	ret    
  109e4e:	b8 29 09 10 00       	mov    eax,0x100929
  109e53:	c3                   	ret    
  109e54:	b8 1a 09 10 00       	mov    eax,0x10091a
  109e59:	c3                   	ret    
  109e5a:	b8 08 09 10 00       	mov    eax,0x100908
  109e5f:	c3                   	ret    
  109e60:	b8 f4 08 10 00       	mov    eax,0x1008f4
  109e65:	c3                   	ret    
  109e66:	b8 e3 08 10 00       	mov    eax,0x1008e3
  109e6b:	c3                   	ret    
  109e6c:	b8 d3 08 10 00       	mov    eax,0x1008d3
  109e71:	c3                   	ret    
  109e72:	b8 b8 08 10 00       	mov    eax,0x1008b8
  109e77:	c3                   	ret    
  109e78:	b8 a7 08 10 00       	mov    eax,0x1008a7
  109e7d:	c3                   	ret    
  109e7e:	b8 8e 08 10 00       	mov    eax,0x10088e
  109e83:	c3                   	ret    
  109e84:	b8 7b 08 10 00       	mov    eax,0x10087b
  109e89:	c3                   	ret    
  109e8a:	b8 70 08 10 00       	mov    eax,0x100870
  109e8f:	c3                   	ret    
  109e90:	b8 5e 08 10 00       	mov    eax,0x10085e
  109e95:	c3                   	ret    
  109e96:	b8 4a 08 10 00       	mov    eax,0x10084a
  109e9b:	c3                   	ret    
  109e9c:	b8 3c 08 10 00       	mov    eax,0x10083c
  109ea1:	c3                   	ret    
  109ea2:	b8 2d 08 10 00       	mov    eax,0x10082d
  109ea7:	c3                   	ret    
  109ea8:	b8 19 08 10 00       	mov    eax,0x100819
  109ead:	c3                   	ret    
  109eae:	b8 08 08 10 00       	mov    eax,0x100808
  109eb3:	c3                   	ret    
  109eb4:	b8 f2 07 10 00       	mov    eax,0x1007f2
  109eb9:	c3                   	ret    
  109eba:	b8 e5 07 10 00       	mov    eax,0x1007e5
  109ebf:	c3                   	ret    

0000000000109ec0 <dw_get_form_string>:

const char *dw_get_form_string(uint32_t value) {
  if (0) {} DW_FORM_META_LIST
  109ec0:	83 ff 01             	cmp    edi,0x1
  109ec3:	0f 84 f7 00 00 00    	je     109fc0 <dw_get_form_string+0x100>
  109ec9:	83 ff 03             	cmp    edi,0x3
  109ecc:	0f 84 fe 00 00 00    	je     109fd0 <dw_get_form_string+0x110>
  109ed2:	83 ff 04             	cmp    edi,0x4
  109ed5:	0f 84 05 01 00 00    	je     109fe0 <dw_get_form_string+0x120>
  109edb:	83 ff 05             	cmp    edi,0x5
  109ede:	0f 84 cc 00 00 00    	je     109fb0 <dw_get_form_string+0xf0>
  109ee4:	83 ff 06             	cmp    edi,0x6
  109ee7:	0f 84 03 01 00 00    	je     109ff0 <dw_get_form_string+0x130>
  109eed:	83 ff 07             	cmp    edi,0x7
  109ef0:	0f 84 0a 01 00 00    	je     10a000 <dw_get_form_string+0x140>
  109ef6:	83 ff 08             	cmp    edi,0x8
  109ef9:	0f 84 11 01 00 00    	je     10a010 <dw_get_form_string+0x150>
  109eff:	83 ff 09             	cmp    edi,0x9
  109f02:	0f 84 18 01 00 00    	je     10a020 <dw_get_form_string+0x160>
  109f08:	83 ff 0a             	cmp    edi,0xa
  109f0b:	0f 84 2f 01 00 00    	je     10a040 <dw_get_form_string+0x180>
  109f11:	83 ff 0b             	cmp    edi,0xb
  109f14:	0f 84 36 01 00 00    	je     10a050 <dw_get_form_string+0x190>
  109f1a:	83 ff 0c             	cmp    edi,0xc
  109f1d:	0f 84 3d 01 00 00    	je     10a060 <dw_get_form_string+0x1a0>
  109f23:	83 ff 0d             	cmp    edi,0xd
  109f26:	0f 84 44 01 00 00    	je     10a070 <dw_get_form_string+0x1b0>
  109f2c:	83 ff 0e             	cmp    edi,0xe
  109f2f:	0f 84 4b 01 00 00    	je     10a080 <dw_get_form_string+0x1c0>
  109f35:	83 ff 0f             	cmp    edi,0xf
  109f38:	0f 84 f2 00 00 00    	je     10a030 <dw_get_form_string+0x170>
  109f3e:	83 ff 10             	cmp    edi,0x10
  109f41:	0f 84 3f 01 00 00    	je     10a086 <dw_get_form_string+0x1c6>
  109f47:	83 ff 11             	cmp    edi,0x11
  109f4a:	0f 84 3c 01 00 00    	je     10a08c <dw_get_form_string+0x1cc>
  109f50:	83 ff 12             	cmp    edi,0x12
  109f53:	0f 84 39 01 00 00    	je     10a092 <dw_get_form_string+0x1d2>
  109f59:	83 ff 13             	cmp    edi,0x13
  109f5c:	0f 84 36 01 00 00    	je     10a098 <dw_get_form_string+0x1d8>
  109f62:	83 ff 14             	cmp    edi,0x14
  109f65:	0f 84 33 01 00 00    	je     10a09e <dw_get_form_string+0x1de>
  109f6b:	83 ff 15             	cmp    edi,0x15
  109f6e:	0f 84 30 01 00 00    	je     10a0a4 <dw_get_form_string+0x1e4>
  109f74:	83 ff 16             	cmp    edi,0x16
  109f77:	0f 84 2d 01 00 00    	je     10a0aa <dw_get_form_string+0x1ea>
  109f7d:	83 ff 17             	cmp    edi,0x17
  109f80:	0f 84 2a 01 00 00    	je     10a0b0 <dw_get_form_string+0x1f0>
  109f86:	83 ff 18             	cmp    edi,0x18
  109f89:	0f 84 27 01 00 00    	je     10a0b6 <dw_get_form_string+0x1f6>
  109f8f:	83 ff 19             	cmp    edi,0x19
  109f92:	0f 84 24 01 00 00    	je     10a0bc <dw_get_form_string+0x1fc>
  else { return "INVALID!!!"; }
  109f98:	83 ff 20             	cmp    edi,0x20
  109f9b:	ba cb 04 10 00       	mov    edx,0x1004cb
  109fa0:	b8 8b 0c 10 00       	mov    eax,0x100c8b
  109fa5:	48 0f 45 c2          	cmovne rax,rdx
  109fa9:	c3                   	ret    
  109faa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  if (0) {} DW_FORM_META_LIST
  109fb0:	b8 51 0b 10 00       	mov    eax,0x100b51
  109fb5:	c3                   	ret    
  109fb6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109fbd:	00 00 00 
  109fc0:	b8 26 0b 10 00       	mov    eax,0x100b26
  109fc5:	c3                   	ret    
  109fc6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109fcd:	00 00 00 
  109fd0:	b8 33 0b 10 00       	mov    eax,0x100b33
  109fd5:	c3                   	ret    
  109fd6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109fdd:	00 00 00 
  109fe0:	b8 42 0b 10 00       	mov    eax,0x100b42
  109fe5:	c3                   	ret    
  109fe6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109fed:	00 00 00 
  109ff0:	b8 5f 0b 10 00       	mov    eax,0x100b5f
  109ff5:	c3                   	ret    
  109ff6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  109ffd:	00 00 00 
  10a000:	b8 6d 0b 10 00       	mov    eax,0x100b6d
  10a005:	c3                   	ret    
  10a006:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a00d:	00 00 00 
  10a010:	b8 7b 0b 10 00       	mov    eax,0x100b7b
  10a015:	c3                   	ret    
  10a016:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a01d:	00 00 00 
  10a020:	b8 8a 0b 10 00       	mov    eax,0x100b8a
  10a025:	c3                   	ret    
  10a026:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a02d:	00 00 00 
  10a030:	b8 dd 0b 10 00       	mov    eax,0x100bdd
  10a035:	c3                   	ret    
  10a036:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a03d:	00 00 00 
  10a040:	b8 98 0b 10 00       	mov    eax,0x100b98
  10a045:	c3                   	ret    
  10a046:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a04d:	00 00 00 
  10a050:	b8 a7 0b 10 00       	mov    eax,0x100ba7
  10a055:	c3                   	ret    
  10a056:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a05d:	00 00 00 
  10a060:	b8 b5 0b 10 00       	mov    eax,0x100bb5
  10a065:	c3                   	ret    
  10a066:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a06d:	00 00 00 
  10a070:	b8 c2 0b 10 00       	mov    eax,0x100bc2
  10a075:	c3                   	ret    
  10a076:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a07d:	00 00 00 
  10a080:	b8 d0 0b 10 00       	mov    eax,0x100bd0
  10a085:	c3                   	ret    
  10a086:	b8 eb 0b 10 00       	mov    eax,0x100beb
  10a08b:	c3                   	ret    
  10a08c:	b8 fc 0b 10 00       	mov    eax,0x100bfc
  10a091:	c3                   	ret    
  10a092:	b8 09 0c 10 00       	mov    eax,0x100c09
  10a097:	c3                   	ret    
  10a098:	b8 16 0c 10 00       	mov    eax,0x100c16
  10a09d:	c3                   	ret    
  10a09e:	b8 23 0c 10 00       	mov    eax,0x100c23
  10a0a3:	c3                   	ret    
  10a0a4:	b8 30 0c 10 00       	mov    eax,0x100c30
  10a0a9:	c3                   	ret    
  10a0aa:	b8 42 0c 10 00       	mov    eax,0x100c42
  10a0af:	c3                   	ret    
  10a0b0:	b8 53 0c 10 00       	mov    eax,0x100c53
  10a0b5:	c3                   	ret    
  10a0b6:	b8 66 0c 10 00       	mov    eax,0x100c66
  10a0bb:	c3                   	ret    
  10a0bc:	b8 76 0c 10 00       	mov    eax,0x100c76
}
  10a0c1:	c3                   	ret    
  10a0c2:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  10a0c6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a0cd:	00 00 00 

000000000010a0d0 <ktask_destroy_process>:
  asm_enter_usermode((uintptr_t)ctx->rip, ctx->rsp);
}

void ktask_destroy_process(uint64_t pid, Task_Info *task_info){
  Process_Context *p = &task_info->processess[pid];
  p->is_valid = false;
  10a0d0:	48 8d 04 7f          	lea    rax,[rdi+rdi*2]
  10a0d4:	48 8d 96 00 0d 00 00 	lea    rdx,[rsi+0xd00]
  10a0db:	c6 44 c6 10 00       	mov    BYTE PTR [rsi+rax*8+0x10],0x0
  10a0e0:	48 8d 86 00 03 00 00 	lea    rax,[rsi+0x300]
  10a0e7:	eb 10                	jmp    10a0f9 <ktask_destroy_process+0x29>
  10a0e9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  10a0f0:	48 83 c0 28          	add    rax,0x28
  //TODO(Torin)
  // - Deallocate physical frames
  // - free allocated memory

  for(size_t i = 0; i < KTASK_MAX_THREADS; i++){
  10a0f4:	48 39 d0             	cmp    rax,rdx
  10a0f7:	74 12                	je     10a10b <ktask_destroy_process+0x3b>
    Thread_Context *t = &task_info->threads[i];
    if(t->pid == pid) {
  10a0f9:	48 3b 38             	cmp    rdi,QWORD PTR [rax]
  10a0fc:	75 f2                	jne    10a0f0 <ktask_destroy_process+0x20>
    }
  }
}

void ktask_destroy_thread(Thread_Context *ctx){
  ctx->is_valid = false;
  10a0fe:	c6 40 20 00          	mov    BYTE PTR [rax+0x20],0x0
  10a102:	48 83 c0 28          	add    rax,0x28
  for(size_t i = 0; i < KTASK_MAX_THREADS; i++){
  10a106:	48 39 d0             	cmp    rax,rdx
  10a109:	75 ee                	jne    10a0f9 <ktask_destroy_process+0x29>
}
  10a10b:	f3 c3                	repz ret 
  10a10d:	0f 1f 00             	nop    DWORD PTR [rax]

000000000010a110 <ktask_destroy_thread>:
  ctx->is_valid = false;
  10a110:	c6 47 20 00          	mov    BYTE PTR [rdi+0x20],0x0
  10a114:	c3                   	ret    
  10a115:	90                   	nop
  10a116:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a11d:	00 00 00 

000000000010a120 <klog_get_next_available_entry>:
		}
  } 
  return bytes_written;
}

Circular_Log_Entry *klog_get_next_available_entry(Circular_Log *log){
  10a120:	48 8d 97 20 05 01 00 	lea    rdx,[rdi+0x10520]
  volatile int lock;
} Spin_Lock;

static inline
void spinlock_aquire(Spin_Lock *lock){
  while(!__sync_bool_compare_and_swap(&lock->lock, 0, 1));
  10a127:	31 f6                	xor    esi,esi
  10a129:	b9 01 00 00 00       	mov    ecx,0x1
  10a12e:	66 90                	xchg   ax,ax
  10a130:	89 f0                	mov    eax,esi
  10a132:	f0 0f b1 0a          	lock cmpxchg DWORD PTR [rdx],ecx
  10a136:	75 f8                	jne    10a130 <klog_get_next_available_entry+0x10>
  __sync_synchronize();
  10a138:	0f ae f0             	mfence 
  spinlock_aquire(&log->spinlock);
  size_t entry_index = log->entry_write_position % CIRCULAR_LOG_ENTRY_COUNT; 
  10a13b:	48 8b 97 00 04 01 00 	mov    rdx,QWORD PTR [rdi+0x10400]
  10a142:	0f b6 ca             	movzx  ecx,dl
  Circular_Log_Entry *entry = &log->entries[entry_index];
  log->entry_write_position++;
  10a145:	48 83 c2 01          	add    rdx,0x1
  10a149:	48 89 97 00 04 01 00 	mov    QWORD PTR [rdi+0x10400],rdx
  if(log->current_entry_count < CIRCULAR_LOG_ENTRY_COUNT) {
  10a150:	48 8b 97 08 04 01 00 	mov    rdx,QWORD PTR [rdi+0x10408]
  Circular_Log_Entry *entry = &log->entries[entry_index];
  10a157:	48 89 c8             	mov    rax,rcx
  10a15a:	48 c1 e0 06          	shl    rax,0x6
  10a15e:	48 01 c8             	add    rax,rcx
  if(log->current_entry_count < CIRCULAR_LOG_ENTRY_COUNT) {
  10a161:	48 81 fa ff 00 00 00 	cmp    rdx,0xff
  Circular_Log_Entry *entry = &log->entries[entry_index];
  10a168:	48 8d 04 87          	lea    rax,[rdi+rax*4]
  if(log->current_entry_count < CIRCULAR_LOG_ENTRY_COUNT) {
  10a16c:	77 0b                	ja     10a179 <klog_get_next_available_entry+0x59>
    log->current_entry_count++; 
  10a16e:	48 83 c2 01          	add    rdx,0x1
  10a172:	48 89 97 08 04 01 00 	mov    QWORD PTR [rdi+0x10408],rdx
}

static inline
void spinlock_release(Spin_Lock *lock){
  __sync_synchronize(); 
  10a179:	0f ae f0             	mfence 
  lock->lock = 0;
  10a17c:	c7 87 20 05 01 00 00 	mov    DWORD PTR [rdi+0x10520],0x0
  10a183:	00 00 00 
  }
  spinlock_release(&log->spinlock);
  return entry;
}
  10a186:	c3                   	ret    
  10a187:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  10a18e:	00 00 

000000000010a190 <klog_write_fmt>:
  write_serial(entry->message, entry->length);
  write_serial("\n", 1);
  spinlock_release(&log->spinlock);
}

void klog_write_fmt(Circular_Log *log, const char *fmt, ...){
  10a190:	41 56                	push   r14
  10a192:	41 55                	push   r13
  10a194:	41 54                	push   r12
  10a196:	55                   	push   rbp
  10a197:	53                   	push   rbx
  10a198:	48 83 ec 50          	sub    rsp,0x50
  if(globals.is_logging_disabled) return;
  10a19c:	80 3d 65 74 01 00 00 	cmp    BYTE PTR [rip+0x17465],0x0        # 121608 <globals+0x114a8>
void klog_write_fmt(Circular_Log *log, const char *fmt, ...){
  10a1a3:	48 89 54 24 30       	mov    QWORD PTR [rsp+0x30],rdx
  10a1a8:	48 89 4c 24 38       	mov    QWORD PTR [rsp+0x38],rcx
  10a1ad:	4c 89 44 24 40       	mov    QWORD PTR [rsp+0x40],r8
  10a1b2:	4c 89 4c 24 48       	mov    QWORD PTR [rsp+0x48],r9
  if(globals.is_logging_disabled) return;
  10a1b7:	74 17                	je     10a1d0 <klog_write_fmt+0x40>
  log->is_dirty = true;
  write_serial(entry->message, entry->length);
  write_serial("\n", 1);
  spinlock_release(&log->spinlock);
  asm volatile("sti");
}
  10a1b9:	48 83 c4 50          	add    rsp,0x50
  10a1bd:	5b                   	pop    rbx
  10a1be:	5d                   	pop    rbp
  10a1bf:	41 5c                	pop    r12
  10a1c1:	41 5d                	pop    r13
  10a1c3:	41 5e                	pop    r14
  10a1c5:	c3                   	ret    
  10a1c6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a1cd:	00 00 00 
  asm volatile("cli");
  10a1d0:	fa                   	cli    
  10a1d1:	48 8d 8f 20 05 01 00 	lea    rcx,[rdi+0x10520]
  while(!__sync_bool_compare_and_swap(&lock->lock, 0, 1));
  10a1d8:	45 31 c0             	xor    r8d,r8d
  10a1db:	ba 01 00 00 00       	mov    edx,0x1
  10a1e0:	44 89 c0             	mov    eax,r8d
  10a1e3:	f0 0f b1 11          	lock cmpxchg DWORD PTR [rcx],edx
  10a1e7:	75 f7                	jne    10a1e0 <klog_write_fmt+0x50>
  __sync_synchronize();
  10a1e9:	0f ae f0             	mfence 
  size_t entry_index = log->entry_write_position % CIRCULAR_LOG_ENTRY_COUNT;
  10a1ec:	48 8b 87 00 04 01 00 	mov    rax,QWORD PTR [rdi+0x10400]
  10a1f3:	44 0f b6 d0          	movzx  r10d,al
  log->entry_write_position++;
  10a1f7:	48 83 c0 01          	add    rax,0x1
  10a1fb:	48 89 87 00 04 01 00 	mov    QWORD PTR [rdi+0x10400],rax
  if(log->current_entry_count < CIRCULAR_LOG_ENTRY_COUNT){ log->current_entry_count++; }
  10a202:	48 8b 87 08 04 01 00 	mov    rax,QWORD PTR [rdi+0x10408]
  10a209:	48 3d ff 00 00 00    	cmp    rax,0xff
  10a20f:	77 0b                	ja     10a21c <klog_write_fmt+0x8c>
  10a211:	48 83 c0 01          	add    rax,0x1
  10a215:	48 89 87 08 04 01 00 	mov    QWORD PTR [rdi+0x10408],rax
  __sync_synchronize(); 
  10a21c:	0f ae f0             	mfence 
  lock->lock = 0;
  10a21f:	c7 87 20 05 01 00 00 	mov    DWORD PTR [rdi+0x10520],0x0
  10a226:	00 00 00 
  asm volatile("sti");
  10a229:	fb                   	sti    
  va_start(args, fmt);
  10a22a:	48 8d 84 24 80 00 00 	lea    rax,[rsp+0x80]
  10a231:	00 
  10a232:	c7 44 24 08 10 00 00 	mov    DWORD PTR [rsp+0x8],0x10
  10a239:	00 
  size_t fmt_index = 0;
  10a23a:	45 31 c0             	xor    r8d,r8d
  size_t bytes_written = 0;
  10a23d:	45 31 db             	xor    r11d,r11d
      dest[bytes_written++] = LOOKUP[value % base];
  10a240:	48 bd cd cc cc cc cc 	movabs rbp,0xcccccccccccccccd
  10a247:	cc cc cc 
  va_start(args, fmt);
  10a24a:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
  10a24f:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
  10a254:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
  entry->length = kernel_vsnprintf(entry->message, CIRCULAR_LOG_MESSAGE_SIZE, fmt, args);
  10a259:	4c 89 d0             	mov    rax,r10
  10a25c:	48 c1 e0 06          	shl    rax,0x6
  10a260:	4c 01 d0             	add    rax,r10
  10a263:	4c 8d 0c 87          	lea    r9,[rdi+rax*4]
  10a267:	0f b6 06             	movzx  eax,BYTE PTR [rsi]
  while(fmt[fmt_index] != 0){
  10a26a:	84 c0                	test   al,al
  10a26c:	74 73                	je     10a2e1 <klog_write_fmt+0x151>
    if(fmt[fmt_index] == '%'){
  10a26e:	3c 25                	cmp    al,0x25
  10a270:	4c 89 c2             	mov    rdx,r8
  10a273:	75 0f                	jne    10a284 <klog_write_fmt+0xf4>
  10a275:	e9 11 01 00 00       	jmp    10a38b <klog_write_fmt+0x1fb>
  10a27a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
      while(fmt[fmt_index] != '%' && fmt[fmt_index] != 0){
  10a280:	84 c0                	test   al,al
  10a282:	74 10                	je     10a294 <klog_write_fmt+0x104>
       fmt_index++; 
  10a284:	48 83 c2 01          	add    rdx,0x1
      while(fmt[fmt_index] != '%' && fmt[fmt_index] != 0){
  10a288:	0f b6 04 16          	movzx  eax,BYTE PTR [rsi+rdx*1]
  10a28c:	4c 8d 24 16          	lea    r12,[rsi+rdx*1]
  10a290:	3c 25                	cmp    al,0x25
  10a292:	75 ec                	jne    10a280 <klog_write_fmt+0xf0>
      size_t length = fmt_index - begin;
  10a294:	48 89 d3             	mov    rbx,rdx
  10a297:	4c 29 c3             	sub    rbx,r8
      if(bytes_written + length > capacity) return bytes_written;
  10a29a:	4d 8d 2c 1b          	lea    r13,[r11+rbx*1]
  10a29e:	49 81 fd 00 01 00 00 	cmp    r13,0x100
  10a2a5:	77 3a                	ja     10a2e1 <klog_write_fmt+0x151>
	for (size_t i = 0; i < size; i++) {
  10a2a7:	48 85 db             	test   rbx,rbx
  10a2aa:	0f 84 11 01 00 00    	je     10a3c1 <klog_write_fmt+0x231>
  10a2b0:	4e 8d 34 06          	lea    r14,[rsi+r8*1]
  10a2b4:	31 c0                	xor    eax,eax
  10a2b6:	4d 01 cb             	add    r11,r9
  10a2b9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		dest[i] = src[i];
  10a2c0:	45 0f b6 04 06       	movzx  r8d,BYTE PTR [r14+rax*1]
  10a2c5:	45 88 04 03          	mov    BYTE PTR [r11+rax*1],r8b
	for (size_t i = 0; i < size; i++) {
  10a2c9:	48 83 c0 01          	add    rax,0x1
  10a2cd:	48 39 c3             	cmp    rbx,rax
  10a2d0:	75 ee                	jne    10a2c0 <klog_write_fmt+0x130>
  10a2d2:	41 0f b6 04 24       	movzx  eax,BYTE PTR [r12]
       fmt_index++; 
  10a2d7:	49 89 d0             	mov    r8,rdx
  10a2da:	4d 89 eb             	mov    r11,r13
  while(fmt[fmt_index] != 0){
  10a2dd:	84 c0                	test   al,al
  10a2df:	75 8d                	jne    10a26e <klog_write_fmt+0xde>
  entry->length = kernel_vsnprintf(entry->message, CIRCULAR_LOG_MESSAGE_SIZE, fmt, args);
  10a2e1:	4c 89 d0             	mov    rax,r10
  10a2e4:	48 c1 e0 06          	shl    rax,0x6
  10a2e8:	4c 01 d0             	add    rax,r10
  10a2eb:	44 89 9c 87 00 01 00 	mov    DWORD PTR [rdi+rax*4+0x100],r11d
  10a2f2:	00 
  asm volatile("cli");
  10a2f3:	fa                   	cli    
  while(!__sync_bool_compare_and_swap(&lock->lock, 0, 1));
  10a2f4:	31 f6                	xor    esi,esi
  10a2f6:	ba 01 00 00 00       	mov    edx,0x1
  10a2fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
  10a300:	89 f0                	mov    eax,esi
  10a302:	f0 0f b1 11          	lock cmpxchg DWORD PTR [rcx],edx
  10a306:	75 f8                	jne    10a300 <klog_write_fmt+0x170>
  write_serial(entry->message, entry->length);
  10a308:	4c 89 d0             	mov    rax,r10
  __sync_synchronize();
  10a30b:	0f ae f0             	mfence 
  log->is_dirty = true;
  10a30e:	c6 87 24 05 01 00 01 	mov    BYTE PTR [rdi+0x10524],0x1
  write_serial(entry->message, entry->length);
  10a315:	48 c1 e0 06          	shl    rax,0x6
  10a319:	49 01 c2             	add    r10,rax
  10a31c:	46 8b 84 97 00 01 00 	mov    r8d,DWORD PTR [rdi+r10*4+0x100]
  10a323:	00 
  10a324:	4d 85 c0             	test   r8,r8
  10a327:	74 30                	je     10a359 <klog_write_fmt+0x1c9>
  10a329:	31 f6                	xor    esi,esi
	asm volatile ("inb %1, %0" : "=a"(result) : "Nd"(port));
  10a32b:	b9 fd 03 00 00       	mov    ecx,0x3fd
	asm volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
  10a330:	41 ba f8 03 00 00    	mov    r10d,0x3f8
  10a336:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a33d:	00 00 00 
	asm volatile ("inb %1, %0" : "=a"(result) : "Nd"(port));
  10a340:	89 ca                	mov    edx,ecx
  10a342:	ec                   	in     al,dx
    while(is_transmit_empty() == 0) {}
  10a343:	a8 20                	test   al,0x20
  10a345:	74 f9                	je     10a340 <klog_write_fmt+0x1b0>
	asm volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
  10a347:	41 0f b6 04 31       	movzx  eax,BYTE PTR [r9+rsi*1]
  10a34c:	44 89 d2             	mov    edx,r10d
  10a34f:	ee                   	out    dx,al
  for(size_t i = 0; i < length; i++){
  10a350:	48 83 c6 01          	add    rsi,0x1
  10a354:	49 39 f0             	cmp    r8,rsi
  10a357:	75 e7                	jne    10a340 <klog_write_fmt+0x1b0>
	asm volatile ("inb %1, %0" : "=a"(result) : "Nd"(port));
  10a359:	ba fd 03 00 00       	mov    edx,0x3fd
  10a35e:	66 90                	xchg   ax,ax
  10a360:	ec                   	in     al,dx
    while(is_transmit_empty() == 0) {}
  10a361:	a8 20                	test   al,0x20
  10a363:	74 fb                	je     10a360 <klog_write_fmt+0x1d0>
	asm volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
  10a365:	ba f8 03 00 00       	mov    edx,0x3f8
  10a36a:	b8 0a 00 00 00       	mov    eax,0xa
  10a36f:	ee                   	out    dx,al
  __sync_synchronize(); 
  10a370:	0f ae f0             	mfence 
  lock->lock = 0;
  10a373:	c7 87 20 05 01 00 00 	mov    DWORD PTR [rdi+0x10520],0x0
  10a37a:	00 00 00 
  asm volatile("sti");
  10a37d:	fb                   	sti    
}
  10a37e:	48 83 c4 50          	add    rsp,0x50
  10a382:	5b                   	pop    rbx
  10a383:	5d                   	pop    rbp
  10a384:	41 5c                	pop    r12
  10a386:	41 5d                	pop    r13
  10a388:	41 5e                	pop    r14
  10a38a:	c3                   	ret    
			if(fmt[fmt_index] == 'l') {
  10a38b:	42 0f b6 44 06 01    	movzx  eax,BYTE PTR [rsi+r8*1+0x1]
			fmt_index++;
  10a391:	49 8d 50 01          	lea    rdx,[r8+0x1]
			if(fmt[fmt_index] == 'l') {
  10a395:	3c 6c                	cmp    al,0x6c
  10a397:	74 33                	je     10a3cc <klog_write_fmt+0x23c>
			else if (fmt[fmt_index] == 'u') {
  10a399:	3c 75                	cmp    al,0x75
  10a39b:	0f 84 2f 01 00 00    	je     10a4d0 <klog_write_fmt+0x340>
			else if (fmt[fmt_index] == 's') {
  10a3a1:	3c 73                	cmp    al,0x73
  10a3a3:	0f 84 37 03 00 00    	je     10a6e0 <klog_write_fmt+0x550>
      else if(fmt[fmt_index] == 'X'){
  10a3a9:	3c 58                	cmp    al,0x58
  10a3ab:	0f 84 f1 01 00 00    	je     10a5a2 <klog_write_fmt+0x412>
			else if (fmt[fmt_index] == '.') {
  10a3b1:	3c 2e                	cmp    al,0x2e
  10a3b3:	0f 84 7f 00 00 00    	je     10a438 <klog_write_fmt+0x2a8>
					fmt_index++;
  10a3b9:	49 89 d0             	mov    r8,rdx
  10a3bc:	e9 a9 fe ff ff       	jmp    10a26a <klog_write_fmt+0xda>
       fmt_index++; 
  10a3c1:	49 89 d0             	mov    r8,rdx
  10a3c4:	4d 89 eb             	mov    r11,r13
  10a3c7:	e9 9e fe ff ff       	jmp    10a26a <klog_write_fmt+0xda>
				if(fmt[fmt_index] == 'u') {
  10a3cc:	42 0f b6 44 06 02    	movzx  eax,BYTE PTR [rsi+r8*1+0x2]
				fmt_index++;
  10a3d2:	49 8d 50 02          	lea    rdx,[r8+0x2]
				if(fmt[fmt_index] == 'u') {
  10a3d6:	3c 75                	cmp    al,0x75
  10a3d8:	75 df                	jne    10a3b9 <klog_write_fmt+0x229>
					uint64_t value = va_arg(args, uint64_t);
  10a3da:	8b 54 24 08          	mov    edx,DWORD PTR [rsp+0x8]
  10a3de:	83 fa 2f             	cmp    edx,0x2f
  10a3e1:	0f 87 e6 02 00 00    	ja     10a6cd <klog_write_fmt+0x53d>
  10a3e7:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
  10a3ec:	89 d0                	mov    eax,edx
  10a3ee:	83 c2 08             	add    edx,0x8
  10a3f1:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
  10a3f5:	48 01 d8             	add    rax,rbx
  10a3f8:	4c 8b 30             	mov    r14,QWORD PTR [rax]
          if(bytes_written + 20 > capacity) return bytes_written;
  10a3fb:	49 8d 43 14          	lea    rax,[r11+0x14]
  10a3ff:	48 3d 00 01 00 00    	cmp    rax,0x100
  10a405:	0f 87 d6 fe ff ff    	ja     10a2e1 <klog_write_fmt+0x151>
  if(value == 0) {
  10a40b:	45 31 e4             	xor    r12d,r12d
  10a40e:	4d 85 f6             	test   r14,r14
          bytes_written += uint64_to_string(buffer + bytes_written, value, 10);
  10a411:	4b 8d 1c 19          	lea    rbx,[r9+r11*1]
  if(value == 0) {
  10a415:	0f 85 48 02 00 00    	jne    10a663 <klog_write_fmt+0x4d3>
    dest[0] = '0';
  10a41b:	c6 03 30             	mov    BYTE PTR [rbx],0x30
    bytes_written = 1;
  10a41e:	41 bd 01 00 00 00    	mov    r13d,0x1
          fmt_index++;
  10a424:	49 83 c0 03          	add    r8,0x3
          bytes_written += uint64_to_string(buffer + bytes_written, value, 10);
  10a428:	4d 01 eb             	add    r11,r13
  10a42b:	42 0f b6 04 06       	movzx  eax,BYTE PTR [rsi+r8*1]
  10a430:	e9 35 fe ff ff       	jmp    10a26a <klog_write_fmt+0xda>
  10a435:	0f 1f 00             	nop    DWORD PTR [rax]
				if(fmt[fmt_index] == '*'){
  10a438:	42 0f b6 44 06 02    	movzx  eax,BYTE PTR [rsi+r8*1+0x2]
				fmt_index++;
  10a43e:	49 8d 50 02          	lea    rdx,[r8+0x2]
				if(fmt[fmt_index] == '*'){
  10a442:	3c 2a                	cmp    al,0x2a
  10a444:	0f 85 6f ff ff ff    	jne    10a3b9 <klog_write_fmt+0x229>
          if(fmt[fmt_index] == 's'){
  10a44a:	42 0f b6 44 06 03    	movzx  eax,BYTE PTR [rsi+r8*1+0x3]
					fmt_index++;
  10a450:	49 8d 50 03          	lea    rdx,[r8+0x3]
          if(fmt[fmt_index] == 's'){
  10a454:	3c 73                	cmp    al,0x73
  10a456:	0f 85 5d ff ff ff    	jne    10a3b9 <klog_write_fmt+0x229>
            size_t str_length = (size_t)va_arg(args, uintptr_t);
  10a45c:	8b 54 24 08          	mov    edx,DWORD PTR [rsp+0x8]
            fmt_index++;
  10a460:	49 83 c0 04          	add    r8,0x4
            size_t str_length = (size_t)va_arg(args, uintptr_t);
  10a464:	83 fa 2f             	cmp    edx,0x2f
  10a467:	0f 87 48 03 00 00    	ja     10a7b5 <klog_write_fmt+0x625>
  10a46d:	8d 42 08             	lea    eax,[rdx+0x8]
  10a470:	89 d3                	mov    ebx,edx
  10a472:	48 8b 5c 1c 20       	mov    rbx,QWORD PTR [rsp+rbx*1+0x20]
            const char *str = (const char *)va_arg(args, uintptr_t);
  10a477:	83 f8 2f             	cmp    eax,0x2f
            size_t str_length = (size_t)va_arg(args, uintptr_t);
  10a47a:	89 44 24 08          	mov    DWORD PTR [rsp+0x8],eax
            const char *str = (const char *)va_arg(args, uintptr_t);
  10a47e:	0f 87 1e 03 00 00    	ja     10a7a2 <klog_write_fmt+0x612>
  10a484:	4c 8d 74 24 20       	lea    r14,[rsp+0x20]
  10a489:	83 c2 10             	add    edx,0x10
  10a48c:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
  10a490:	4c 01 f0             	add    rax,r14
            if(bytes_written + str_length > capacity) return bytes_written;
  10a493:	49 8d 14 1b          	lea    rdx,[r11+rbx*1]
            const char *str = (const char *)va_arg(args, uintptr_t);
  10a497:	4c 8b 20             	mov    r12,QWORD PTR [rax]
            if(bytes_written + str_length > capacity) return bytes_written;
  10a49a:	48 81 fa 00 01 00 00 	cmp    rdx,0x100
  10a4a1:	0f 87 3a fe ff ff    	ja     10a2e1 <klog_write_fmt+0x151>
  10a4a7:	31 c0                	xor    eax,eax
  10a4a9:	4d 01 cb             	add    r11,r9
  10a4ac:	48 85 db             	test   rbx,rbx
  10a4af:	74 12                	je     10a4c3 <klog_write_fmt+0x333>
		dest[i] = src[i];
  10a4b1:	46 0f b6 2c 20       	movzx  r13d,BYTE PTR [rax+r12*1]
  10a4b6:	45 88 2c 03          	mov    BYTE PTR [r11+rax*1],r13b
	for (size_t i = 0; i < size; i++) {
  10a4ba:	48 83 c0 01          	add    rax,0x1
  10a4be:	48 39 d8             	cmp    rax,rbx
  10a4c1:	75 ee                	jne    10a4b1 <klog_write_fmt+0x321>
  10a4c3:	42 0f b6 04 06       	movzx  eax,BYTE PTR [rsi+r8*1]
  10a4c8:	49 89 d3             	mov    r11,rdx
  10a4cb:	e9 9a fd ff ff       	jmp    10a26a <klog_write_fmt+0xda>
				uint32_t value = va_arg(args, uint32_t);
  10a4d0:	8b 54 24 08          	mov    edx,DWORD PTR [rsp+0x8]
  10a4d4:	83 fa 2f             	cmp    edx,0x2f
  10a4d7:	0f 87 b2 00 00 00    	ja     10a58f <klog_write_fmt+0x3ff>
  10a4dd:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
  10a4e2:	89 d0                	mov    eax,edx
  10a4e4:	83 c2 08             	add    edx,0x8
  10a4e7:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
  10a4eb:	48 01 d8             	add    rax,rbx
  10a4ee:	8b 18                	mov    ebx,DWORD PTR [rax]
        if(bytes_written + 10 > capacity) return bytes_written;
  10a4f0:	49 8d 43 0a          	lea    rax,[r11+0xa]
  10a4f4:	48 3d 00 01 00 00    	cmp    rax,0x100
  10a4fa:	0f 87 e1 fd ff ff    	ja     10a2e1 <klog_write_fmt+0x151>
  if(value == 0) {
  10a500:	45 31 f6             	xor    r14d,r14d
  10a503:	48 85 db             	test   rbx,rbx
				bytes_written += uint64_to_string(buffer + bytes_written, (uint64_t)value, 10);
  10a506:	4f 8d 24 19          	lea    r12,[r9+r11*1]
  if(value == 0) {
  10a50a:	75 1f                	jne    10a52b <klog_write_fmt+0x39b>
    dest[0] = '0';
  10a50c:	41 c6 04 24 30       	mov    BYTE PTR [r12],0x30
    bytes_written = 1;
  10a511:	41 bd 01 00 00 00    	mov    r13d,0x1
        fmt_index++;
  10a517:	49 83 c0 02          	add    r8,0x2
				bytes_written += uint64_to_string(buffer + bytes_written, (uint64_t)value, 10);
  10a51b:	4d 01 eb             	add    r11,r13
  10a51e:	42 0f b6 04 06       	movzx  eax,BYTE PTR [rsi+r8*1]
  10a523:	e9 42 fd ff ff       	jmp    10a26a <klog_write_fmt+0xda>
      dest[bytes_written++] = LOOKUP[value % base];
  10a528:	4d 89 ee             	mov    r14,r13
  10a52b:	48 89 d8             	mov    rax,rbx
  10a52e:	4d 8d 6e 01          	lea    r13,[r14+0x1]
  10a532:	48 f7 e5             	mul    rbp
  10a535:	48 89 d0             	mov    rax,rdx
  10a538:	48 c1 e8 03          	shr    rax,0x3
  10a53c:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  10a540:	48 01 d2             	add    rdx,rdx
  10a543:	48 29 d3             	sub    rbx,rdx
    while(value > 0){
  10a546:	48 85 c0             	test   rax,rax
      dest[bytes_written++] = LOOKUP[value % base];
  10a549:	0f b6 93 a0 16 10 00 	movzx  edx,BYTE PTR [rbx+0x1016a0]
      value /= base;
  10a550:	48 89 c3             	mov    rbx,rax
      dest[bytes_written++] = LOOKUP[value % base];
  10a553:	43 88 54 2c ff       	mov    BYTE PTR [r12+r13*1-0x1],dl
    while(value > 0){
  10a558:	75 ce                	jne    10a528 <klog_write_fmt+0x398>
  for(size_t i = 0; i < midpoint; i++){
  10a55a:	4c 89 eb             	mov    rbx,r13
  10a55d:	48 d1 eb             	shr    rbx,1
  10a560:	0f 84 1c 02 00 00    	je     10a782 <klog_write_fmt+0x5f2>
  10a566:	4b 8d 04 34          	lea    rax,[r12+r14*1]
  10a56a:	4c 89 e2             	mov    rdx,r12
  10a56d:	4c 01 e3             	add    rbx,r12
    str[i] = str[length - 1 - i];
  10a570:	44 0f b6 30          	movzx  r14d,BYTE PTR [rax]
    char oldValue = str[i];
  10a574:	44 0f b6 22          	movzx  r12d,BYTE PTR [rdx]
  10a578:	48 83 c2 01          	add    rdx,0x1
  10a57c:	48 83 e8 01          	sub    rax,0x1
    str[i] = str[length - 1 - i];
  10a580:	44 88 72 ff          	mov    BYTE PTR [rdx-0x1],r14b
    str[length - 1 - i] = oldValue;
  10a584:	44 88 60 01          	mov    BYTE PTR [rax+0x1],r12b
  for(size_t i = 0; i < midpoint; i++){
  10a588:	48 39 d3             	cmp    rbx,rdx
  10a58b:	75 e3                	jne    10a570 <klog_write_fmt+0x3e0>
  10a58d:	eb 88                	jmp    10a517 <klog_write_fmt+0x387>
				uint32_t value = va_arg(args, uint32_t);
  10a58f:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  10a594:	48 8d 50 08          	lea    rdx,[rax+0x8]
  10a598:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  10a59d:	e9 4c ff ff ff       	jmp    10a4ee <klog_write_fmt+0x35e>
        uint64_t value = va_arg(args, uint64_t);
  10a5a2:	8b 54 24 08          	mov    edx,DWORD PTR [rsp+0x8]
  10a5a6:	83 fa 2f             	cmp    edx,0x2f
  10a5a9:	0f 87 9d 00 00 00    	ja     10a64c <klog_write_fmt+0x4bc>
  10a5af:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
  10a5b4:	89 d0                	mov    eax,edx
  10a5b6:	83 c2 08             	add    edx,0x8
  10a5b9:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
  10a5bd:	48 01 d8             	add    rax,rbx
  10a5c0:	4c 8b 20             	mov    r12,QWORD PTR [rax]
        if(bytes_written + 16 > capacity) return bytes_written;
  10a5c3:	49 8d 43 10          	lea    rax,[r11+0x10]
  10a5c7:	48 3d 00 01 00 00    	cmp    rax,0x100
  10a5cd:	0f 87 0e fd ff ff    	ja     10a2e1 <klog_write_fmt+0x151>
  if(value == 0) {
  10a5d3:	31 d2                	xor    edx,edx
  10a5d5:	4d 85 e4             	test   r12,r12
        bytes_written += uint64_to_string(buffer + bytes_written, value, 16);
  10a5d8:	4b 8d 04 19          	lea    rax,[r9+r11*1]
  if(value == 0) {
  10a5dc:	75 1c                	jne    10a5fa <klog_write_fmt+0x46a>
    dest[0] = '0';
  10a5de:	c6 00 30             	mov    BYTE PTR [rax],0x30
    bytes_written = 1;
  10a5e1:	bb 01 00 00 00       	mov    ebx,0x1
        fmt_index++;
  10a5e6:	49 83 c0 02          	add    r8,0x2
        bytes_written += uint64_to_string(buffer + bytes_written, value, 16);
  10a5ea:	49 01 db             	add    r11,rbx
  10a5ed:	42 0f b6 04 06       	movzx  eax,BYTE PTR [rsi+r8*1]
  10a5f2:	e9 73 fc ff ff       	jmp    10a26a <klog_write_fmt+0xda>
      dest[bytes_written++] = LOOKUP[value % base];
  10a5f7:	48 89 da             	mov    rdx,rbx
  10a5fa:	4d 89 e5             	mov    r13,r12
  10a5fd:	48 8d 5a 01          	lea    rbx,[rdx+0x1]
      value /= base;
  10a601:	49 c1 ec 04          	shr    r12,0x4
      dest[bytes_written++] = LOOKUP[value % base];
  10a605:	41 83 e5 0f          	and    r13d,0xf
    while(value > 0){
  10a609:	4d 85 e4             	test   r12,r12
      dest[bytes_written++] = LOOKUP[value % base];
  10a60c:	45 0f b6 ad a0 16 10 	movzx  r13d,BYTE PTR [r13+0x1016a0]
  10a613:	00 
  10a614:	44 88 6c 18 ff       	mov    BYTE PTR [rax+rbx*1-0x1],r13b
    while(value > 0){
  10a619:	75 dc                	jne    10a5f7 <klog_write_fmt+0x467>
  for(size_t i = 0; i < midpoint; i++){
  10a61b:	49 89 dc             	mov    r12,rbx
  10a61e:	49 d1 ec             	shr    r12,1
  10a621:	0f 84 66 01 00 00    	je     10a78d <klog_write_fmt+0x5fd>
  10a627:	48 01 c2             	add    rdx,rax
  10a62a:	49 01 c4             	add    r12,rax
    str[i] = str[length - 1 - i];
  10a62d:	44 0f b6 32          	movzx  r14d,BYTE PTR [rdx]
    char oldValue = str[i];
  10a631:	44 0f b6 28          	movzx  r13d,BYTE PTR [rax]
  10a635:	48 83 c0 01          	add    rax,0x1
  10a639:	48 83 ea 01          	sub    rdx,0x1
    str[i] = str[length - 1 - i];
  10a63d:	44 88 70 ff          	mov    BYTE PTR [rax-0x1],r14b
    str[length - 1 - i] = oldValue;
  10a641:	44 88 6a 01          	mov    BYTE PTR [rdx+0x1],r13b
  for(size_t i = 0; i < midpoint; i++){
  10a645:	49 39 c4             	cmp    r12,rax
  10a648:	75 e3                	jne    10a62d <klog_write_fmt+0x49d>
  10a64a:	eb 9a                	jmp    10a5e6 <klog_write_fmt+0x456>
        uint64_t value = va_arg(args, uint64_t);
  10a64c:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  10a651:	48 8d 50 08          	lea    rdx,[rax+0x8]
  10a655:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  10a65a:	e9 61 ff ff ff       	jmp    10a5c0 <klog_write_fmt+0x430>
  10a65f:	90                   	nop
      dest[bytes_written++] = LOOKUP[value % base];
  10a660:	4d 89 ec             	mov    r12,r13
  10a663:	4c 89 f0             	mov    rax,r14
  10a666:	4d 8d 6c 24 01       	lea    r13,[r12+0x1]
  10a66b:	48 f7 e5             	mul    rbp
  10a66e:	48 89 d0             	mov    rax,rdx
  10a671:	48 c1 e8 03          	shr    rax,0x3
  10a675:	48 8d 14 80          	lea    rdx,[rax+rax*4]
  10a679:	48 01 d2             	add    rdx,rdx
  10a67c:	49 29 d6             	sub    r14,rdx
    while(value > 0){
  10a67f:	48 85 c0             	test   rax,rax
      dest[bytes_written++] = LOOKUP[value % base];
  10a682:	41 0f b6 96 a0 16 10 	movzx  edx,BYTE PTR [r14+0x1016a0]
  10a689:	00 
      value /= base;
  10a68a:	49 89 c6             	mov    r14,rax
      dest[bytes_written++] = LOOKUP[value % base];
  10a68d:	42 88 54 2b ff       	mov    BYTE PTR [rbx+r13*1-0x1],dl
    while(value > 0){
  10a692:	75 cc                	jne    10a660 <klog_write_fmt+0x4d0>
  for(size_t i = 0; i < midpoint; i++){
  10a694:	4d 89 ee             	mov    r14,r13
  10a697:	49 d1 ee             	shr    r14,1
  10a69a:	0f 84 f7 00 00 00    	je     10a797 <klog_write_fmt+0x607>
  10a6a0:	48 89 da             	mov    rdx,rbx
  10a6a3:	4a 8d 04 23          	lea    rax,[rbx+r12*1]
  10a6a7:	4a 8d 1c 33          	lea    rbx,[rbx+r14*1]
    str[i] = str[length - 1 - i];
  10a6ab:	44 0f b6 30          	movzx  r14d,BYTE PTR [rax]
    char oldValue = str[i];
  10a6af:	44 0f b6 22          	movzx  r12d,BYTE PTR [rdx]
  10a6b3:	48 83 c2 01          	add    rdx,0x1
  10a6b7:	48 83 e8 01          	sub    rax,0x1
    str[i] = str[length - 1 - i];
  10a6bb:	44 88 72 ff          	mov    BYTE PTR [rdx-0x1],r14b
    str[length - 1 - i] = oldValue;
  10a6bf:	44 88 60 01          	mov    BYTE PTR [rax+0x1],r12b
  for(size_t i = 0; i < midpoint; i++){
  10a6c3:	48 39 d3             	cmp    rbx,rdx
  10a6c6:	75 e3                	jne    10a6ab <klog_write_fmt+0x51b>
  10a6c8:	e9 57 fd ff ff       	jmp    10a424 <klog_write_fmt+0x294>
					uint64_t value = va_arg(args, uint64_t);
  10a6cd:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  10a6d2:	48 8d 50 08          	lea    rdx,[rax+0x8]
  10a6d6:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  10a6db:	e9 18 fd ff ff       	jmp    10a3f8 <klog_write_fmt+0x268>
				const char *str = (const char *)va_arg(args, uintptr_t);
  10a6e0:	8b 54 24 08          	mov    edx,DWORD PTR [rsp+0x8]
  10a6e4:	83 fa 2f             	cmp    edx,0x2f
  10a6e7:	0f 87 82 00 00 00    	ja     10a76f <klog_write_fmt+0x5df>
  10a6ed:	48 8d 5c 24 20       	lea    rbx,[rsp+0x20]
  10a6f2:	89 d0                	mov    eax,edx
  10a6f4:	83 c2 08             	add    edx,0x8
  10a6f7:	89 54 24 08          	mov    DWORD PTR [rsp+0x8],edx
  10a6fb:	48 01 d8             	add    rax,rbx
  10a6fe:	4c 8b 20             	mov    r12,QWORD PTR [rax]
	while (str[result] != 0)
  10a701:	41 80 3c 24 00       	cmp    BYTE PTR [r12],0x0
  10a706:	74 46                	je     10a74e <klog_write_fmt+0x5be>
  10a708:	31 d2                	xor    edx,edx
		result ++;
  10a70a:	48 83 c2 01          	add    rdx,0x1
	while (str[result] != 0)
  10a70e:	42 80 3c 22 00       	cmp    BYTE PTR [rdx+r12*1],0x0
  10a713:	75 f5                	jne    10a70a <klog_write_fmt+0x57a>
        if(bytes_written + length > capacity) return bytes_written;
  10a715:	49 8d 1c 13          	lea    rbx,[r11+rdx*1]
  10a719:	48 81 fb 00 01 00 00 	cmp    rbx,0x100
  10a720:	0f 87 bb fb ff ff    	ja     10a2e1 <klog_write_fmt+0x151>
  10a726:	31 c0                	xor    eax,eax
  10a728:	4d 01 cb             	add    r11,r9
		dest[i] = src[i];
  10a72b:	46 0f b6 2c 20       	movzx  r13d,BYTE PTR [rax+r12*1]
  10a730:	45 88 2c 03          	mov    BYTE PTR [r11+rax*1],r13b
	for (size_t i = 0; i < size; i++) {
  10a734:	48 83 c0 01          	add    rax,0x1
  10a738:	48 39 c2             	cmp    rdx,rax
  10a73b:	75 ee                	jne    10a72b <klog_write_fmt+0x59b>
				fmt_index++;
  10a73d:	49 83 c0 02          	add    r8,0x2
  10a741:	49 89 db             	mov    r11,rbx
  10a744:	42 0f b6 04 06       	movzx  eax,BYTE PTR [rsi+r8*1]
  10a749:	e9 1c fb ff ff       	jmp    10a26a <klog_write_fmt+0xda>
        if(bytes_written + length > capacity) return bytes_written;
  10a74e:	49 81 fb 00 01 00 00 	cmp    r11,0x100
  10a755:	0f 87 86 fb ff ff    	ja     10a2e1 <klog_write_fmt+0x151>
  10a75b:	4c 89 db             	mov    rbx,r11
				fmt_index++;
  10a75e:	49 83 c0 02          	add    r8,0x2
  10a762:	42 0f b6 04 06       	movzx  eax,BYTE PTR [rsi+r8*1]
  10a767:	49 89 db             	mov    r11,rbx
  10a76a:	e9 fb fa ff ff       	jmp    10a26a <klog_write_fmt+0xda>
				const char *str = (const char *)va_arg(args, uintptr_t);
  10a76f:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
  10a774:	48 8d 50 08          	lea    rdx,[rax+0x8]
  10a778:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  10a77d:	e9 7c ff ff ff       	jmp    10a6fe <klog_write_fmt+0x56e>
  for(size_t i = 0; i < midpoint; i++){
  10a782:	41 bd 01 00 00 00    	mov    r13d,0x1
  10a788:	e9 8a fd ff ff       	jmp    10a517 <klog_write_fmt+0x387>
  10a78d:	bb 01 00 00 00       	mov    ebx,0x1
  10a792:	e9 4f fe ff ff       	jmp    10a5e6 <klog_write_fmt+0x456>
  10a797:	41 bd 01 00 00 00    	mov    r13d,0x1
  10a79d:	e9 82 fc ff ff       	jmp    10a424 <klog_write_fmt+0x294>
  10a7a2:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
            const char *str = (const char *)va_arg(args, uintptr_t);
  10a7a7:	48 8d 50 08          	lea    rdx,[rax+0x8]
  10a7ab:	48 89 54 24 10       	mov    QWORD PTR [rsp+0x10],rdx
  10a7b0:	e9 de fc ff ff       	jmp    10a493 <klog_write_fmt+0x303>
            size_t str_length = (size_t)va_arg(args, uintptr_t);
  10a7b5:	48 8b 54 24 10       	mov    rdx,QWORD PTR [rsp+0x10]
  10a7ba:	48 8d 42 08          	lea    rax,[rdx+0x8]
  10a7be:	48 8b 1a             	mov    rbx,QWORD PTR [rdx]
  10a7c1:	eb e4                	jmp    10a7a7 <klog_write_fmt+0x617>
  10a7c3:	0f 1f 00             	nop    DWORD PTR [rax]
  10a7c6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a7cd:	00 00 00 

000000000010a7d0 <kmem_map_physical_to_virtual_2MB_ext>:
  kassert((virtual_address & 0x1FFFFF) == 0);
  10a7d0:	f7 c6 ff ff 1f 00    	test   esi,0x1fffff
void kmem_map_physical_to_virtual_2MB_ext(uintptr_t physical_address, uintptr_t virtual_address, uint64_t flags){
  10a7d6:	41 54                	push   r12
  10a7d8:	49 89 fc             	mov    r12,rdi
  10a7db:	55                   	push   rbp
  10a7dc:	48 89 d5             	mov    rbp,rdx
  10a7df:	53                   	push   rbx
  10a7e0:	48 89 f3             	mov    rbx,rsi
  kassert((virtual_address & 0x1FFFFF) == 0);
  10a7e3:	75 5b                	jne    10a840 <kmem_map_physical_to_virtual_2MB_ext+0x70>
  kassert((physical_address & 0x1FFFFF) == 0);
  10a7e5:	41 f7 c4 ff ff 1f 00 	test   r12d,0x1fffff
  10a7ec:	74 2d                	je     10a81b <kmem_map_physical_to_virtual_2MB_ext+0x4b>
  10a7ee:	41 b8 9c 0c 10 00    	mov    r8d,0x100c9c
  10a7f4:	b9 27 00 00 00       	mov    ecx,0x27
  10a7f9:	ba b0 12 10 00       	mov    edx,0x1012b0
  10a7fe:	be 80 12 10 00       	mov    esi,0x101280
  10a803:	31 c0                	xor    eax,eax
  10a805:	bf 60 01 11 00       	mov    edi,0x110160
  10a80a:	e8 81 f9 ff ff       	call   10a190 <klog_write_fmt>
  10a80f:	bf 60 01 11 00       	mov    edi,0x110160
  10a814:	e8 57 e9 ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10a819:	fa                   	cli    
  10a81a:	f4                   	hlt    
  uintptr_t p2_index = (virtual_address >> 21) & 0x1FF;
  10a81b:	48 c1 eb 15          	shr    rbx,0x15
  g_p2_table.entries[p2_index] = physical_address | PAGE_PRESENT_BIT | PAGE_HUGE_BIT | PAGE_WRITEABLE_BIT | flags;
  10a81f:	40 80 cd 83          	or     bpl,0x83
  10a823:	4c 09 e5             	or     rbp,r12
  uintptr_t p2_index = (virtual_address >> 21) & 0x1FF;
  10a826:	81 e3 ff 01 00 00    	and    ebx,0x1ff
  g_p2_table.entries[p2_index] = physical_address | PAGE_PRESENT_BIT | PAGE_HUGE_BIT | PAGE_WRITEABLE_BIT | flags;
  10a82c:	48 89 2c dd 00 40 12 	mov    QWORD PTR [rbx*8+0x124000],rbp
  10a833:	00 
}
  10a834:	5b                   	pop    rbx
  10a835:	5d                   	pop    rbp
  10a836:	41 5c                	pop    r12
  10a838:	c3                   	ret    
  10a839:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  kassert((virtual_address & 0x1FFFFF) == 0);
  10a840:	41 b8 9c 0c 10 00    	mov    r8d,0x100c9c
  10a846:	b9 26 00 00 00       	mov    ecx,0x26
  10a84b:	ba 58 12 10 00       	mov    edx,0x101258
  10a850:	be 80 12 10 00       	mov    esi,0x101280
  10a855:	31 c0                	xor    eax,eax
  10a857:	bf 60 01 11 00       	mov    edi,0x110160
  10a85c:	e8 2f f9 ff ff       	call   10a190 <klog_write_fmt>
  10a861:	bf 60 01 11 00       	mov    edi,0x110160
  10a866:	e8 05 e9 ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10a86b:	fa                   	cli    
  10a86c:	f4                   	hlt    
  10a86d:	e9 73 ff ff ff       	jmp    10a7e5 <kmem_map_physical_to_virtual_2MB_ext+0x15>
  10a872:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  10a876:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a87d:	00 00 00 

000000000010a880 <kmem_map_unaligned_physical_to_aligned_virtual_2MB>:
uintptr_t kmem_map_unaligned_physical_to_aligned_virtual_2MB(uintptr_t requested_physical_address, uintptr_t virtual_address, uint64_t flags){
  10a880:	53                   	push   rbx
	uint64_t displacement_from_page_boundray = requested_physical_address & 0x1FFFFF;
  10a881:	48 89 fb             	mov    rbx,rdi
  10a884:	81 e3 ff ff 1f 00    	and    ebx,0x1fffff
  physical_address_to_map -= displacement_from_page_boundray;
  10a88a:	48 29 df             	sub    rdi,rbx
  kmem_map_physical_to_virtual_2MB_ext(physical_address_to_map, virtual_address, flags);
  10a88d:	e8 3e ff ff ff       	call   10a7d0 <kmem_map_physical_to_virtual_2MB_ext>
}
  10a892:	48 89 d8             	mov    rax,rbx
  10a895:	5b                   	pop    rbx
  10a896:	c3                   	ret    
  10a897:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  10a89e:	00 00 

000000000010a8a0 <parse_root_system_descriptor>:

void parse_root_system_descriptor(const RSDP_Descriptor_1 *rsdp, System_Info *sys) {
	if((rsdp->signature[0] == 'R' && rsdp->signature[1] == 'S' &&
      rsdp->signature[2] == 'D' && rsdp->signature[3] == ' ' &&
      rsdp->signature[4] == 'P' && rsdp->signature[5] == 'T' &&
      rsdp->signature[6] == 'R' && rsdp->signature[7] == ' ') == 0) {
  10a8a0:	80 3f 52             	cmp    BYTE PTR [rdi],0x52
  10a8a3:	74 1b                	je     10a8c0 <parse_root_system_descriptor+0x20>
    klog_error("RSDP is invalid!");
  10a8a5:	be c6 0c 10 00       	mov    esi,0x100cc6
  10a8aa:	bf 60 01 11 00       	mov    edi,0x110160
  10a8af:	31 c0                	xor    eax,eax
  10a8b1:	e9 da f8 ff ff       	jmp    10a190 <klog_write_fmt>
  10a8b6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10a8bd:	00 00 00 
	if((rsdp->signature[0] == 'R' && rsdp->signature[1] == 'S' &&
  10a8c0:	80 7f 01 53          	cmp    BYTE PTR [rdi+0x1],0x53
  10a8c4:	75 df                	jne    10a8a5 <parse_root_system_descriptor+0x5>
  10a8c6:	80 7f 02 44          	cmp    BYTE PTR [rdi+0x2],0x44
  10a8ca:	75 d9                	jne    10a8a5 <parse_root_system_descriptor+0x5>
      rsdp->signature[2] == 'D' && rsdp->signature[3] == ' ' &&
  10a8cc:	80 7f 03 20          	cmp    BYTE PTR [rdi+0x3],0x20
  10a8d0:	75 d3                	jne    10a8a5 <parse_root_system_descriptor+0x5>
  10a8d2:	80 7f 04 50          	cmp    BYTE PTR [rdi+0x4],0x50
  10a8d6:	75 cd                	jne    10a8a5 <parse_root_system_descriptor+0x5>
      rsdp->signature[4] == 'P' && rsdp->signature[5] == 'T' &&
  10a8d8:	80 7f 05 54          	cmp    BYTE PTR [rdi+0x5],0x54
  10a8dc:	75 c7                	jne    10a8a5 <parse_root_system_descriptor+0x5>
  10a8de:	80 7f 06 52          	cmp    BYTE PTR [rdi+0x6],0x52
  10a8e2:	75 c1                	jne    10a8a5 <parse_root_system_descriptor+0x5>
      rsdp->signature[6] == 'R' && rsdp->signature[7] == ' ') == 0) {
  10a8e4:	80 7f 07 20          	cmp    BYTE PTR [rdi+0x7],0x20
  10a8e8:	75 bb                	jne    10a8a5 <parse_root_system_descriptor+0x5>
void parse_root_system_descriptor(const RSDP_Descriptor_1 *rsdp, System_Info *sys) {
  10a8ea:	41 57                	push   r15
  10a8ec:	41 56                	push   r14
  kmem_map_physical_to_virtual_2MB_ext(physical_address_to_map, virtual_address, flags);
  10a8ee:	31 d2                	xor    edx,edx
  10a8f0:	41 55                	push   r13
  10a8f2:	41 54                	push   r12
  10a8f4:	49 89 fd             	mov    r13,rdi
  10a8f7:	55                   	push   rbp
  10a8f8:	53                   	push   rbx
  10a8f9:	49 89 f6             	mov    r14,rsi
  10a8fc:	be 00 00 60 0c       	mov    esi,0xc600000
  10a901:	48 83 ec 10          	sub    rsp,0x10
    return;
  } 

  //TODO(Torin) This should be a temporary page!
  uintptr_t virtual_address = 0x0C600000;
  uintptr_t page_offset = kmem_map_unaligned_physical_to_aligned_virtual_2MB(rsdp->rsdt_address, virtual_address, 0); 
  10a905:	8b 7f 10             	mov    edi,DWORD PTR [rdi+0x10]
	uint64_t displacement_from_page_boundray = requested_physical_address & 0x1FFFFF;
  10a908:	41 89 ff             	mov    r15d,edi
  10a90b:	41 81 e7 ff ff 1f 00 	and    r15d,0x1fffff
  physical_address_to_map -= displacement_from_page_boundray;
  10a912:	4c 29 ff             	sub    rdi,r15
  kmem_map_physical_to_virtual_2MB_ext(physical_address_to_map, virtual_address, flags);
  10a915:	e8 b6 fe ff ff       	call   10a7d0 <kmem_map_physical_to_virtual_2MB_ext>
  ACPI_SDT_Header *rsdt = (ACPI_SDT_Header *)(virtual_address + page_offset);
  10a91a:	49 8d 87 00 00 60 0c 	lea    rax,[r15+0xc600000]
  10a921:	48 89 04 24          	mov    QWORD PTR [rsp],rax
  uint32_t entry_count = (rsdt->length - sizeof(ACPI_SDT_Header)) / 4;
  10a925:	41 8b 87 04 00 60 0c 	mov    eax,DWORD PTR [r15+0xc600004]
  10a92c:	48 83 e8 24          	sub    rax,0x24
  10a930:	48 c1 e8 02          	shr    rax,0x2
  10a934:	89 c0                	mov    eax,eax
  uint32_t *entries = (uint32_t *)(rsdt + 1);
  for(size_t i = 0; i < entry_count; i++){
  10a936:	48 85 c0             	test   rax,rax
  10a939:	0f 84 21 01 00 00    	je     10aa60 <parse_root_system_descriptor+0x1c0>
  10a93f:	49 8d 04 87          	lea    rax,[r15+rax*4]
  10a943:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
  10a948:	eb 20                	jmp    10a96a <parse_root_system_descriptor+0xca>
  10a94a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

        madt_entry = (MADT_Entry_Header *)((uintptr_t)madt_entry + madt_entry->entry_length); 
      }
    } 

    else if (header->signature == ACPI_MCFG_SIGNATURE){
  10a950:	3d 4d 43 46 47       	cmp    eax,0x4746434d
  10a955:	0f 84 e5 00 00 00    	je     10aa40 <parse_root_system_descriptor+0x1a0>
  10a95b:	49 83 c7 04          	add    r15,0x4
  for(size_t i = 0; i < entry_count; i++){
  10a95f:	4c 39 7c 24 08       	cmp    QWORD PTR [rsp+0x8],r15
  10a964:	0f 84 f6 00 00 00    	je     10aa60 <parse_root_system_descriptor+0x1c0>
    int64_t physical_offset = header_physical_addr - rsdp->rsdt_address;
  10a96a:	41 8b 45 10          	mov    eax,DWORD PTR [r13+0x10]
    uintptr_t entry_address = virtual_address + page_offset + physical_offset;
  10a96e:	4c 8b 24 24          	mov    r12,QWORD PTR [rsp]
  10a972:	49 29 c4             	sub    r12,rax
    uintptr_t header_physical_addr = (uintptr_t)entries[i];
  10a975:	41 8b 87 24 00 60 0c 	mov    eax,DWORD PTR [r15+0xc600024]
    uintptr_t entry_address = virtual_address + page_offset + physical_offset;
  10a97c:	49 01 c4             	add    r12,rax
    if(header->signature == ACPI_MADT_SIGNATURE) {
  10a97f:	41 8b 04 24          	mov    eax,DWORD PTR [r12]
  10a983:	3d 41 50 49 43       	cmp    eax,0x43495041
  10a988:	75 c6                	jne    10a950 <parse_root_system_descriptor+0xb0>
      while(((uintptr_t)madt_entry - (uintptr_t)madt) < madt->header.length) 
  10a98a:	41 8b 74 24 04       	mov    esi,DWORD PTR [r12+0x4]
      sys->lapic_physical_address = madt->local_controler_address;
  10a98f:	41 8b 44 24 24       	mov    eax,DWORD PTR [r12+0x24]
      MADT_Entry_Header *madt_entry = (MADT_Entry_Header *)(madt + 1);
  10a994:	49 8d 6c 24 2c       	lea    rbp,[r12+0x2c]
      while(((uintptr_t)madt_entry - (uintptr_t)madt) < madt->header.length) 
  10a999:	48 89 eb             	mov    rbx,rbp
  10a99c:	48 83 fe 2c          	cmp    rsi,0x2c
      sys->lapic_physical_address = madt->local_controler_address;
  10a9a0:	49 89 06             	mov    QWORD PTR [r14],rax
      while(((uintptr_t)madt_entry - (uintptr_t)madt) < madt->header.length) 
  10a9a3:	77 32                	ja     10a9d7 <parse_root_system_descriptor+0x137>
  10a9a5:	eb b4                	jmp    10a95b <parse_root_system_descriptor+0xbb>
  10a9a7:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  10a9ae:	00 00 
        switch(madt_entry->entry_type){
  10a9b0:	3c 01                	cmp    al,0x1
  10a9b2:	75 0e                	jne    10a9c2 <parse_root_system_descriptor+0x122>
            if(sys->ioapic_physical_address != 0){
  10a9b4:	49 83 7e 08 00       	cmp    QWORD PTR [r14+0x8],0x0
  10a9b9:	75 45                	jne    10aa00 <parse_root_system_descriptor+0x160>
              sys->ioapic_physical_address = ioapic->io_apic_address;
  10a9bb:	8b 45 04             	mov    eax,DWORD PTR [rbp+0x4]
  10a9be:	49 89 46 08          	mov    QWORD PTR [r14+0x8],rax
        madt_entry = (MADT_Entry_Header *)((uintptr_t)madt_entry + madt_entry->entry_length); 
  10a9c2:	0f b6 45 01          	movzx  eax,BYTE PTR [rbp+0x1]
  10a9c6:	48 01 c3             	add    rbx,rax
      while(((uintptr_t)madt_entry - (uintptr_t)madt) < madt->header.length) 
  10a9c9:	48 89 d8             	mov    rax,rbx
        madt_entry = (MADT_Entry_Header *)((uintptr_t)madt_entry + madt_entry->entry_length); 
  10a9cc:	48 89 dd             	mov    rbp,rbx
      while(((uintptr_t)madt_entry - (uintptr_t)madt) < madt->header.length) 
  10a9cf:	4c 29 e0             	sub    rax,r12
  10a9d2:	48 39 f0             	cmp    rax,rsi
  10a9d5:	73 84                	jae    10a95b <parse_root_system_descriptor+0xbb>
        switch(madt_entry->entry_type){
  10a9d7:	0f b6 45 00          	movzx  eax,BYTE PTR [rbp+0x0]
  10a9db:	84 c0                	test   al,al
  10a9dd:	75 d1                	jne    10a9b0 <parse_root_system_descriptor+0x110>
            if(sys->cpu_count < ARRAY_COUNT(sys->cpu_lapic_ids)){
  10a9df:	41 8b 46 68          	mov    eax,DWORD PTR [r14+0x68]
  10a9e3:	83 f8 0f             	cmp    eax,0xf
  10a9e6:	77 38                	ja     10aa20 <parse_root_system_descriptor+0x180>
              sys->cpu_lapic_ids[sys->cpu_count] = local_apic->apic_id;
  10a9e8:	44 0f b6 45 03       	movzx  r8d,BYTE PTR [rbp+0x3]
  10a9ed:	89 c7                	mov    edi,eax
              sys->cpu_count++;
  10a9ef:	83 c0 01             	add    eax,0x1
              sys->cpu_lapic_ids[sys->cpu_count] = local_apic->apic_id;
  10a9f2:	45 89 44 be 28       	mov    DWORD PTR [r14+rdi*4+0x28],r8d
              sys->cpu_count++;
  10a9f7:	41 89 46 68          	mov    DWORD PTR [r14+0x68],eax
  10a9fb:	eb c5                	jmp    10a9c2 <parse_root_system_descriptor+0x122>
  10a9fd:	0f 1f 00             	nop    DWORD PTR [rax]
              klog_warning("[acpi] system contains multiple ioapics");
  10aa00:	be 00 13 10 00       	mov    esi,0x101300
  10aa05:	bf 60 01 11 00       	mov    edi,0x110160
  10aa0a:	31 c0                	xor    eax,eax
  10aa0c:	e8 7f f7 ff ff       	call   10a190 <klog_write_fmt>
  10aa11:	41 8b 74 24 04       	mov    esi,DWORD PTR [r12+0x4]
  10aa16:	eb aa                	jmp    10a9c2 <parse_root_system_descriptor+0x122>
  10aa18:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  10aa1f:	00 
              klog_warning("only 32 cpus are currently supported!");
  10aa20:	be d8 12 10 00       	mov    esi,0x1012d8
  10aa25:	bf 60 01 11 00       	mov    edi,0x110160
  10aa2a:	31 c0                	xor    eax,eax
  10aa2c:	e8 5f f7 ff ff       	call   10a190 <klog_write_fmt>
  10aa31:	41 8b 74 24 04       	mov    esi,DWORD PTR [r12+0x4]
  10aa36:	eb 8a                	jmp    10a9c2 <parse_root_system_descriptor+0x122>
  10aa38:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  10aa3f:	00 
      klog_debug("found MCFG ACPI table");
  10aa40:	31 c0                	xor    eax,eax
  10aa42:	be b0 0c 10 00       	mov    esi,0x100cb0
  10aa47:	bf 60 01 11 00       	mov    edi,0x110160
  10aa4c:	e8 3f f7 ff ff       	call   10a190 <klog_write_fmt>
  10aa51:	49 83 c7 04          	add    r15,0x4
  for(size_t i = 0; i < entry_count; i++){
  10aa55:	4c 39 7c 24 08       	cmp    QWORD PTR [rsp+0x8],r15
  10aa5a:	0f 85 0a ff ff ff    	jne    10a96a <parse_root_system_descriptor+0xca>
    }


  }  
}
  10aa60:	48 83 c4 10          	add    rsp,0x10
  10aa64:	5b                   	pop    rbx
  10aa65:	5d                   	pop    rbp
  10aa66:	41 5c                	pop    r12
  10aa68:	41 5d                	pop    r13
  10aa6a:	41 5e                	pop    r14
  10aa6c:	41 5f                	pop    r15
  10aa6e:	c3                   	ret    
  10aa6f:	90                   	nop

000000000010aa70 <ehci_initalize>:
  status |= PORT_CHANGE_MASK & data;
  *port = status;
  #undef PORT_CHANGE_MASK
}

void ehci_initalize(uintptr_t ehci_physical_address){
  10aa70:	41 55                	push   r13
  10aa72:	41 54                	push   r12
  klog_debug("starting ehci initalization...");
  10aa74:	31 c0                	xor    eax,eax
void ehci_initalize(uintptr_t ehci_physical_address){
  10aa76:	55                   	push   rbp
  10aa77:	48 89 fd             	mov    rbp,rdi
  10aa7a:	53                   	push   rbx
  klog_debug("starting ehci initalization...");
  10aa7b:	be 28 13 10 00       	mov    esi,0x101328
	uint64_t displacement_from_page_boundray = requested_physical_address & 0x1FFFFF;
  10aa80:	48 89 eb             	mov    rbx,rbp
  10aa83:	bf 60 01 11 00       	mov    edi,0x110160
  10aa88:	e8 03 f7 ff ff       	call   10a190 <klog_write_fmt>
  10aa8d:	81 e3 ff ff 1f 00    	and    ebx,0x1fffff
  physical_address_to_map -= displacement_from_page_boundray;
  10aa93:	48 89 ef             	mov    rdi,rbp
  kmem_map_physical_to_virtual_2MB_ext(physical_address_to_map, virtual_address, flags);
  10aa96:	31 d2                	xor    edx,edx
  physical_address_to_map -= displacement_from_page_boundray;
  10aa98:	48 29 df             	sub    rdi,rbx
  kmem_map_physical_to_virtual_2MB_ext(physical_address_to_map, virtual_address, flags);
  10aa9b:	be 00 00 00 01       	mov    esi,0x1000000

  //TODO(Torin 2016-09-16) Idealy this memory_map should occur in a different location
  uintptr_t ehci_virtual_page = 0x1000000;  
  uintptr_t page_offset = kmem_map_unaligned_physical_to_aligned_virtual_2MB(ehci_physical_address, ehci_virtual_page, 0); 
  uintptr_t ehci_virtual_address = page_offset + ehci_virtual_page;
  10aaa0:	48 8d ab 00 00 00 01 	lea    rbp,[rbx+0x1000000]
  10aaa7:	e8 24 fd ff ff       	call   10a7d0 <kmem_map_physical_to_virtual_2MB_ext>

  EHCI_Capability_Registers *cap_regs = (EHCI_Capability_Registers *)ehci_virtual_address;
  klog_debug("capabilites_length: %u", (uint32_t)cap_regs->capability_length);
  10aaac:	0f b6 93 00 00 00 01 	movzx  edx,BYTE PTR [rbx+0x1000000]
  10aab3:	31 c0                	xor    eax,eax
  10aab5:	be d7 0c 10 00       	mov    esi,0x100cd7
  10aaba:	bf 60 01 11 00       	mov    edi,0x110160
  10aabf:	e8 cc f6 ff ff       	call   10a190 <klog_write_fmt>
  uintptr_t operational_register_base = ehci_virtual_address + cap_regs->capability_length;
  10aac4:	0f b6 9b 00 00 00 01 	movzx  ebx,BYTE PTR [rbx+0x1000000]
  10aacb:	48 01 eb             	add    rbx,rbp
      //if PCIe works as expected
    }

    //TODO(Torin 2016-09-16) Find out when it is appropiate to use 64bit data structures
    //for the EHCI operational data structures
    if(addressing_capability == ADDRESSING_CAPABILITY_32){
  10aace:	f6 45 08 01          	test   BYTE PTR [rbp+0x8],0x1
  10aad2:	0f 85 9b 01 00 00    	jne    10ac73 <ehci_initalize+0x203>
      klog_error("hhcparams does not support 64bit addressing"); 
  10aad8:	be 48 13 10 00       	mov    esi,0x101348
  10aadd:	bf 60 01 11 00       	mov    edi,0x110160
  10aae2:	31 c0                	xor    eax,eax
  10aae4:	e8 a7 f6 ff ff       	call   10a190 <klog_write_fmt>
  size_t port_count = 0;
  bool is_port_power_control_enabled = false;
  { //NOTE(Torin 2016-09-17) Extract HCSPARAMS information
    static const uint32_t HCS_PORT_COUNT_MASK = 0b1111;
    static const uint32_t POWER_PORT_CONTROL_BIT = 1 << 4;
    port_count = cap_regs->hcs_params & HCS_PORT_COUNT_MASK; 
  10aae9:	44 8b 6d 04          	mov    r13d,DWORD PTR [rbp+0x4]
    is_port_power_control_enabled = cap_regs->hcs_params & POWER_PORT_CONTROL_BIT;
  }

  klog_debug("port count: %lu", port_count);
  10aaed:	be ee 0c 10 00       	mov    esi,0x100cee
  10aaf2:	bf 60 01 11 00       	mov    edi,0x110160
  10aaf7:	31 c0                	xor    eax,eax
  10aaf9:	44 89 ed             	mov    ebp,r13d
  10aafc:	83 e5 0f             	and    ebp,0xf
    port_count = cap_regs->hcs_params & HCS_PORT_COUNT_MASK; 
  10aaff:	41 89 ec             	mov    r12d,ebp
  klog_debug("port count: %lu", port_count);
  10ab02:	4c 89 e2             	mov    rdx,r12
  10ab05:	e8 86 f6 ff ff       	call   10a190 <klog_write_fmt>
    is_port_power_control_enabled = cap_regs->hcs_params & POWER_PORT_CONTROL_BIT;
  10ab0a:	44 89 ea             	mov    edx,r13d
  klog_debug("is_port_power_control_enabled: %u", (uint32_t)is_port_power_control_enabled);
  10ab0d:	31 c0                	xor    eax,eax
  10ab0f:	be a8 13 10 00       	mov    esi,0x1013a8
    is_port_power_control_enabled = cap_regs->hcs_params & POWER_PORT_CONTROL_BIT;
  10ab14:	c1 ea 04             	shr    edx,0x4
  klog_debug("is_port_power_control_enabled: %u", (uint32_t)is_port_power_control_enabled);
  10ab17:	bf 60 01 11 00       	mov    edi,0x110160
    is_port_power_control_enabled = cap_regs->hcs_params & POWER_PORT_CONTROL_BIT;
  10ab1c:	83 e2 01             	and    edx,0x1
  klog_debug("is_port_power_control_enabled: %u", (uint32_t)is_port_power_control_enabled);
  10ab1f:	e8 6c f6 ff ff       	call   10a190 <klog_write_fmt>
  10ab24:	b8 80 00 11 00       	mov    eax,0x110080
  10ab29:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		dest[i] = value;
  10ab30:	c6 00 00             	mov    BYTE PTR [rax],0x0
  10ab33:	48 83 c0 01          	add    rax,0x1
  for (size_t i = 0; i < size; i++) {
  10ab37:	48 3d b0 00 11 00    	cmp    rax,0x1100b0
  10ab3d:	75 f1                	jne    10ab30 <ehci_initalize+0xc0>
  10ab3f:	90                   	nop
		dest[i] = value;
  10ab40:	c6 00 00             	mov    BYTE PTR [rax],0x0
  10ab43:	48 83 c0 01          	add    rax,0x1
  for (size_t i = 0; i < size; i++) {
  10ab47:	48 3d e0 00 11 00    	cmp    rax,0x1100e0
  10ab4d:	75 f1                	jne    10ab40 <ehci_initalize+0xd0>
    EHCI_Queue_Head *periodic_qh = &g_ehci.periodic_qh;
    memset(asynch_qh, 0x00, sizeof(EHCI_Queue_Head));
    memset(periodic_qh, 0x00, sizeof(EHCI_Queue_Head));

    //NOTE(Torin 2016-09-10) Setup the Asynch_Queue_Head
    asynch_qh->horizontal_link_pointer = ((uint32_t)(uintptr_t)(asynch_qh)) | EHCI_POINTER_TYPE_QH;
  10ab4f:	b8 80 00 11 00       	mov    eax,0x110080
    asynch_qh->endpoint_characteristics = 0; //TODO(Torin 2016-09-06) This needs somthing
  10ab54:	c7 05 26 55 00 00 00 	mov    DWORD PTR [rip+0x5526],0x0        # 110084 <g_ehci+0x1084>
  10ab5b:	00 00 00 
    asynch_qh->current_td = EHCI_POINTER_TERMINATE;
  10ab5e:	c7 05 24 55 00 00 01 	mov    DWORD PTR [rip+0x5524],0x1        # 11008c <g_ehci+0x108c>
  10ab65:	00 00 00 
    asynch_qh->horizontal_link_pointer = ((uint32_t)(uintptr_t)(asynch_qh)) | EHCI_POINTER_TYPE_QH;
  10ab68:	44 8d 28             	lea    r13d,[rax]
  10ab6b:	83 c8 02             	or     eax,0x2
    asynch_qh->next_td = EHCI_POINTER_TERMINATE;
  10ab6e:	c7 05 18 55 00 00 01 	mov    DWORD PTR [rip+0x5518],0x1        # 110090 <g_ehci+0x1090>
  10ab75:	00 00 00 
    asynch_qh->horizontal_link_pointer = ((uint32_t)(uintptr_t)(asynch_qh)) | EHCI_POINTER_TYPE_QH;
  10ab78:	89 05 02 55 00 00    	mov    DWORD PTR [rip+0x5502],eax        # 110080 <g_ehci+0x1080>
  10ab7e:	b8 b0 00 11 00       	mov    eax,0x1100b0
    asynch_qh->alt_next_td = EHCI_POINTER_TERMINATE;
  10ab83:	c7 05 07 55 00 00 01 	mov    DWORD PTR [rip+0x5507],0x1        # 110094 <g_ehci+0x1094>
  10ab8a:	00 00 00 
  10ab8d:	8d 10                	lea    edx,[rax]

    periodic_qh->horizontal_link_pointer = EHCI_POINTER_TERMINATE;
  10ab8f:	c7 05 17 55 00 00 01 	mov    DWORD PTR [rip+0x5517],0x1        # 1100b0 <g_ehci+0x10b0>
  10ab96:	00 00 00 
    periodic_qh->current_td = EHCI_POINTER_TERMINATE;
  10ab99:	c7 05 19 55 00 00 01 	mov    DWORD PTR [rip+0x5519],0x1        # 1100bc <g_ehci+0x10bc>
  10aba0:	00 00 00 
    periodic_qh->next_td = EHCI_POINTER_TERMINATE;
  10aba3:	c7 05 13 55 00 00 01 	mov    DWORD PTR [rip+0x5513],0x1        # 1100c0 <g_ehci+0x10c0>
  10abaa:	00 00 00 
    periodic_qh->alt_next_td = EHCI_POINTER_TERMINATE;
  10abad:	c7 05 0d 55 00 00 01 	mov    DWORD PTR [rip+0x550d],0x1        # 1100c4 <g_ehci+0x10c4>
  10abb4:	00 00 00 
  10abb7:	b8 00 f0 10 00       	mov    eax,0x10f000
  10abbc:	83 ca 03             	or     edx,0x3
  10abbf:	b9 00 00 11 00       	mov    ecx,0x110000
  10abc4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

    uint32_t *periodic_frame_list = g_ehci.periodic_frame_list;
    for(size_t i = 0; i < 1024; i++){
      periodic_frame_list[i] = (uint32_t)(uintptr_t)periodic_qh | EHCI_POINTER_TYPE_QH | EHCI_POINTER_TERMINATE;
  10abc8:	89 10                	mov    DWORD PTR [rax],edx
  10abca:	48 83 c0 04          	add    rax,0x4
    for(size_t i = 0; i < 1024; i++){
  10abce:	48 39 c1             	cmp    rcx,rax
  10abd1:	75 f5                	jne    10abc8 <ehci_initalize+0x158>
    }
  }

  klog_debug("queue heads initalized");
  10abd3:	31 c0                	xor    eax,eax
  10abd5:	be fe 0c 10 00       	mov    esi,0x100cfe
  10abda:	bf 60 01 11 00       	mov    edi,0x110160
  10abdf:	e8 ac f5 ff ff       	call   10a190 <klog_write_fmt>
      USBCMD_PERIODIC_SCHEDULE_ENABLE | USBCMD_ASYNCH_SCHEDULE_ENABLE | USBCMD_RUN_STOP; 
    op_regs->config_flag = ROUTE_PORTS_TO_HOST_EHCI;

    //TODO(Torin 2016-09-17) More robust waiting mechanisim
    size_t watchdog = 0x00;
    while((op_regs->usb_status & USBSTATUS_CONTROLLER_HALTED) && watchdog < 0xFFFFFF) { 
  10abe4:	f6 43 05 10          	test   BYTE PTR [rbx+0x5],0x10
    op_regs->perodic_list_base = (uint32_t)(uintptr_t)g_ehci.periodic_frame_list;
  10abe8:	b8 00 f0 10 00       	mov    eax,0x10f000
    op_regs->ctrl_ds_segment = 0;
  10abed:	c7 43 10 00 00 00 00 	mov    DWORD PTR [rbx+0x10],0x0
    op_regs->usb_interrupt = 0;
  10abf4:	c7 43 08 00 00 00 00 	mov    DWORD PTR [rbx+0x8],0x0
    op_regs->perodic_list_base = (uint32_t)(uintptr_t)g_ehci.periodic_frame_list;
  10abfb:	89 43 14             	mov    DWORD PTR [rbx+0x14],eax
    op_regs->async_list_address = (uint32_t)(uintptr_t)&g_ehci.asynch_qh;
  10abfe:	44 89 6b 18          	mov    DWORD PTR [rbx+0x18],r13d
    op_regs->frame_index = 0;
  10ac02:	c7 43 0c 00 00 00 00 	mov    DWORD PTR [rbx+0xc],0x0
    op_regs->usb_command = USBCMD_INTERRUPT_THRESHOLD_CONTROL_8 | 
  10ac09:	c7 03 31 00 08 00    	mov    DWORD PTR [rbx],0x80031
    op_regs->config_flag = ROUTE_PORTS_TO_HOST_EHCI;
  10ac0f:	c7 43 1c 01 00 00 00 	mov    DWORD PTR [rbx+0x1c],0x1
    while((op_regs->usb_status & USBSTATUS_CONTROLLER_HALTED) && watchdog < 0xFFFFFF) { 
  10ac16:	74 48                	je     10ac60 <ehci_initalize+0x1f0>
       watchdog++; 
    } 
    if(watchdog == 0xFFFFFF) {
      klog_debug("ehci controller failed to start");
  10ac18:	be d0 13 10 00       	mov    esi,0x1013d0
  10ac1d:	bf 60 01 11 00       	mov    edi,0x110160
  10ac22:	31 c0                	xor    eax,eax
  10ac24:	e8 67 f5 ff ff       	call   10a190 <klog_write_fmt>
  }

    
  
  { //NOTE(Torin 2016-09-06) Probe the ports managed by this controler
    klog_debug("enumerating %lu ports", port_count);
  10ac29:	31 c0                	xor    eax,eax
  10ac2b:	4c 89 e2             	mov    rdx,r12
  10ac2e:	be 31 0d 10 00       	mov    esi,0x100d31
  10ac33:	bf 60 01 11 00       	mov    edi,0x110160
  10ac38:	e8 53 f5 ff ff       	call   10a190 <klog_write_fmt>
    uintptr_t port_base = operational_register_base + 0x44;
    for(size_t i = 0; i < port_count; i++){
  10ac3d:	85 ed                	test   ebp,ebp
  10ac3f:	74 48                	je     10ac89 <ehci_initalize+0x219>
      static const uint32_t PORT_CONNECT_CURRENT_STATUS = 1 << 0;
      static const uint32_t PORT_CONNECT_STATUS_CHANGED_BIT = 1 << 1;
      static const uint32_t PORT_POWER_BIT = 1 << 12;
      uint32_t volatile *port_reg = &op_regs->ports[i];

      *port_reg |= PORT_POWER_BIT;
  10ac41:	8b 43 20             	mov    eax,DWORD PTR [rbx+0x20]
  10ac44:	80 cc 10             	or     ah,0x10
  10ac47:	89 43 20             	mov    DWORD PTR [rbx+0x20],eax
      *port_reg &= ~PORT_ENABLED_BIT;
  10ac4a:	8b 43 20             	mov    eax,DWORD PTR [rbx+0x20]
  10ac4d:	83 e0 fb             	and    eax,0xfffffffb
  10ac50:	89 43 20             	mov    DWORD PTR [rbx+0x20],eax
      *port_reg |= PORT_RESET_BIT;
  10ac53:	8b 43 20             	mov    eax,DWORD PTR [rbx+0x20]
  10ac56:	80 cc 01             	or     ah,0x1
  10ac59:	89 43 20             	mov    DWORD PTR [rbx+0x20],eax
  10ac5c:	eb fe                	jmp    10ac5c <ehci_initalize+0x1ec>
  10ac5e:	66 90                	xchg   ax,ax
      klog_debug("ehci controller was started");
  10ac60:	be 15 0d 10 00       	mov    esi,0x100d15
  10ac65:	bf 60 01 11 00       	mov    edi,0x110160
  10ac6a:	31 c0                	xor    eax,eax
  10ac6c:	e8 1f f5 ff ff       	call   10a190 <klog_write_fmt>
  10ac71:	eb b6                	jmp    10ac29 <ehci_initalize+0x1b9>
      klog_debug("usb host controller supports 64bit addressing");
  10ac73:	be 78 13 10 00       	mov    esi,0x101378
  10ac78:	bf 60 01 11 00       	mov    edi,0x110160
  10ac7d:	31 c0                	xor    eax,eax
  10ac7f:	e8 0c f5 ff ff       	call   10a190 <klog_write_fmt>
  10ac84:	e9 60 fe ff ff       	jmp    10aae9 <ehci_initalize+0x79>
      } else {
        klog_debug("no device connected to port %lu", i);
      }
    }
  }
  klog_debug("echi was initalized");
  10ac89:	bf 60 01 11 00       	mov    edi,0x110160
  10ac8e:	be 47 0d 10 00       	mov    esi,0x100d47
  10ac93:	31 c0                	xor    eax,eax
  10ac95:	e8 f6 f4 ff ff       	call   10a190 <klog_write_fmt>

  kgfx_draw_log_if_dirty(&globals.log);
}
  10ac9a:	5b                   	pop    rbx
  10ac9b:	5d                   	pop    rbp
  10ac9c:	41 5c                	pop    r12
  10ac9e:	41 5d                	pop    r13
  kgfx_draw_log_if_dirty(&globals.log);
  10aca0:	bf 60 01 11 00       	mov    edi,0x110160
  10aca5:	e9 c6 e4 ff ff       	jmp    109170 <kgfx_draw_log_if_dirty>
  10acaa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

000000000010acb0 <kmem_map_physical_to_virtual_2MB>:
  kassert((virtual_address & 0x1FFFFF) == 0);
  10acb0:	f7 c6 ff ff 1f 00    	test   esi,0x1fffff
void kmem_map_physical_to_virtual_2MB(uintptr_t physical_address, uintptr_t virtual_address){
  10acb6:	41 54                	push   r12
  10acb8:	49 89 fc             	mov    r12,rdi
  10acbb:	55                   	push   rbp
  10acbc:	53                   	push   rbx
  10acbd:	48 89 f3             	mov    rbx,rsi
  kassert((virtual_address & 0x1FFFFF) == 0);
  10acc0:	0f 85 ea 00 00 00    	jne    10adb0 <kmem_map_physical_to_virtual_2MB+0x100>
  kassert((physical_address & 0x1FFFFF) == 0);
  10acc6:	41 f7 c4 ff ff 1f 00 	test   r12d,0x1fffff
  10accd:	0f 85 a5 00 00 00    	jne    10ad78 <kmem_map_physical_to_virtual_2MB+0xc8>
  uintptr_t p4_index = (virtual_address >> 39) & 0x1FF;
  10acd3:	48 89 d8             	mov    rax,rbx
  uintptr_t p2_index = (virtual_address >> 21) & 0x1FF;
  10acd6:	48 89 dd             	mov    rbp,rbx
  uintptr_t p3_index = (virtual_address >> 30) & 0x1FF;
  10acd9:	48 c1 eb 1e          	shr    rbx,0x1e
  uintptr_t p4_index = (virtual_address >> 39) & 0x1FF;
  10acdd:	48 c1 e8 27          	shr    rax,0x27
  uintptr_t p2_index = (virtual_address >> 21) & 0x1FF;
  10ace1:	48 c1 ed 15          	shr    rbp,0x15
  kassert(p4_index == 0 && p3_index == 0);
  10ace5:	48 09 c3             	or     rbx,rax
  uintptr_t p2_index = (virtual_address >> 21) & 0x1FF;
  10ace8:	81 e5 ff 01 00 00    	and    ebp,0x1ff
  kassert(p4_index == 0 && p3_index == 0);
  10acee:	f7 c3 ff 01 00 00    	test   ebx,0x1ff
  10acf4:	75 4a                	jne    10ad40 <kmem_map_physical_to_virtual_2MB+0x90>
  kassert(g_p2_table.entries[p2_index] == 0);
  10acf6:	48 83 3c ed 00 40 12 	cmp    QWORD PTR [rbp*8+0x124000],0x0
  10acfd:	00 00 
  10acff:	74 2d                	je     10ad2e <kmem_map_physical_to_virtual_2MB+0x7e>
  10ad01:	41 b8 9c 0c 10 00    	mov    r8d,0x100c9c
  10ad07:	b9 38 00 00 00       	mov    ecx,0x38
  10ad0c:	ba 10 14 10 00       	mov    edx,0x101410
  10ad11:	be 80 12 10 00       	mov    esi,0x101280
  10ad16:	31 c0                	xor    eax,eax
  10ad18:	bf 60 01 11 00       	mov    edi,0x110160
  10ad1d:	e8 6e f4 ff ff       	call   10a190 <klog_write_fmt>
  10ad22:	bf 60 01 11 00       	mov    edi,0x110160
  10ad27:	e8 44 e4 ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10ad2c:	fa                   	cli    
  10ad2d:	f4                   	hlt    
  g_p2_table.entries[p2_index] = physical_address | PAGE_PRESENT_BIT | PAGE_HUGE_BIT | PAGE_WRITEABLE_BIT;
  10ad2e:	41 80 cc 83          	or     r12b,0x83
  10ad32:	4c 89 24 ed 00 40 12 	mov    QWORD PTR [rbp*8+0x124000],r12
  10ad39:	00 
}
  10ad3a:	5b                   	pop    rbx
  10ad3b:	5d                   	pop    rbp
  10ad3c:	41 5c                	pop    r12
  10ad3e:	c3                   	ret    
  10ad3f:	90                   	nop
  kassert(p4_index == 0 && p3_index == 0);
  10ad40:	41 b8 9c 0c 10 00    	mov    r8d,0x100c9c
  10ad46:	b9 37 00 00 00       	mov    ecx,0x37
  10ad4b:	ba f0 13 10 00       	mov    edx,0x1013f0
  10ad50:	be 80 12 10 00       	mov    esi,0x101280
  10ad55:	31 c0                	xor    eax,eax
  10ad57:	bf 60 01 11 00       	mov    edi,0x110160
  10ad5c:	e8 2f f4 ff ff       	call   10a190 <klog_write_fmt>
  10ad61:	bf 60 01 11 00       	mov    edi,0x110160
  10ad66:	e8 05 e4 ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10ad6b:	fa                   	cli    
  10ad6c:	f4                   	hlt    
  10ad6d:	e9 84 ff ff ff       	jmp    10acf6 <kmem_map_physical_to_virtual_2MB+0x46>
  10ad72:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  kassert((physical_address & 0x1FFFFF) == 0);
  10ad78:	41 b8 9c 0c 10 00    	mov    r8d,0x100c9c
  10ad7e:	b9 33 00 00 00       	mov    ecx,0x33
  10ad83:	ba b0 12 10 00       	mov    edx,0x1012b0
  10ad88:	be 80 12 10 00       	mov    esi,0x101280
  10ad8d:	31 c0                	xor    eax,eax
  10ad8f:	bf 60 01 11 00       	mov    edi,0x110160
  10ad94:	e8 f7 f3 ff ff       	call   10a190 <klog_write_fmt>
  10ad99:	bf 60 01 11 00       	mov    edi,0x110160
  10ad9e:	e8 cd e3 ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10ada3:	fa                   	cli    
  10ada4:	f4                   	hlt    
  10ada5:	e9 29 ff ff ff       	jmp    10acd3 <kmem_map_physical_to_virtual_2MB+0x23>
  10adaa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  kassert((virtual_address & 0x1FFFFF) == 0);
  10adb0:	41 b8 9c 0c 10 00    	mov    r8d,0x100c9c
  10adb6:	b9 32 00 00 00       	mov    ecx,0x32
  10adbb:	ba 58 12 10 00       	mov    edx,0x101258
  10adc0:	be 80 12 10 00       	mov    esi,0x101280
  10adc5:	31 c0                	xor    eax,eax
  10adc7:	bf 60 01 11 00       	mov    edi,0x110160
  10adcc:	e8 bf f3 ff ff       	call   10a190 <klog_write_fmt>
  10add1:	bf 60 01 11 00       	mov    edi,0x110160
  10add6:	e8 95 e3 ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10addb:	fa                   	cli    
  10addc:	f4                   	hlt    
  10addd:	e9 e4 fe ff ff       	jmp    10acc6 <kmem_map_physical_to_virtual_2MB+0x16>
  10ade2:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  10ade6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10aded:	00 00 00 

000000000010adf0 <ktask_create_process>:
uint64_t ktask_create_process(uintptr_t elf_executable, Task_Info *task_info){
  10adf0:	48 8d 56 10          	lea    rdx,[rsi+0x10]
  for(size_t i = 0; i < KTASK_MAX_PROCESSESS; i++){
  10adf4:	31 c0                	xor    eax,eax
  10adf6:	eb 16                	jmp    10ae0e <ktask_create_process+0x1e>
  10adf8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  10adff:	00 
  10ae00:	48 83 c0 01          	add    rax,0x1
  10ae04:	48 83 c2 18          	add    rdx,0x18
  10ae08:	48 83 f8 20          	cmp    rax,0x20
  10ae0c:	74 42                	je     10ae50 <ktask_create_process+0x60>
    if(p->is_valid == false) {
  10ae0e:	80 3a 00             	cmp    BYTE PTR [rdx],0x0
  10ae11:	75 ed                	jne    10ae00 <ktask_create_process+0x10>
    Process_Context *p = &task_info->processess[i];
  10ae13:	48 8d 14 40          	lea    rdx,[rax+rax*2]
  10ae17:	48 8d 14 d6          	lea    rdx,[rsi+rdx*8]
  if(process == 0) return result_pid;
  10ae1b:	48 85 d2             	test   rdx,rdx
  10ae1e:	74 2f                	je     10ae4f <ktask_create_process+0x5f>
uint64_t ktask_create_process(uintptr_t elf_executable, Task_Info *task_info){
  10ae20:	55                   	push   rbp
  10ae21:	53                   	push   rbx
  10ae22:	48 89 f3             	mov    rbx,rsi
  10ae25:	48 83 ec 08          	sub    rsp,0x8
  if(header->magicNumber != ELF64_MAGIC_NUMBER){
  10ae29:	81 3f 7f 45 4c 46    	cmp    DWORD PTR [rdi],0x464c457f
  10ae2f:	74 2f                	je     10ae60 <ktask_create_process+0x70>
    klog_error("invalid elf file was provided");
  10ae31:	31 c0                	xor    eax,eax
  10ae33:	be 5b 0d 10 00       	mov    esi,0x100d5b
  10ae38:	bf 60 01 11 00       	mov    edi,0x110160
  10ae3d:	e8 4e f3 ff ff       	call   10a190 <klog_write_fmt>
    return KTASK_INVALID_PID;
  10ae42:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
}
  10ae49:	48 83 c4 08          	add    rsp,0x8
  10ae4d:	5b                   	pop    rbx
  10ae4e:	5d                   	pop    rbp
  10ae4f:	c3                   	ret    
  uint64_t result_pid = KTASK_INVALID_PID;
  10ae50:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  10ae57:	c3                   	ret    
  10ae58:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  10ae5f:	00 
  uintptr_t elf_start_address = header->programEntryOffset;
  10ae60:	48 8b 6f 18          	mov    rbp,QWORD PTR [rdi+0x18]
  kmem_map_physical_to_virtual_2MB_ext(executable_physical_address, executable_virtual_address, PAGE_USER_ACCESS_BIT);
  10ae64:	ba 04 00 00 00       	mov    edx,0x4
  10ae69:	be 00 00 40 00       	mov    esi,0x400000
  10ae6e:	bf 00 00 a0 00       	mov    edi,0xa00000
  10ae73:	48 89 04 24          	mov    QWORD PTR [rsp],rax
  10ae77:	e8 54 f9 ff ff       	call   10a7d0 <kmem_map_physical_to_virtual_2MB_ext>
  10ae7c:	b9 7f 00 00 00       	mov    ecx,0x7f
	for (size_t i = 0; i < size; i++) {
  10ae81:	31 d2                	xor    edx,edx
  10ae83:	48 8b 04 24          	mov    rax,QWORD PTR [rsp]
  10ae87:	eb 0e                	jmp    10ae97 <ktask_create_process+0xa7>
  10ae89:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
  10ae90:	0f b6 8a a0 17 10 00 	movzx  ecx,BYTE PTR [rdx+0x1017a0]
		dest[i] = src[i];
  10ae97:	88 8a 00 00 40 00    	mov    BYTE PTR [rdx+0x400000],cl
	for (size_t i = 0; i < size; i++) {
  10ae9d:	48 83 c2 01          	add    rdx,0x1
  10aea1:	48 81 fa d0 07 00 00 	cmp    rdx,0x7d0
  10aea8:	75 e6                	jne    10ae90 <ktask_create_process+0xa0>
  process->start_address = elf_start_address;
  10aeaa:	48 8d 14 40          	lea    rdx,[rax+rax*2]
  10aeae:	48 8d 14 d3          	lea    rdx,[rbx+rdx*8]
  10aeb2:	48 89 6a 08          	mov    QWORD PTR [rdx+0x8],rbp
  process->is_valid = true;
  10aeb6:	c6 42 10 01          	mov    BYTE PTR [rdx+0x10],0x1
  return result_pid;
  10aeba:	eb 8d                	jmp    10ae49 <ktask_create_process+0x59>
  10aebc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000010aec0 <ktask_create_thread>:
uint64_t ktask_create_thread(uint64_t pid, uintptr_t rip, Task_Info *task_info){
  10aec0:	41 55                	push   r13
  10aec2:	48 8d 82 00 03 00 00 	lea    rax,[rdx+0x300]
  10aec9:	41 54                	push   r12
  for(size_t i = 0; i < KTASK_MAX_THREADS; i++){
  10aecb:	31 d2                	xor    edx,edx
uint64_t ktask_create_thread(uint64_t pid, uintptr_t rip, Task_Info *task_info){
  10aecd:	55                   	push   rbp
  10aece:	49 89 f4             	mov    r12,rsi
  10aed1:	53                   	push   rbx
  10aed2:	48 89 fd             	mov    rbp,rdi
  Thread_Context *thread = 0;
  10aed5:	31 db                	xor    ebx,ebx
  uint64_t result_tid = KTASK_INVALID_TID;
  10aed7:	49 c7 c5 ff ff ff ff 	mov    r13,0xffffffffffffffff
  10aede:	66 90                	xchg   ax,ax
    if(t->is_valid == false){
  10aee0:	80 78 20 00          	cmp    BYTE PTR [rax+0x20],0x0
  10aee4:	75 06                	jne    10aeec <ktask_create_thread+0x2c>
  10aee6:	48 89 c3             	mov    rbx,rax
  10aee9:	49 89 d5             	mov    r13,rdx
  for(size_t i = 0; i < KTASK_MAX_THREADS; i++){
  10aeec:	48 83 c2 01          	add    rdx,0x1
  10aef0:	48 83 c0 28          	add    rax,0x28
  10aef4:	48 83 fa 40          	cmp    rdx,0x40
  10aef8:	75 e6                	jne    10aee0 <ktask_create_thread+0x20>
  if(thread == 0) {
  10aefa:	48 85 db             	test   rbx,rbx
  10aefd:	74 39                	je     10af38 <ktask_create_thread+0x78>
  kmem_map_physical_to_virtual_2MB_ext(thread_physical_stack, thread_virtual_stack, PAGE_USER_ACCESS_BIT);
  10aeff:	ba 04 00 00 00       	mov    edx,0x4
  10af04:	be 00 00 60 00       	mov    esi,0x600000
  10af09:	bf 00 00 c0 00       	mov    edi,0xc00000
  10af0e:	e8 bd f8 ff ff       	call   10a7d0 <kmem_map_physical_to_virtual_2MB_ext>
  thread->stack_physical_address = thread_physical_stack;
  10af13:	48 c7 43 08 00 00 c0 	mov    QWORD PTR [rbx+0x8],0xc00000
  10af1a:	00 
  thread->rsp = rsp_begin;
  10af1b:	48 c7 43 10 ff ff 7f 	mov    QWORD PTR [rbx+0x10],0x7fffff
  10af22:	00 
}
  10af23:	4c 89 e8             	mov    rax,r13
  thread->rip = rip;
  10af26:	4c 89 63 18          	mov    QWORD PTR [rbx+0x18],r12
  thread->is_valid = true;
  10af2a:	c6 43 20 01          	mov    BYTE PTR [rbx+0x20],0x1
  thread->pid = pid;
  10af2e:	48 89 2b             	mov    QWORD PTR [rbx],rbp
}
  10af31:	5b                   	pop    rbx
  10af32:	5d                   	pop    rbp
  10af33:	41 5c                	pop    r12
  10af35:	41 5d                	pop    r13
  10af37:	c3                   	ret    
    klog_error("NO THREADS");
  10af38:	be 79 0d 10 00       	mov    esi,0x100d79
  10af3d:	31 c0                	xor    eax,eax
  10af3f:	bf 60 01 11 00       	mov    edi,0x110160
  10af44:	e8 47 f2 ff ff       	call   10a190 <klog_write_fmt>
    kpanic();
  10af49:	bf 60 01 11 00       	mov    edi,0x110160
  10af4e:	e8 1d e2 ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10af53:	fa                   	cli    
  10af54:	f4                   	hlt    
  10af55:	eb a8                	jmp    10aeff <ktask_create_thread+0x3f>
  10af57:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  10af5e:	00 00 

000000000010af60 <irq_handler_keyboard>:
	asm volatile ("inb %1, %0" : "=a"(result) : "Nd"(port));
  10af60:	e4 64                	in     al,0x64
static void 
irq_handler_keyboard(void) {
  static const uint32_t KEYBOARD_DATA_PORT   = 0x60;
  static const uint32_t KEYBOARD_STATUS_PORT = 0x64;
	uint8_t keyboard_status = read_port_uint8(KEYBOARD_STATUS_PORT);
  if(keyboard_status & 0x01){
  10af62:	a8 01                	test   al,0x1
  10af64:	74 43                	je     10afa9 <irq_handler_keyboard+0x49>
irq_handler_keyboard(void) {
  10af66:	53                   	push   rbx
  10af67:	e4 60                	in     al,0x60
		uint8_t scancode = read_port_uint8(KEYBOARD_DATA_PORT);
    if(globals.log_keyboard_events){
  10af69:	80 3d 99 66 01 00 00 	cmp    BYTE PTR [rip+0x16699],0x0        # 121609 <globals+0x114a9>
  10af70:	89 c3                	mov    ebx,eax
  10af72:	75 4c                	jne    10afc0 <irq_handler_keyboard+0x60>
      klog_debug("[keyboard_event] scancode %u", scancode);
    }

    //TODO(Torin) How should this case be handled?  Is it even possbile to occur in practice?
    //What if the user has a stupidly slow computer?
    if(globals.keyboard.scancode_event_stack_count >= sizeof(globals.keyboard.scancode_event_stack)) {
  10af74:	48 8b 05 25 58 01 00 	mov    rax,QWORD PTR [rip+0x15825]        # 1207a0 <globals+0x10640>
  10af7b:	48 83 f8 07          	cmp    rax,0x7
  10af7f:	77 60                	ja     10afe1 <irq_handler_keyboard+0x81>
      klog_warning("[keyboard_event] keyboard event stack reached maximum size before events were processed");
      return;
    }

    if (scancode > 0x80) {  //NOTE(Torin)key release event 
  10af81:	80 fb 80             	cmp    bl,0x80
  10af84:	76 2a                	jbe    10afb0 <irq_handler_keyboard+0x50>
      uint8_t base_scancode = scancode - 0x80;
  10af86:	8d 53 80             	lea    edx,[rbx-0x80]
      globals.keyboard.keystate[base_scancode] = 0;
  10af89:	0f b6 d2             	movzx  edx,dl
  10af8c:	c6 82 a0 06 12 00 00 	mov    BYTE PTR [rdx+0x1206a0],0x0
      globals.keyboard.keystate[scancode] = 1;
    }
    
    //TODO(Torin) we would be saving some subtractions cost in userspace by storing the keycode here instead of the
    //scanconde and adding an extra byte to store information about the isDown state and keyboard modifiers!
    globals.keyboard.scancode_event_stack[globals.keyboard.scancode_event_stack_count++] = scancode;
  10af93:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10af97:	48 89 15 02 58 01 00 	mov    QWORD PTR [rip+0x15802],rdx        # 1207a0 <globals+0x10640>
  10af9e:	48 8b 15 03 58 01 00 	mov    rdx,QWORD PTR [rip+0x15803]        # 1207a8 <globals+0x10648>
  10afa5:	88 1c 02             	mov    BYTE PTR [rdx+rax*1],bl
  }
}
  10afa8:	5b                   	pop    rbx
  10afa9:	f3 c3                	repz ret 
  10afab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
      globals.keyboard.keystate[scancode] = 1;
  10afb0:	0f b6 d3             	movzx  edx,bl
  10afb3:	c6 82 a0 06 12 00 01 	mov    BYTE PTR [rdx+0x1206a0],0x1
  10afba:	eb d7                	jmp    10af93 <irq_handler_keyboard+0x33>
  10afbc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
      klog_debug("[keyboard_event] scancode %u", scancode);
  10afc0:	0f b6 d0             	movzx  edx,al
  10afc3:	be 84 0d 10 00       	mov    esi,0x100d84
  10afc8:	31 c0                	xor    eax,eax
  10afca:	bf 60 01 11 00       	mov    edi,0x110160
  10afcf:	e8 bc f1 ff ff       	call   10a190 <klog_write_fmt>
    if(globals.keyboard.scancode_event_stack_count >= sizeof(globals.keyboard.scancode_event_stack)) {
  10afd4:	48 8b 05 c5 57 01 00 	mov    rax,QWORD PTR [rip+0x157c5]        # 1207a0 <globals+0x10640>
  10afdb:	48 83 f8 07          	cmp    rax,0x7
  10afdf:	76 a0                	jbe    10af81 <irq_handler_keyboard+0x21>
}
  10afe1:	5b                   	pop    rbx
      klog_warning("[keyboard_event] keyboard event stack reached maximum size before events were processed");
  10afe2:	be 38 14 10 00       	mov    esi,0x101438
  10afe7:	bf 60 01 11 00       	mov    edi,0x110160
  10afec:	31 c0                	xor    eax,eax
  10afee:	e9 9d f1 ff ff       	jmp    10a190 <klog_write_fmt>
  10aff3:	0f 1f 00             	nop    DWORD PTR [rax]
  10aff6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10affd:	00 00 00 

000000000010b000 <irq_handler_pit>:
}

static void 
irq_handler_pit(void){
  globals.pit_timer_ticks += 1;
  klog_debug("pit tick!");
  10b000:	31 c0                	xor    eax,eax
  10b002:	be a1 0d 10 00       	mov    esi,0x100da1
  10b007:	bf 60 01 11 00       	mov    edi,0x110160
  globals.pit_timer_ticks += 1;
  10b00c:	48 83 05 ec 65 01 00 	add    QWORD PTR [rip+0x165ec],0x1        # 121600 <globals+0x114a0>
  10b013:	01 
  klog_debug("pit tick!");
  10b014:	e8 77 f1 ff ff       	call   10a190 <klog_write_fmt>
  kgfx_draw_log_if_dirty(&globals.log); 
  10b019:	bf 60 01 11 00       	mov    edi,0x110160
  10b01e:	e8 4d e1 ff ff       	call   109170 <kgfx_draw_log_if_dirty>
	asm volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
  10b023:	b8 20 00 00 00       	mov    eax,0x20
  10b028:	e6 21                	out    0x21,al
  10b02a:	c3                   	ret    
  10b02b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000010b030 <kprocess_destroy>:
  for(size_t i = 0; i < globals.system_info.cpu_count; i++){
  10b030:	8b 15 22 58 01 00    	mov    edx,DWORD PTR [rip+0x15822]        # 120858 <globals+0x106f8>
  lapic[0] = value;
}

static inline
uint32_t lapic_read_register(uintptr_t lapic_base, uintptr_t register_offset){
  uint32_t volatile *lapic_register = (uint32_t volatile *)(lapic_base + register_offset);
  10b036:	48 8b 05 c3 57 01 00 	mov    rax,QWORD PTR [rip+0x157c3]        # 120800 <globals+0x106a0>
  10b03d:	85 d2                	test   edx,edx
  return lapic_register[0];
  10b03f:	8b 40 20             	mov    eax,DWORD PTR [rax+0x20]
  10b042:	74 08                	je     10b04c <kprocess_destroy+0x1c>
    if(globals.system_info.cpu_lapic_ids[0] == lapic_id) return i;
  10b044:	3b 05 ce 57 01 00    	cmp    eax,DWORD PTR [rip+0x157ce]        # 120818 <globals+0x106b8>
  10b04a:	74 1d                	je     10b069 <kprocess_destroy+0x39>
  klog_error("UNREGISTER LAPIC ID WAS USED TO GFT CPU ID");
  10b04c:	be 90 14 10 00       	mov    esi,0x101490
  10b051:	31 c0                	xor    eax,eax
  10b053:	bf 60 01 11 00       	mov    edi,0x110160
  10b058:	e8 33 f1 ff ff       	call   10a190 <klog_write_fmt>
  kpanic();
  10b05d:	bf 60 01 11 00       	mov    edi,0x110160
  10b062:	e8 09 e1 ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10b067:	fa                   	cli    
  10b068:	f4                   	hlt    
  uint64_t pid = running_thread->pid;
  10b069:	48 8b 05 10 65 01 00 	mov    rax,QWORD PTR [rip+0x16510]        # 121580 <globals+0x11420>
  10b070:	48 8b 10             	mov    rdx,QWORD PTR [rax]
  p->is_valid = false;
  10b073:	48 8d 04 52          	lea    rax,[rdx+rdx*2]
  10b077:	c6 04 c5 90 08 12 00 	mov    BYTE PTR [rax*8+0x120890],0x0
  10b07e:	00 
  10b07f:	b8 80 0b 12 00       	mov    eax,0x120b80
  10b084:	eb 0c                	jmp    10b092 <kprocess_destroy+0x62>
  10b086:	48 83 c0 28          	add    rax,0x28
  for(size_t i = 0; i < KTASK_MAX_THREADS; i++){
  10b08a:	48 3d 80 15 12 00    	cmp    rax,0x121580
  10b090:	74 15                	je     10b0a7 <kprocess_destroy+0x77>
    if(t->pid == pid) {
  10b092:	48 3b 10             	cmp    rdx,QWORD PTR [rax]
  10b095:	75 ef                	jne    10b086 <kprocess_destroy+0x56>
  ctx->is_valid = false;
  10b097:	c6 40 20 00          	mov    BYTE PTR [rax+0x20],0x0
  10b09b:	48 83 c0 28          	add    rax,0x28
  for(size_t i = 0; i < KTASK_MAX_THREADS; i++){
  10b09f:	48 3d 80 15 12 00    	cmp    rax,0x121580
  10b0a5:	75 eb                	jne    10b092 <kprocess_destroy+0x62>
  klog_debug("destroyed pid: %lu", pid);
  10b0a7:	31 c0                	xor    eax,eax
  10b0a9:	be ab 0d 10 00       	mov    esi,0x100dab
  10b0ae:	bf 60 01 11 00       	mov    edi,0x110160
  10b0b3:	e8 d8 f0 ff ff       	call   10a190 <klog_write_fmt>
  lapic_configure_timer(globals.system_info.lapic_virtual_address, 0xFFFF, 0x20, 1);
  10b0b8:	48 8b 05 41 57 01 00 	mov    rax,QWORD PTR [rip+0x15741]        # 120800 <globals+0x106a0>
  lapic[0] = value;
  10b0bf:	c7 80 80 03 00 00 ff 	mov    DWORD PTR [rax+0x380],0xffff
  10b0c6:	ff 00 00 
  10b0c9:	c7 80 e0 03 00 00 03 	mov    DWORD PTR [rax+0x3e0],0x3
  10b0d0:	00 00 00 
  10b0d3:	c7 80 20 03 00 00 20 	mov    DWORD PTR [rax+0x320],0x20020
  10b0da:	00 02 00 
  asm volatile("int $0x20");
  10b0dd:	cd 20                	int    0x20
  10b0df:	90                   	nop
  while(1) { asm volatile("hlt"); }
  10b0e0:	f4                   	hlt    
  10b0e1:	eb fd                	jmp    10b0e0 <kprocess_destroy+0xb0>
  10b0e3:	0f 1f 00             	nop    DWORD PTR [rax]
  10b0e6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10b0ed:	00 00 00 

000000000010b0f0 <isr_common_handler>:
isr_common_handler(Interrupt_Stack_Frame stack) {
  10b0f0:	53                   	push   rbx
  10b0f1:	48 8b 9c 24 88 00 00 	mov    rbx,QWORD PTR [rsp+0x88]
  10b0f8:	00 
	klog_debug("Exception Occured:%u %s", stack.interrupt_number, EXCEPTION_NAMES[stack.interrupt_number]);
  10b0f9:	31 c0                	xor    eax,eax
  10b0fb:	be be 0d 10 00       	mov    esi,0x100dbe
  10b100:	bf 60 01 11 00       	mov    edi,0x110160
  10b105:	48 8b 0c dd 80 1f 10 	mov    rcx,QWORD PTR [rbx*8+0x101f80]
  10b10c:	00 
  10b10d:	48 89 da             	mov    rdx,rbx
  10b110:	e8 7b f0 ff ff       	call   10a190 <klog_write_fmt>
	klog_debug("error_code: %u", stack.error_code);
  10b115:	48 8b 94 24 90 00 00 	mov    rdx,QWORD PTR [rsp+0x90]
  10b11c:	00 
  10b11d:	31 c0                	xor    eax,eax
  10b11f:	be d6 0d 10 00       	mov    esi,0x100dd6
  10b124:	bf 60 01 11 00       	mov    edi,0x110160
  10b129:	e8 62 f0 ff ff       	call   10a190 <klog_write_fmt>
	klog_debug("rip: 0x%X", stack.rip);
  10b12e:	48 8b 94 24 98 00 00 	mov    rdx,QWORD PTR [rsp+0x98]
  10b135:	00 
  10b136:	31 c0                	xor    eax,eax
  10b138:	be e5 0d 10 00       	mov    esi,0x100de5
  10b13d:	bf 60 01 11 00       	mov    edi,0x110160
  10b142:	e8 49 f0 ff ff       	call   10a190 <klog_write_fmt>
  if(g_exception_handlers[stack.interrupt_number] != 0){
  10b147:	48 8b 04 dd 00 17 10 	mov    rax,QWORD PTR [rbx*8+0x101700]
  10b14e:	00 
  10b14f:	48 85 c0             	test   rax,rax
  10b152:	74 1c                	je     10b170 <isr_common_handler+0x80>
    g_exception_handlers[stack.interrupt_number](stack);
  10b154:	48 8d 7c 24 10       	lea    rdi,[rsp+0x10]
  10b159:	b9 16 00 00 00       	mov    ecx,0x16
  10b15e:	48 89 fe             	mov    rsi,rdi
  10b161:	f3 48 a5             	rep movs QWORD PTR es:[rdi],QWORD PTR ds:[rsi]
}
  10b164:	5b                   	pop    rbx
    g_exception_handlers[stack.interrupt_number](stack);
  10b165:	ff e0                	jmp    rax
  10b167:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  10b16e:	00 00 
}
  10b170:	5b                   	pop    rbx
  10b171:	c3                   	ret    
  10b172:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  10b176:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10b17d:	00 00 00 

000000000010b180 <isr_handler_page_fault>:
    kpanic();
  }
}

static void 
isr_handler_page_fault(Interrupt_Stack_Frame stack_frame) {
  10b180:	55                   	push   rbp
  10b181:	53                   	push   rbx
  10b182:	48 83 ec 08          	sub    rsp,0x8
  10b186:	48 8b 9c 24 a0 00 00 	mov    rbx,QWORD PTR [rsp+0xa0]
  10b18d:	00 
	static const uint64_t CAUSE_USER_OR_KERNEL = (1 << 2);
	static const uint64_t CAUSE_RESERVED_BIT_SET = (1 << 3);
	static const uint64_t CAUSE_INSTRUCTION_FETCH = (1 << 4);

	uintptr_t faulting_address = 0xFFFFFFFFFFFFFFFFL;
	asm volatile ("movq %%cr2, %0" : "=r"(faulting_address));
  10b18e:	0f 20 d2             	mov    rdx,cr2
  if(faulting_address == 0xFFFFFFFFFFFFFFFFL){
  10b191:	48 83 fa ff          	cmp    rdx,0xffffffffffffffff
  10b195:	0f 84 9d 00 00 00    	je     10b238 <isr_handler_page_fault+0xb8>
	uint64_t is_write_else_read = stack_frame.error_code & CAUSE_WRITE_OR_READ;
	uint64_t is_usermode_else_kernel = stack_frame.error_code & CAUSE_USER_OR_KERNEL;
	uint64_t is_reserved_bit_overwritten = stack_frame.error_code & CAUSE_RESERVED_BIT_SET;
	uint64_t is_instruction_else_data = stack_frame.error_code & CAUSE_INSTRUCTION_FETCH;
	
	klog_error("Page Fault: 0x%X (%s%s%s%s%s)", faulting_address,
  10b19b:	f6 c3 10             	test   bl,0x10
  10b19e:	b8 0b 0e 10 00       	mov    eax,0x100e0b
  10b1a3:	be ef 0d 10 00       	mov    esi,0x100def
  10b1a8:	48 0f 44 f0          	cmove  rsi,rax
  10b1ac:	b9 21 0e 10 00       	mov    ecx,0x100e21
  10b1b1:	f6 c3 08             	test   bl,0x8
  10b1b4:	48 89 dd             	mov    rbp,rbx
  10b1b7:	b8 c0 14 10 00       	mov    eax,0x1014c0
  10b1bc:	41 b9 3a 0e 10 00    	mov    r9d,0x100e3a
  10b1c2:	48 0f 44 c1          	cmove  rax,rcx
  10b1c6:	83 e5 04             	and    ebp,0x4
  10b1c9:	b9 52 0e 10 00       	mov    ecx,0x100e52
  10b1ce:	4c 0f 44 c9          	cmove  r9,rcx
  10b1d2:	41 b8 6c 0e 10 00    	mov    r8d,0x100e6c
  10b1d8:	f6 c3 02             	test   bl,0x2
  10b1db:	b9 82 0e 10 00       	mov    ecx,0x100e82
  10b1e0:	56                   	push   rsi
  10b1e1:	bf 98 0e 10 00       	mov    edi,0x100e98
  10b1e6:	50                   	push   rax
  10b1e7:	4c 0f 44 c1          	cmove  r8,rcx
  10b1eb:	83 e3 01             	and    ebx,0x1
  10b1ee:	b9 e8 14 10 00       	mov    ecx,0x1014e8
  10b1f3:	be c7 0e 10 00       	mov    esi,0x100ec7
  10b1f8:	48 0f 44 cf          	cmove  rcx,rdi
  10b1fc:	31 c0                	xor    eax,eax
  10b1fe:	bf 60 01 11 00       	mov    edi,0x110160
  10b203:	e8 88 ef ff ff       	call   10a190 <klog_write_fmt>
    (is_usermode_else_kernel ? "happened in user-mode, " : "happened in kernel-mode, "),
    (is_reserved_bit_overwritten ? "a reserved bit was overrwriten, " : "reserved bits are fine, "),
    (is_instruction_else_data ? "caused by instruction fetch" : "caused by data access")
  );

	if(is_usermode_else_kernel == false){
  10b208:	48 85 ed             	test   rbp,rbp
  10b20b:	58                   	pop    rax
  10b20c:	5a                   	pop    rdx
  10b20d:	74 11                	je     10b220 <isr_handler_page_fault+0xa0>
		//and mabye drops back into real mode to go back to old-school vga text buffer and
		//does a blue-screen of death type of deal to insure that the error is reported properly
    kpanic();
	} else {
		//TODO(TORIN) This was the userspace application lets kill it
    klog_error("UNHANDLED USERSPACE VIOLATION!!!");
  10b20f:	be 10 15 10 00       	mov    esi,0x101510
  10b214:	bf 60 01 11 00       	mov    edi,0x110160
  10b219:	31 c0                	xor    eax,eax
  10b21b:	e8 70 ef ff ff       	call   10a190 <klog_write_fmt>
    kpanic();
  10b220:	bf 60 01 11 00       	mov    edi,0x110160
  10b225:	e8 46 df ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10b22a:	fa                   	cli    
  10b22b:	f4                   	hlt    
	}
  10b22c:	48 83 c4 08          	add    rsp,0x8
  10b230:	5b                   	pop    rbx
  10b231:	5d                   	pop    rbp
  10b232:	c3                   	ret    
  10b233:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    klog_error("invalid faulting_address");
  10b238:	be ae 0e 10 00       	mov    esi,0x100eae
  10b23d:	bf 60 01 11 00       	mov    edi,0x110160
  10b242:	31 c0                	xor    eax,eax
  10b244:	48 89 14 24          	mov    QWORD PTR [rsp],rdx
  10b248:	e8 43 ef ff ff       	call   10a190 <klog_write_fmt>
  10b24d:	48 8b 14 24          	mov    rdx,QWORD PTR [rsp]
  10b251:	e9 45 ff ff ff       	jmp    10b19b <isr_handler_page_fault+0x1b>
  10b256:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10b25d:	00 00 00 

000000000010b260 <isr_handler_general_protection_fault>:
isr_handler_general_protection_fault(Interrupt_Stack_Frame stack_frame) {
  10b260:	53                   	push   rbx
  error_code.packed = stack_frame.error_code;
  10b261:	48 8b 9c 24 90 00 00 	mov    rbx,QWORD PTR [rsp+0x90]
  10b268:	00 
  if(error_code.packed != 0){
  10b269:	85 db                	test   ebx,ebx
  10b26b:	0f 84 7f 00 00 00    	je     10b2f0 <isr_handler_general_protection_fault+0x90>
    klog_error("GPF caused by segment error: ");
  10b271:	31 c0                	xor    eax,eax
  10b273:	be f0 0e 10 00       	mov    esi,0x100ef0
  10b278:	bf 60 01 11 00       	mov    edi,0x110160
  10b27d:	e8 0e ef ff ff       	call   10a190 <klog_write_fmt>
    klog_error(" external_to_cpu: %s", error_code.is_external_to_cpu ? "true" : "false");
  10b282:	f6 c3 01             	test   bl,0x1
  10b285:	b8 ea 0e 10 00       	mov    eax,0x100eea
  10b28a:	ba e5 0e 10 00       	mov    edx,0x100ee5
  10b28f:	48 0f 44 d0          	cmove  rdx,rax
  10b293:	be 0e 0f 10 00       	mov    esi,0x100f0e
  10b298:	31 c0                	xor    eax,eax
  10b29a:	bf 60 01 11 00       	mov    edi,0x110160
  10b29f:	e8 ec ee ff ff       	call   10a190 <klog_write_fmt>
    klog_error(" table_name: %s", TABLE_NAMES[error_code.table_index]);
  10b2a4:	89 d8                	mov    eax,ebx
  10b2a6:	be 23 0f 10 00       	mov    esi,0x100f23
  10b2ab:	bf 60 01 11 00       	mov    edi,0x110160
  10b2b0:	d1 e8                	shr    eax,1
  10b2b2:	83 e0 03             	and    eax,0x3
  10b2b5:	48 8b 14 c5 c0 16 10 	mov    rdx,QWORD PTR [rax*8+0x1016c0]
  10b2bc:	00 
  10b2bd:	31 c0                	xor    eax,eax
  10b2bf:	e8 cc ee ff ff       	call   10a190 <klog_write_fmt>
    klog_error(" selector_index: 0x%X", error_code.selector_index);
  10b2c4:	89 da                	mov    edx,ebx
  10b2c6:	be 33 0f 10 00       	mov    esi,0x100f33
  10b2cb:	31 c0                	xor    eax,eax
  10b2cd:	c1 ea 03             	shr    edx,0x3
  10b2d0:	bf 60 01 11 00       	mov    edi,0x110160
  10b2d5:	81 e2 ff 1f 00 00    	and    edx,0x1fff
  10b2db:	e8 b0 ee ff ff       	call   10a190 <klog_write_fmt>
    kpanic();
  10b2e0:	bf 60 01 11 00       	mov    edi,0x110160
  10b2e5:	e8 86 de ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10b2ea:	fa                   	cli    
  10b2eb:	f4                   	hlt    
}
  10b2ec:	5b                   	pop    rbx
  10b2ed:	c3                   	ret    
  10b2ee:	66 90                	xchg   ax,ax
    kpanic();
  10b2f0:	bf 60 01 11 00       	mov    edi,0x110160
  10b2f5:	e8 76 de ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10b2fa:	fa                   	cli    
  10b2fb:	f4                   	hlt    
}
  10b2fc:	5b                   	pop    rbx
  10b2fd:	c3                   	ret    
  10b2fe:	66 90                	xchg   ax,ax

000000000010b300 <irq_common_handler>:
  klog_debug("recieved irq");
  10b300:	31 c0                	xor    eax,eax
  10b302:	be 49 0f 10 00       	mov    esi,0x100f49
  10b307:	bf 60 01 11 00       	mov    edi,0x110160
  10b30c:	e8 7f ee ff ff       	call   10a190 <klog_write_fmt>
  kgfx_draw_log_if_dirty(&globals.log);
  10b311:	bf 60 01 11 00       	mov    edi,0x110160
  10b316:	e8 55 de ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10b31b:	b8 20 00 00 00       	mov    eax,0x20
  10b320:	e6 21                	out    0x21,al
  10b322:	c3                   	ret    
  10b323:	0f 1f 00             	nop    DWORD PTR [rax]
  10b326:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10b32d:	00 00 00 

000000000010b330 <klog_write_string>:
  if(length > CIRCULAR_LOG_MESSAGE_SIZE){
  10b330:	48 81 fa 00 01 00 00 	cmp    rdx,0x100
void klog_write_string(Circular_Log *log, const char *string, size_t length){
  10b337:	53                   	push   rbx
  10b338:	49 89 d0             	mov    r8,rdx
  10b33b:	48 89 f3             	mov    rbx,rsi
  if(length > CIRCULAR_LOG_MESSAGE_SIZE){
  10b33e:	0f 87 bc 00 00 00    	ja     10b400 <klog_write_string+0xd0>
  if(globals.is_logging_disabled) return;
  10b344:	80 3d bd 62 01 00 00 	cmp    BYTE PTR [rip+0x162bd],0x0        # 121608 <globals+0x114a8>
  10b34b:	74 03                	je     10b350 <klog_write_string+0x20>
}
  10b34d:	5b                   	pop    rbx
  10b34e:	c3                   	ret    
  10b34f:	90                   	nop
  10b350:	49 89 f9             	mov    r9,rdi
  Circular_Log_Entry *entry = klog_get_next_available_entry(log);
  10b353:	e8 c8 ed ff ff       	call   10a120 <klog_get_next_available_entry>
  10b358:	48 89 c7             	mov    rdi,rax
  10b35b:	31 c0                	xor    eax,eax
  10b35d:	4d 85 c0             	test   r8,r8
  10b360:	74 10                	je     10b372 <klog_write_string+0x42>
		dest[i] = src[i];
  10b362:	0f b6 14 03          	movzx  edx,BYTE PTR [rbx+rax*1]
  10b366:	88 14 07             	mov    BYTE PTR [rdi+rax*1],dl
	for (size_t i = 0; i < size; i++) {
  10b369:	48 83 c0 01          	add    rax,0x1
  10b36d:	49 39 c0             	cmp    r8,rax
  10b370:	75 f0                	jne    10b362 <klog_write_string+0x32>
  10b372:	49 8d 91 20 05 01 00 	lea    rdx,[r9+0x10520]
  entry->length = length;
  10b379:	44 89 87 00 01 00 00 	mov    DWORD PTR [rdi+0x100],r8d
  while(!__sync_bool_compare_and_swap(&lock->lock, 0, 1));
  10b380:	31 f6                	xor    esi,esi
  10b382:	b9 01 00 00 00       	mov    ecx,0x1
  10b387:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  10b38e:	00 00 
  10b390:	89 f0                	mov    eax,esi
  10b392:	f0 0f b1 0a          	lock cmpxchg DWORD PTR [rdx],ecx
  10b396:	75 f8                	jne    10b390 <klog_write_string+0x60>
  __sync_synchronize();
  10b398:	0f ae f0             	mfence 
  write_serial(entry->message, entry->length);
  10b39b:	44 8b 87 00 01 00 00 	mov    r8d,DWORD PTR [rdi+0x100]
  log->is_dirty = true;
  10b3a2:	41 c6 81 24 05 01 00 	mov    BYTE PTR [r9+0x10524],0x1
  10b3a9:	01 
  for(size_t i = 0; i < length; i++){
  10b3aa:	4d 85 c0             	test   r8,r8
  10b3ad:	74 29                	je     10b3d8 <klog_write_string+0xa8>
  10b3af:	31 f6                	xor    esi,esi
	asm volatile ("inb %1, %0" : "=a"(result) : "Nd"(port));
  10b3b1:	b9 fd 03 00 00       	mov    ecx,0x3fd
	asm volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
  10b3b6:	41 ba f8 03 00 00    	mov    r10d,0x3f8
  10b3bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	asm volatile ("inb %1, %0" : "=a"(result) : "Nd"(port));
  10b3c0:	89 ca                	mov    edx,ecx
  10b3c2:	ec                   	in     al,dx
    while(is_transmit_empty() == 0) {}
  10b3c3:	a8 20                	test   al,0x20
  10b3c5:	74 f9                	je     10b3c0 <klog_write_string+0x90>
	asm volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
  10b3c7:	0f b6 04 37          	movzx  eax,BYTE PTR [rdi+rsi*1]
  10b3cb:	44 89 d2             	mov    edx,r10d
  10b3ce:	ee                   	out    dx,al
  for(size_t i = 0; i < length; i++){
  10b3cf:	48 83 c6 01          	add    rsi,0x1
  10b3d3:	49 39 f0             	cmp    r8,rsi
  10b3d6:	75 e8                	jne    10b3c0 <klog_write_string+0x90>
	asm volatile ("inb %1, %0" : "=a"(result) : "Nd"(port));
  10b3d8:	ba fd 03 00 00       	mov    edx,0x3fd
  10b3dd:	0f 1f 00             	nop    DWORD PTR [rax]
  10b3e0:	ec                   	in     al,dx
    while(is_transmit_empty() == 0) {}
  10b3e1:	a8 20                	test   al,0x20
  10b3e3:	74 fb                	je     10b3e0 <klog_write_string+0xb0>
	asm volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
  10b3e5:	ba f8 03 00 00       	mov    edx,0x3f8
  10b3ea:	b8 0a 00 00 00       	mov    eax,0xa
  10b3ef:	ee                   	out    dx,al
  __sync_synchronize(); 
  10b3f0:	0f ae f0             	mfence 
  lock->lock = 0;
  10b3f3:	41 c7 81 20 05 01 00 	mov    DWORD PTR [r9+0x10520],0x0
  10b3fa:	00 00 00 00 
}
  10b3fe:	5b                   	pop    rbx
  10b3ff:	c3                   	ret    
    klog_error("failed to print string of length: %u", length);
  10b400:	be 38 15 10 00       	mov    esi,0x101538
  10b405:	bf 60 01 11 00       	mov    edi,0x110160
  10b40a:	31 c0                	xor    eax,eax
  10b40c:	e8 7f ed ff ff       	call   10a190 <klog_write_fmt>
    klog_error("string: %.*s", 30, string);
  10b411:	48 89 d9             	mov    rcx,rbx
  10b414:	ba 1e 00 00 00       	mov    edx,0x1e
  10b419:	be 56 0f 10 00       	mov    esi,0x100f56
}
  10b41e:	5b                   	pop    rbx
    klog_error("string: %.*s", 30, string);
  10b41f:	bf 60 01 11 00       	mov    edi,0x110160
  10b424:	31 c0                	xor    eax,eax
  10b426:	e9 65 ed ff ff       	jmp    10a190 <klog_write_fmt>
  10b42b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

000000000010b430 <syscall_handler_print_string>:
static uint64_t syscall_handler_print_string(const char *string, size_t length){
  10b430:	48 89 f2             	mov    rdx,rsi
  klog_write_string(&globals.log, string, length);
  10b433:	48 89 fe             	mov    rsi,rdi
  10b436:	bf 60 01 11 00       	mov    edi,0x110160
  10b43b:	e8 f0 fe ff ff       	call   10b330 <klog_write_string>
}
  10b440:	31 c0                	xor    eax,eax
  10b442:	c3                   	ret    
  10b443:	0f 1f 00             	nop    DWORD PTR [rax]
  10b446:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10b44d:	00 00 00 

000000000010b450 <kernel_longmode_entry>:
#include "kernel_debug.c"


extern void 
kernel_longmode_entry(uint64_t multiboot2_magic, uint64_t multiboot2_address)
{
  10b450:	41 55                	push   r13
  10b452:	41 54                	push   r12
  10b454:	45 31 c0             	xor    r8d,r8d
  10b457:	55                   	push   rbp
  10b458:	53                   	push   rbx
  10b459:	41 b9 f9 03 00 00    	mov    r9d,0x3f9
  10b45f:	48 89 f3             	mov    rbx,rsi
  10b462:	44 89 c0             	mov    eax,r8d
  10b465:	44 89 ca             	mov    edx,r9d
  10b468:	48 83 ec 28          	sub    rsp,0x28
  10b46c:	ee                   	out    dx,al
  10b46d:	be fb 03 00 00       	mov    esi,0x3fb
  10b472:	b8 80 ff ff ff       	mov    eax,0xffffff80
  10b477:	89 f2                	mov    edx,esi
  10b479:	ee                   	out    dx,al
  10b47a:	b9 01 00 00 00       	mov    ecx,0x1
  10b47f:	ba f8 03 00 00       	mov    edx,0x3f8
  10b484:	89 c8                	mov    eax,ecx
  10b486:	ee                   	out    dx,al
  10b487:	44 89 c0             	mov    eax,r8d
  10b48a:	44 89 ca             	mov    edx,r9d
  10b48d:	ee                   	out    dx,al
  10b48e:	b8 03 00 00 00       	mov    eax,0x3
  10b493:	89 f2                	mov    edx,esi
  10b495:	ee                   	out    dx,al
  10b496:	ba fa 03 00 00       	mov    edx,0x3fa
  10b49b:	b8 c7 ff ff ff       	mov    eax,0xffffffc7
  10b4a0:	ee                   	out    dx,al
  10b4a1:	ba fc 03 00 00       	mov    edx,0x3fc
  10b4a6:	b8 0b 00 00 00       	mov    eax,0xb
  10b4ab:	ee                   	out    dx,al
  10b4ac:	b8 11 00 00 00       	mov    eax,0x11
  10b4b1:	e6 20                	out    0x20,al
  10b4b3:	e6 a0                	out    0xa0,al
  10b4b5:	b8 20 00 00 00       	mov    eax,0x20
  10b4ba:	e6 21                	out    0x21,al
  10b4bc:	b8 28 00 00 00       	mov    eax,0x28
  10b4c1:	e6 a1                	out    0xa1,al
  10b4c3:	b8 04 00 00 00       	mov    eax,0x4
  10b4c8:	e6 21                	out    0x21,al
  10b4ca:	b8 02 00 00 00       	mov    eax,0x2
  10b4cf:	e6 a1                	out    0xa1,al
  10b4d1:	89 c8                	mov    eax,ecx
  10b4d3:	e6 21                	out    0x21,al
  10b4d5:	e6 a1                	out    0xa1,al
  10b4d7:	b8 fe ff ff ff       	mov    eax,0xfffffffe
  10b4dc:	e6 21                	out    0x21,al
  10b4de:	b8 ff ff ff ff       	mov    eax,0xffffffff
  10b4e3:	e6 a1                	out    0xa1,al
  10b4e5:	ba 25 c6 10 00       	mov    edx,0x10c625
  10b4ea:	48 89 d0             	mov    rax,rdx
  10b4ed:	89 d6                	mov    esi,edx
  10b4ef:	48 c1 ea 20          	shr    rdx,0x20
  10b4f3:	48 c1 e8 10          	shr    rax,0x10
  10b4f7:	48 89 c1             	mov    rcx,rax
  10b4fa:	b8 00 e0 10 00       	mov    eax,0x10e000
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b4ff:	41 ba 18 00 00 00    	mov    r10d,0x18
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b505:	66 89 30             	mov    WORD PTR [rax],si
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b508:	66 89 48 06          	mov    WORD PTR [rax+0x6],cx
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b50c:	89 50 08             	mov    DWORD PTR [rax+0x8],edx
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b50f:	c6 40 05 8e          	mov    BYTE PTR [rax+0x5],0x8e
  10b513:	48 83 c0 10          	add    rax,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b517:	66 44 89 50 f2       	mov    WORD PTR [rax-0xe],r10w
	_idt[irq_number].ist = 0;
  10b51c:	c6 40 f4 00          	mov    BYTE PTR [rax-0xc],0x0
	for (uint32_t i = 0; i < 256; i++) {
  10b520:	48 3d 00 f0 10 00    	cmp    rax,0x10f000
  10b526:	75 d7                	jne    10b4ff <kernel_longmode_entry+0xaf>
		idt_install_interrupt(0, (uintptr_t)asm_isr0);
  10b528:	b8 cc c6 10 00       	mov    eax,0x10c6cc
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b52d:	b9 18 00 00 00       	mov    ecx,0x18
  10b532:	be 18 00 00 00       	mov    esi,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b537:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b53a:	66 89 05 bf 2a 00 00 	mov    WORD PTR [rip+0x2abf],ax        # 10e000 <_idt>
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b541:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b545:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b549:	89 05 b9 2a 00 00    	mov    DWORD PTR [rip+0x2ab9],eax        # 10e008 <_idt+0x8>
		idt_install_interrupt(1, (uintptr_t)asm_isr1);
  10b54f:	b8 d3 c6 10 00       	mov    eax,0x10c6d3
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b554:	66 89 15 ab 2a 00 00 	mov    WORD PTR [rip+0x2aab],dx        # 10e006 <_idt+0x6>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b55b:	ba 18 00 00 00       	mov    edx,0x18
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b560:	66 89 05 a9 2a 00 00 	mov    WORD PTR [rip+0x2aa9],ax        # 10e010 <_idt+0x10>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b567:	66 89 15 94 2a 00 00 	mov    WORD PTR [rip+0x2a94],dx        # 10e002 <_idt+0x2>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b56e:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b571:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b575:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b579:	89 05 99 2a 00 00    	mov    DWORD PTR [rip+0x2a99],eax        # 10e018 <_idt+0x18>
		idt_install_interrupt(2, (uintptr_t)asm_isr2);
  10b57f:	b8 da c6 10 00       	mov    eax,0x10c6da
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b584:	66 89 15 8b 2a 00 00 	mov    WORD PTR [rip+0x2a8b],dx        # 10e016 <_idt+0x16>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b58b:	66 89 05 8e 2a 00 00 	mov    WORD PTR [rip+0x2a8e],ax        # 10e020 <_idt+0x20>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b592:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b595:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b599:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b59d:	41 b8 18 00 00 00    	mov    r8d,0x18
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b5a3:	89 05 7f 2a 00 00    	mov    DWORD PTR [rip+0x2a7f],eax        # 10e028 <_idt+0x28>
		idt_install_interrupt(3, (uintptr_t)asm_isr3);
  10b5a9:	b8 e1 c6 10 00       	mov    eax,0x10c6e1
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b5ae:	66 89 15 71 2a 00 00 	mov    WORD PTR [rip+0x2a71],dx        # 10e026 <_idt+0x26>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b5b5:	66 89 05 74 2a 00 00 	mov    WORD PTR [rip+0x2a74],ax        # 10e030 <_idt+0x30>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b5bc:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b5bf:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b5c3:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b5c7:	89 05 6b 2a 00 00    	mov    DWORD PTR [rip+0x2a6b],eax        # 10e038 <_idt+0x38>
		idt_install_interrupt(4, (uintptr_t)asm_isr4);
  10b5cd:	b8 e8 c6 10 00       	mov    eax,0x10c6e8
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b5d2:	66 89 15 5d 2a 00 00 	mov    WORD PTR [rip+0x2a5d],dx        # 10e036 <_idt+0x36>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b5d9:	66 89 05 60 2a 00 00 	mov    WORD PTR [rip+0x2a60],ax        # 10e040 <_idt+0x40>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b5e0:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b5e3:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b5e7:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b5eb:	41 b9 18 00 00 00    	mov    r9d,0x18
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b5f1:	89 05 51 2a 00 00    	mov    DWORD PTR [rip+0x2a51],eax        # 10e048 <_idt+0x48>
		idt_install_interrupt(5, (uintptr_t)asm_isr5);
  10b5f7:	b8 ef c6 10 00       	mov    eax,0x10c6ef
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b5fc:	66 89 15 43 2a 00 00 	mov    WORD PTR [rip+0x2a43],dx        # 10e046 <_idt+0x46>
  10b603:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b606:	66 89 05 43 2a 00 00 	mov    WORD PTR [rip+0x2a43],ax        # 10e050 <_idt+0x50>
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b60d:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b611:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b615:	66 89 0d f6 29 00 00 	mov    WORD PTR [rip+0x29f6],cx        # 10e012 <_idt+0x12>
  10b61c:	66 89 35 ff 29 00 00 	mov    WORD PTR [rip+0x29ff],si        # 10e022 <_idt+0x22>
  10b623:	66 44 89 05 07 2a 00 	mov    WORD PTR [rip+0x2a07],r8w        # 10e032 <_idt+0x32>
  10b62a:	00 
  10b62b:	66 44 89 0d 0f 2a 00 	mov    WORD PTR [rip+0x2a0f],r9w        # 10e042 <_idt+0x42>
  10b632:	00 
  10b633:	41 ba 18 00 00 00    	mov    r10d,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b639:	66 89 15 16 2a 00 00 	mov    WORD PTR [rip+0x2a16],dx        # 10e056 <_idt+0x56>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b640:	c6 05 be 29 00 00 8e 	mov    BYTE PTR [rip+0x29be],0x8e        # 10e005 <_idt+0x5>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b647:	41 bb 18 00 00 00    	mov    r11d,0x18
	_idt[irq_number].ist = 0;
  10b64d:	c6 05 b0 29 00 00 00 	mov    BYTE PTR [rip+0x29b0],0x0        # 10e004 <_idt+0x4>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b654:	c6 05 ba 29 00 00 8e 	mov    BYTE PTR [rip+0x29ba],0x8e        # 10e015 <_idt+0x15>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b65b:	bd 18 00 00 00       	mov    ebp,0x18
	_idt[irq_number].ist = 0;
  10b660:	c6 05 ad 29 00 00 00 	mov    BYTE PTR [rip+0x29ad],0x0        # 10e014 <_idt+0x14>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b667:	c6 05 b7 29 00 00 8e 	mov    BYTE PTR [rip+0x29b7],0x8e        # 10e025 <_idt+0x25>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b66e:	41 bc 18 00 00 00    	mov    r12d,0x18
	_idt[irq_number].ist = 0;
  10b674:	c6 05 a9 29 00 00 00 	mov    BYTE PTR [rip+0x29a9],0x0        # 10e024 <_idt+0x24>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b67b:	c6 05 b3 29 00 00 8e 	mov    BYTE PTR [rip+0x29b3],0x8e        # 10e035 <_idt+0x35>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b682:	41 bd 18 00 00 00    	mov    r13d,0x18
	_idt[irq_number].ist = 0;
  10b688:	c6 05 a5 29 00 00 00 	mov    BYTE PTR [rip+0x29a5],0x0        # 10e034 <_idt+0x34>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b68f:	c6 05 af 29 00 00 8e 	mov    BYTE PTR [rip+0x29af],0x8e        # 10e045 <_idt+0x45>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b696:	b9 18 00 00 00       	mov    ecx,0x18
	_idt[irq_number].ist = 0;
  10b69b:	c6 05 a2 29 00 00 00 	mov    BYTE PTR [rip+0x29a2],0x0        # 10e044 <_idt+0x44>
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b6a2:	89 05 b0 29 00 00    	mov    DWORD PTR [rip+0x29b0],eax        # 10e058 <_idt+0x58>
		idt_install_interrupt(6, (uintptr_t)asm_isr6);
  10b6a8:	b8 f6 c6 10 00       	mov    eax,0x10c6f6
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b6ad:	66 89 05 ac 29 00 00 	mov    WORD PTR [rip+0x29ac],ax        # 10e060 <_idt+0x60>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b6b4:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b6b7:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b6bb:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b6bf:	89 05 a3 29 00 00    	mov    DWORD PTR [rip+0x29a3],eax        # 10e068 <_idt+0x68>
		idt_install_interrupt(7, (uintptr_t)asm_isr7);
  10b6c5:	b8 fd c6 10 00       	mov    eax,0x10c6fd
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b6ca:	66 89 15 95 29 00 00 	mov    WORD PTR [rip+0x2995],dx        # 10e066 <_idt+0x66>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b6d1:	66 89 05 98 29 00 00 	mov    WORD PTR [rip+0x2998],ax        # 10e070 <_idt+0x70>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b6d8:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b6db:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b6df:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b6e3:	66 44 89 15 67 29 00 	mov    WORD PTR [rip+0x2967],r10w        # 10e052 <_idt+0x52>
  10b6ea:	00 
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b6eb:	89 05 87 29 00 00    	mov    DWORD PTR [rip+0x2987],eax        # 10e078 <_idt+0x78>
		idt_install_interrupt(8, (uintptr_t)asm_double_fault_handler);
  10b6f1:	b8 00 c6 10 00       	mov    eax,0x10c600
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b6f6:	66 89 15 79 29 00 00 	mov    WORD PTR [rip+0x2979],dx        # 10e076 <_idt+0x76>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b6fd:	66 89 05 7c 29 00 00 	mov    WORD PTR [rip+0x297c],ax        # 10e080 <_idt+0x80>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b704:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b707:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b70b:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b70f:	89 05 73 29 00 00    	mov    DWORD PTR [rip+0x2973],eax        # 10e088 <_idt+0x88>
		idt_install_interrupt(9, (uintptr_t)asm_isr9);
  10b715:	b8 0c c7 10 00       	mov    eax,0x10c70c
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b71a:	66 89 15 65 29 00 00 	mov    WORD PTR [rip+0x2965],dx        # 10e086 <_idt+0x86>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b721:	66 89 05 68 29 00 00 	mov    WORD PTR [rip+0x2968],ax        # 10e090 <_idt+0x90>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b728:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b72b:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b72f:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b733:	66 44 89 1d 27 29 00 	mov    WORD PTR [rip+0x2927],r11w        # 10e062 <_idt+0x62>
  10b73a:	00 
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b73b:	89 05 57 29 00 00    	mov    DWORD PTR [rip+0x2957],eax        # 10e098 <_idt+0x98>
		idt_install_interrupt(10, (uintptr_t)asm_isr10);
  10b741:	b8 16 c7 10 00       	mov    eax,0x10c716
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b746:	66 89 15 49 29 00 00 	mov    WORD PTR [rip+0x2949],dx        # 10e096 <_idt+0x96>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b74d:	66 89 05 4c 29 00 00 	mov    WORD PTR [rip+0x294c],ax        # 10e0a0 <_idt+0xa0>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b754:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b757:	48 c1 e8 20          	shr    rax,0x20
  10b75b:	89 05 47 29 00 00    	mov    DWORD PTR [rip+0x2947],eax        # 10e0a8 <_idt+0xa8>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b761:	b8 18 00 00 00       	mov    eax,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b766:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b76a:	66 89 05 31 29 00 00 	mov    WORD PTR [rip+0x2931],ax        # 10e0a2 <_idt+0xa2>
		idt_install_interrupt(11, (uintptr_t)asm_isr11);
  10b771:	b8 1e c7 10 00       	mov    eax,0x10c71e
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b776:	66 89 2d f5 28 00 00 	mov    WORD PTR [rip+0x28f5],bp        # 10e072 <_idt+0x72>
  10b77d:	66 44 89 25 fd 28 00 	mov    WORD PTR [rip+0x28fd],r12w        # 10e082 <_idt+0x82>
  10b784:	00 
  10b785:	66 44 89 2d 05 29 00 	mov    WORD PTR [rip+0x2905],r13w        # 10e092 <_idt+0x92>
  10b78c:	00 
  10b78d:	be 18 00 00 00       	mov    esi,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b792:	66 89 15 0d 29 00 00 	mov    WORD PTR [rip+0x290d],dx        # 10e0a6 <_idt+0xa6>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b799:	c6 05 b5 28 00 00 8e 	mov    BYTE PTR [rip+0x28b5],0x8e        # 10e055 <_idt+0x55>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b7a0:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].ist = 0;
  10b7a3:	c6 05 aa 28 00 00 00 	mov    BYTE PTR [rip+0x28aa],0x0        # 10e054 <_idt+0x54>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b7aa:	c6 05 b4 28 00 00 8e 	mov    BYTE PTR [rip+0x28b4],0x8e        # 10e065 <_idt+0x65>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b7b1:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].ist = 0;
  10b7b5:	c6 05 a8 28 00 00 00 	mov    BYTE PTR [rip+0x28a8],0x0        # 10e064 <_idt+0x64>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b7bc:	c6 05 b2 28 00 00 8e 	mov    BYTE PTR [rip+0x28b2],0x8e        # 10e075 <_idt+0x75>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b7c3:	41 b8 18 00 00 00    	mov    r8d,0x18
	_idt[irq_number].ist = 0;
  10b7c9:	c6 05 a4 28 00 00 00 	mov    BYTE PTR [rip+0x28a4],0x0        # 10e074 <_idt+0x74>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b7d0:	c6 05 ae 28 00 00 8e 	mov    BYTE PTR [rip+0x28ae],0x8e        # 10e085 <_idt+0x85>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b7d7:	41 b9 18 00 00 00    	mov    r9d,0x18
	_idt[irq_number].ist = 0;
  10b7dd:	c6 05 a0 28 00 00 00 	mov    BYTE PTR [rip+0x28a0],0x0        # 10e084 <_idt+0x84>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b7e4:	c6 05 aa 28 00 00 8e 	mov    BYTE PTR [rip+0x28aa],0x8e        # 10e095 <_idt+0x95>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b7eb:	41 ba 18 00 00 00    	mov    r10d,0x18
	_idt[irq_number].ist = 0;
  10b7f1:	c6 05 9c 28 00 00 00 	mov    BYTE PTR [rip+0x289c],0x0        # 10e094 <_idt+0x94>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b7f8:	c6 05 a6 28 00 00 8e 	mov    BYTE PTR [rip+0x28a6],0x8e        # 10e0a5 <_idt+0xa5>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b7ff:	41 bb 18 00 00 00    	mov    r11d,0x18
	_idt[irq_number].ist = 0;
  10b805:	c6 05 98 28 00 00 00 	mov    BYTE PTR [rip+0x2898],0x0        # 10e0a4 <_idt+0xa4>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b80c:	66 89 05 9d 28 00 00 	mov    WORD PTR [rip+0x289d],ax        # 10e0b0 <_idt+0xb0>
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b813:	48 c1 e8 20          	shr    rax,0x20
  10b817:	89 05 9b 28 00 00    	mov    DWORD PTR [rip+0x289b],eax        # 10e0b8 <_idt+0xb8>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b81d:	b8 18 00 00 00       	mov    eax,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b822:	66 89 15 8d 28 00 00 	mov    WORD PTR [rip+0x288d],dx        # 10e0b6 <_idt+0xb6>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b829:	66 89 05 82 28 00 00 	mov    WORD PTR [rip+0x2882],ax        # 10e0b2 <_idt+0xb2>
		idt_install_interrupt(12, (uintptr_t)asm_isr12);
  10b830:	b8 26 c7 10 00       	mov    eax,0x10c726
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b835:	c6 05 79 28 00 00 8e 	mov    BYTE PTR [rip+0x2879],0x8e        # 10e0b5 <_idt+0xb5>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b83c:	66 89 05 7d 28 00 00 	mov    WORD PTR [rip+0x287d],ax        # 10e0c0 <_idt+0xc0>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b843:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b846:	48 c1 e8 20          	shr    rax,0x20
  10b84a:	89 05 78 28 00 00    	mov    DWORD PTR [rip+0x2878],eax        # 10e0c8 <_idt+0xc8>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b850:	b8 18 00 00 00       	mov    eax,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b855:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b859:	66 89 05 62 28 00 00 	mov    WORD PTR [rip+0x2862],ax        # 10e0c2 <_idt+0xc2>
		idt_install_interrupt(13, (uintptr_t)asm_isr13);
  10b860:	b8 2e c7 10 00       	mov    eax,0x10c72e
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b865:	66 89 15 5a 28 00 00 	mov    WORD PTR [rip+0x285a],dx        # 10e0c6 <_idt+0xc6>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b86c:	66 89 05 5d 28 00 00 	mov    WORD PTR [rip+0x285d],ax        # 10e0d0 <_idt+0xd0>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b873:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b876:	48 c1 e8 20          	shr    rax,0x20
  10b87a:	89 05 58 28 00 00    	mov    DWORD PTR [rip+0x2858],eax        # 10e0d8 <_idt+0xd8>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b880:	b8 18 00 00 00       	mov    eax,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b885:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b889:	66 89 05 42 28 00 00 	mov    WORD PTR [rip+0x2842],ax        # 10e0d2 <_idt+0xd2>
		idt_install_interrupt(14, (uintptr_t)asm_isr14);
  10b890:	b8 36 c7 10 00       	mov    eax,0x10c736
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b895:	66 89 15 3a 28 00 00 	mov    WORD PTR [rip+0x283a],dx        # 10e0d6 <_idt+0xd6>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b89c:	66 89 05 3d 28 00 00 	mov    WORD PTR [rip+0x283d],ax        # 10e0e0 <_idt+0xe0>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b8a3:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b8a6:	48 c1 e8 20          	shr    rax,0x20
  10b8aa:	89 05 38 28 00 00    	mov    DWORD PTR [rip+0x2838],eax        # 10e0e8 <_idt+0xe8>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b8b0:	b8 18 00 00 00       	mov    eax,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b8b5:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b8b9:	66 89 05 22 28 00 00 	mov    WORD PTR [rip+0x2822],ax        # 10e0e2 <_idt+0xe2>
		idt_install_interrupt(15, (uintptr_t)asm_isr15);
  10b8c0:	b8 3e c7 10 00       	mov    eax,0x10c73e
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b8c5:	66 89 15 1a 28 00 00 	mov    WORD PTR [rip+0x281a],dx        # 10e0e6 <_idt+0xe6>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b8cc:	66 89 05 1d 28 00 00 	mov    WORD PTR [rip+0x281d],ax        # 10e0f0 <_idt+0xf0>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b8d3:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b8d6:	48 c1 e8 20          	shr    rax,0x20
  10b8da:	89 05 18 28 00 00    	mov    DWORD PTR [rip+0x2818],eax        # 10e0f8 <_idt+0xf8>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b8e0:	b8 18 00 00 00       	mov    eax,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b8e5:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b8e9:	66 89 05 02 28 00 00 	mov    WORD PTR [rip+0x2802],ax        # 10e0f2 <_idt+0xf2>
		idt_install_interrupt(16, (uintptr_t)asm_isr16);
  10b8f0:	b8 48 c7 10 00       	mov    eax,0x10c748
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b8f5:	66 89 15 fa 27 00 00 	mov    WORD PTR [rip+0x27fa],dx        # 10e0f6 <_idt+0xf6>
  10b8fc:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b8ff:	66 89 05 fa 27 00 00 	mov    WORD PTR [rip+0x27fa],ax        # 10e100 <_idt+0x100>
	_idt[irq_number].ist = 0;
  10b906:	c6 05 a7 27 00 00 00 	mov    BYTE PTR [rip+0x27a7],0x0        # 10e0b4 <_idt+0xb4>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b90d:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b911:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b915:	c6 05 a9 27 00 00 8e 	mov    BYTE PTR [rip+0x27a9],0x8e        # 10e0c5 <_idt+0xc5>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b91c:	66 89 15 e3 27 00 00 	mov    WORD PTR [rip+0x27e3],dx        # 10e106 <_idt+0x106>
	_idt[irq_number].ist = 0;
  10b923:	c6 05 9a 27 00 00 00 	mov    BYTE PTR [rip+0x279a],0x0        # 10e0c4 <_idt+0xc4>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b92a:	ba 18 00 00 00       	mov    edx,0x18
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b92f:	c6 05 9f 27 00 00 8e 	mov    BYTE PTR [rip+0x279f],0x8e        # 10e0d5 <_idt+0xd5>
	_idt[irq_number].ist = 0;
  10b936:	c6 05 97 27 00 00 00 	mov    BYTE PTR [rip+0x2797],0x0        # 10e0d4 <_idt+0xd4>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b93d:	bd 18 00 00 00       	mov    ebp,0x18
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b942:	c6 05 9c 27 00 00 8e 	mov    BYTE PTR [rip+0x279c],0x8e        # 10e0e5 <_idt+0xe5>
	_idt[irq_number].ist = 0;
  10b949:	c6 05 94 27 00 00 00 	mov    BYTE PTR [rip+0x2794],0x0        # 10e0e4 <_idt+0xe4>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b950:	41 bc 18 00 00 00    	mov    r12d,0x18
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10b956:	c6 05 98 27 00 00 8e 	mov    BYTE PTR [rip+0x2798],0x8e        # 10e0f5 <_idt+0xf5>
	_idt[irq_number].ist = 0;
  10b95d:	c6 05 90 27 00 00 00 	mov    BYTE PTR [rip+0x2790],0x0        # 10e0f4 <_idt+0xf4>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b964:	41 bd 18 00 00 00    	mov    r13d,0x18
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b96a:	89 05 98 27 00 00    	mov    DWORD PTR [rip+0x2798],eax        # 10e108 <_idt+0x108>
		idt_install_interrupt(17, (uintptr_t)asm_isr17);
  10b970:	b8 52 c7 10 00       	mov    eax,0x10c752
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b975:	66 89 15 86 27 00 00 	mov    WORD PTR [rip+0x2786],dx        # 10e102 <_idt+0x102>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b97c:	66 89 05 8d 27 00 00 	mov    WORD PTR [rip+0x278d],ax        # 10e110 <_idt+0x110>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b983:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b986:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b98a:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b98e:	89 05 84 27 00 00    	mov    DWORD PTR [rip+0x2784],eax        # 10e118 <_idt+0x118>
		idt_install_interrupt(18, (uintptr_t)asm_isr18);
  10b994:	b8 5a c7 10 00       	mov    eax,0x10c75a
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b999:	66 89 15 76 27 00 00 	mov    WORD PTR [rip+0x2776],dx        # 10e116 <_idt+0x116>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b9a0:	66 89 05 79 27 00 00 	mov    WORD PTR [rip+0x2779],ax        # 10e120 <_idt+0x120>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b9a7:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b9aa:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b9ae:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10b9b2:	66 89 0d 59 27 00 00 	mov    WORD PTR [rip+0x2759],cx        # 10e112 <_idt+0x112>
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b9b9:	89 05 69 27 00 00    	mov    DWORD PTR [rip+0x2769],eax        # 10e128 <_idt+0x128>
		idt_install_interrupt(19, (uintptr_t)asm_isr19);
  10b9bf:	b8 64 c7 10 00       	mov    eax,0x10c764
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b9c4:	66 89 15 5b 27 00 00 	mov    WORD PTR [rip+0x275b],dx        # 10e126 <_idt+0x126>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b9cb:	66 89 05 5e 27 00 00 	mov    WORD PTR [rip+0x275e],ax        # 10e130 <_idt+0x130>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b9d2:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b9d5:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b9d9:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b9dd:	89 05 55 27 00 00    	mov    DWORD PTR [rip+0x2755],eax        # 10e138 <_idt+0x138>
		idt_install_interrupt(20, (uintptr_t)asm_isr20);
  10b9e3:	b8 6e c7 10 00       	mov    eax,0x10c76e
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b9e8:	66 89 15 47 27 00 00 	mov    WORD PTR [rip+0x2747],dx        # 10e136 <_idt+0x136>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10b9ef:	66 89 05 4a 27 00 00 	mov    WORD PTR [rip+0x274a],ax        # 10e140 <_idt+0x140>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b9f6:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10b9f9:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10b9fd:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10ba01:	66 89 35 1a 27 00 00 	mov    WORD PTR [rip+0x271a],si        # 10e122 <_idt+0x122>
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10ba08:	89 05 3a 27 00 00    	mov    DWORD PTR [rip+0x273a],eax        # 10e148 <_idt+0x148>
		idt_install_interrupt(21, (uintptr_t)asm_isr21);
  10ba0e:	b8 78 c7 10 00       	mov    eax,0x10c778
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10ba13:	66 89 15 2c 27 00 00 	mov    WORD PTR [rip+0x272c],dx        # 10e146 <_idt+0x146>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10ba1a:	66 89 05 2f 27 00 00 	mov    WORD PTR [rip+0x272f],ax        # 10e150 <_idt+0x150>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10ba21:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10ba24:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10ba28:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10ba2c:	89 05 26 27 00 00    	mov    DWORD PTR [rip+0x2726],eax        # 10e158 <_idt+0x158>
		idt_install_interrupt(22, (uintptr_t)asm_isr22);
  10ba32:	b8 82 c7 10 00       	mov    eax,0x10c782
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10ba37:	66 44 89 05 f3 26 00 	mov    WORD PTR [rip+0x26f3],r8w        # 10e132 <_idt+0x132>
  10ba3e:	00 
  10ba3f:	66 44 89 0d fb 26 00 	mov    WORD PTR [rip+0x26fb],r9w        # 10e142 <_idt+0x142>
  10ba46:	00 
  10ba47:	b9 18 00 00 00       	mov    ecx,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10ba4c:	66 89 15 03 27 00 00 	mov    WORD PTR [rip+0x2703],dx        # 10e156 <_idt+0x156>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10ba53:	66 44 89 15 f7 26 00 	mov    WORD PTR [rip+0x26f7],r10w        # 10e152 <_idt+0x152>
  10ba5a:	00 
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10ba5b:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10ba5e:	c6 05 a0 26 00 00 8e 	mov    BYTE PTR [rip+0x26a0],0x8e        # 10e105 <_idt+0x105>
	_idt[irq_number].ist = 0;
  10ba65:	c6 05 98 26 00 00 00 	mov    BYTE PTR [rip+0x2698],0x0        # 10e104 <_idt+0x104>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10ba6c:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10ba70:	c6 05 9e 26 00 00 8e 	mov    BYTE PTR [rip+0x269e],0x8e        # 10e115 <_idt+0x115>
	_idt[irq_number].ist = 0;
  10ba77:	c6 05 96 26 00 00 00 	mov    BYTE PTR [rip+0x2696],0x0        # 10e114 <_idt+0x114>
  IDT_Entry *entry = (IDT_Entry *)entry_addr;
	entry->offset_0_15 = (uint16_t)(handler_addr & 0xFFFF);
	entry->offset_16_31 = (uint16_t)((handler_addr >> 16) & 0xFFFF);
	entry->offset_32_63 = (uint32_t)((handler_addr >> 32) & 0xFFFFFFFF);
	entry->type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | (is_user_accessible ?  PRIVILEGE_LEVEL_3 : PRIVILEGE_LEVEL_0); 
	entry->code_segment_selector = GDT_RING0_CODE;
  10ba7e:	be 18 00 00 00       	mov    esi,0x18
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10ba83:	c6 05 9b 26 00 00 8e 	mov    BYTE PTR [rip+0x269b],0x8e        # 10e125 <_idt+0x125>
	_idt[irq_number].ist = 0;
  10ba8a:	c6 05 93 26 00 00 00 	mov    BYTE PTR [rip+0x2693],0x0        # 10e124 <_idt+0x124>
  10ba91:	41 b8 18 00 00 00    	mov    r8d,0x18
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10ba97:	c6 05 97 26 00 00 8e 	mov    BYTE PTR [rip+0x2697],0x8e        # 10e135 <_idt+0x135>
	_idt[irq_number].ist = 0;
  10ba9e:	c6 05 8f 26 00 00 00 	mov    BYTE PTR [rip+0x268f],0x0        # 10e134 <_idt+0x134>
    //Ofline tool.  For now it is just done a runtime for simplicity
    idt_install_all_interrupts();
    struct {
      uint16_t limit;
      uintptr_t address;
    } __attribute__((packed)) idtr = { sizeof(_idt) - 1, (uintptr_t)_idt };
  10baa5:	41 b9 ff 0f 00 00    	mov    r9d,0xfff
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10baab:	c6 05 93 26 00 00 8e 	mov    BYTE PTR [rip+0x2693],0x8e        # 10e145 <_idt+0x145>
	_idt[irq_number].ist = 0;
  10bab2:	c6 05 8b 26 00 00 00 	mov    BYTE PTR [rip+0x268b],0x0        # 10e144 <_idt+0x144>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10bab9:	c6 05 95 26 00 00 8e 	mov    BYTE PTR [rip+0x2695],0x8e        # 10e155 <_idt+0x155>
	_idt[irq_number].ist = 0;
  10bac0:	c6 05 8d 26 00 00 00 	mov    BYTE PTR [rip+0x268d],0x0        # 10e154 <_idt+0x154>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10bac7:	66 89 05 92 26 00 00 	mov    WORD PTR [rip+0x2692],ax        # 10e160 <_idt+0x160>
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bace:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bad2:	66 89 15 8d 26 00 00 	mov    WORD PTR [rip+0x268d],dx        # 10e166 <_idt+0x166>
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bad9:	89 05 89 26 00 00    	mov    DWORD PTR [rip+0x2689],eax        # 10e168 <_idt+0x168>
		idt_install_interrupt(23, (uintptr_t)asm_isr23);
  10badf:	b8 8c c7 10 00       	mov    eax,0x10c78c
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bae4:	66 44 89 1d 76 26 00 	mov    WORD PTR [rip+0x2676],r11w        # 10e162 <_idt+0x162>
  10baeb:	00 
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10baec:	66 89 05 7d 26 00 00 	mov    WORD PTR [rip+0x267d],ax        # 10e170 <_idt+0x170>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10baf3:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10baf6:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bafa:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bafe:	89 05 74 26 00 00    	mov    DWORD PTR [rip+0x2674],eax        # 10e178 <_idt+0x178>
		idt_install_interrupt(24, (uintptr_t)asm_isr24);
  10bb04:	b8 96 c7 10 00       	mov    eax,0x10c796
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bb09:	66 89 15 66 26 00 00 	mov    WORD PTR [rip+0x2666],dx        # 10e176 <_idt+0x176>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10bb10:	66 89 05 69 26 00 00 	mov    WORD PTR [rip+0x2669],ax        # 10e180 <_idt+0x180>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bb17:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bb1a:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bb1e:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bb22:	66 89 2d 49 26 00 00 	mov    WORD PTR [rip+0x2649],bp        # 10e172 <_idt+0x172>
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bb29:	89 05 59 26 00 00    	mov    DWORD PTR [rip+0x2659],eax        # 10e188 <_idt+0x188>
		idt_install_interrupt(25, (uintptr_t)asm_isr25);
  10bb2f:	b8 a0 c7 10 00       	mov    eax,0x10c7a0
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bb34:	66 89 15 4b 26 00 00 	mov    WORD PTR [rip+0x264b],dx        # 10e186 <_idt+0x186>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10bb3b:	66 89 05 4e 26 00 00 	mov    WORD PTR [rip+0x264e],ax        # 10e190 <_idt+0x190>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bb42:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bb45:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bb49:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bb4d:	89 05 45 26 00 00    	mov    DWORD PTR [rip+0x2645],eax        # 10e198 <_idt+0x198>
		idt_install_interrupt(26, (uintptr_t)asm_isr26);
  10bb53:	b8 aa c7 10 00       	mov    eax,0x10c7aa
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bb58:	66 89 15 37 26 00 00 	mov    WORD PTR [rip+0x2637],dx        # 10e196 <_idt+0x196>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10bb5f:	66 89 05 3a 26 00 00 	mov    WORD PTR [rip+0x263a],ax        # 10e1a0 <_idt+0x1a0>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bb66:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bb69:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bb6d:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bb71:	66 44 89 25 09 26 00 	mov    WORD PTR [rip+0x2609],r12w        # 10e182 <_idt+0x182>
  10bb78:	00 
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bb79:	89 05 29 26 00 00    	mov    DWORD PTR [rip+0x2629],eax        # 10e1a8 <_idt+0x1a8>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bb7f:	b8 18 00 00 00       	mov    eax,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bb84:	66 89 15 1b 26 00 00 	mov    WORD PTR [rip+0x261b],dx        # 10e1a6 <_idt+0x1a6>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bb8b:	66 89 05 10 26 00 00 	mov    WORD PTR [rip+0x2610],ax        # 10e1a2 <_idt+0x1a2>
		idt_install_interrupt(27, (uintptr_t)asm_isr27);
  10bb92:	b8 b4 c7 10 00       	mov    eax,0x10c7b4
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bb97:	66 44 89 2d f3 25 00 	mov    WORD PTR [rip+0x25f3],r13w        # 10e192 <_idt+0x192>
  10bb9e:	00 
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bb9f:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10bba2:	66 89 05 07 26 00 00 	mov    WORD PTR [rip+0x2607],ax        # 10e1b0 <_idt+0x1b0>
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bba9:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bbad:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10bbb1:	c6 05 ad 25 00 00 8e 	mov    BYTE PTR [rip+0x25ad],0x8e        # 10e165 <_idt+0x165>
	_idt[irq_number].ist = 0;
  10bbb8:	c6 05 a5 25 00 00 00 	mov    BYTE PTR [rip+0x25a5],0x0        # 10e164 <_idt+0x164>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bbbf:	66 89 15 f0 25 00 00 	mov    WORD PTR [rip+0x25f0],dx        # 10e1b6 <_idt+0x1b6>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10bbc6:	c6 05 a8 25 00 00 8e 	mov    BYTE PTR [rip+0x25a8],0x8e        # 10e175 <_idt+0x175>
	_idt[irq_number].ist = 0;
  10bbcd:	c6 05 a0 25 00 00 00 	mov    BYTE PTR [rip+0x25a0],0x0        # 10e174 <_idt+0x174>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10bbd4:	c6 05 aa 25 00 00 8e 	mov    BYTE PTR [rip+0x25aa],0x8e        # 10e185 <_idt+0x185>
	_idt[irq_number].ist = 0;
  10bbdb:	c6 05 a2 25 00 00 00 	mov    BYTE PTR [rip+0x25a2],0x0        # 10e184 <_idt+0x184>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10bbe2:	c6 05 ac 25 00 00 8e 	mov    BYTE PTR [rip+0x25ac],0x8e        # 10e195 <_idt+0x195>
	_idt[irq_number].ist = 0;
  10bbe9:	c6 05 a4 25 00 00 00 	mov    BYTE PTR [rip+0x25a4],0x0        # 10e194 <_idt+0x194>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10bbf0:	c6 05 ae 25 00 00 8e 	mov    BYTE PTR [rip+0x25ae],0x8e        # 10e1a5 <_idt+0x1a5>
	_idt[irq_number].ist = 0;
  10bbf7:	c6 05 a6 25 00 00 00 	mov    BYTE PTR [rip+0x25a6],0x0        # 10e1a4 <_idt+0x1a4>
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bbfe:	89 05 b4 25 00 00    	mov    DWORD PTR [rip+0x25b4],eax        # 10e1b8 <_idt+0x1b8>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bc04:	b8 18 00 00 00       	mov    eax,0x18
  10bc09:	66 89 05 a2 25 00 00 	mov    WORD PTR [rip+0x25a2],ax        # 10e1b2 <_idt+0x1b2>
		idt_install_interrupt(28, (uintptr_t)asm_isr28);
  10bc10:	b8 be c7 10 00       	mov    eax,0x10c7be
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10bc15:	c6 05 99 25 00 00 8e 	mov    BYTE PTR [rip+0x2599],0x8e        # 10e1b5 <_idt+0x1b5>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10bc1c:	66 89 05 9d 25 00 00 	mov    WORD PTR [rip+0x259d],ax        # 10e1c0 <_idt+0x1c0>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bc23:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bc26:	48 c1 e8 20          	shr    rax,0x20
  10bc2a:	89 05 98 25 00 00    	mov    DWORD PTR [rip+0x2598],eax        # 10e1c8 <_idt+0x1c8>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bc30:	b8 18 00 00 00       	mov    eax,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bc35:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bc39:	66 89 05 82 25 00 00 	mov    WORD PTR [rip+0x2582],ax        # 10e1c2 <_idt+0x1c2>
		idt_install_interrupt(29, (uintptr_t)asm_isr29);
  10bc40:	b8 c8 c7 10 00       	mov    eax,0x10c7c8
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bc45:	66 89 15 7a 25 00 00 	mov    WORD PTR [rip+0x257a],dx        # 10e1c6 <_idt+0x1c6>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10bc4c:	66 89 05 7d 25 00 00 	mov    WORD PTR [rip+0x257d],ax        # 10e1d0 <_idt+0x1d0>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bc53:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bc56:	48 c1 e8 20          	shr    rax,0x20
  10bc5a:	89 05 78 25 00 00    	mov    DWORD PTR [rip+0x2578],eax        # 10e1d8 <_idt+0x1d8>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bc60:	b8 18 00 00 00       	mov    eax,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bc65:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bc69:	66 89 05 62 25 00 00 	mov    WORD PTR [rip+0x2562],ax        # 10e1d2 <_idt+0x1d2>
		idt_install_interrupt(30, (uintptr_t)asm_isr30);
  10bc70:	b8 d2 c7 10 00       	mov    eax,0x10c7d2
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bc75:	66 89 15 5a 25 00 00 	mov    WORD PTR [rip+0x255a],dx        # 10e1d6 <_idt+0x1d6>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10bc7c:	66 89 05 5d 25 00 00 	mov    WORD PTR [rip+0x255d],ax        # 10e1e0 <_idt+0x1e0>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bc83:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bc86:	48 c1 e8 20          	shr    rax,0x20
  10bc8a:	89 05 58 25 00 00    	mov    DWORD PTR [rip+0x2558],eax        # 10e1e8 <_idt+0x1e8>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bc90:	b8 18 00 00 00       	mov    eax,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bc95:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bc99:	66 89 05 42 25 00 00 	mov    WORD PTR [rip+0x2542],ax        # 10e1e2 <_idt+0x1e2>
		idt_install_interrupt(31, (uintptr_t)asm_isr31);
  10bca0:	b8 dc c7 10 00       	mov    eax,0x10c7dc
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bca5:	66 89 15 3a 25 00 00 	mov    WORD PTR [rip+0x253a],dx        # 10e1e6 <_idt+0x1e6>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10bcac:	66 89 05 3d 25 00 00 	mov    WORD PTR [rip+0x253d],ax        # 10e1f0 <_idt+0x1f0>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bcb3:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bcb6:	48 c1 e8 20          	shr    rax,0x20
  10bcba:	89 05 38 25 00 00    	mov    DWORD PTR [rip+0x2538],eax        # 10e1f8 <_idt+0x1f8>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bcc0:	b8 18 00 00 00       	mov    eax,0x18
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bcc5:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bcc9:	66 89 05 22 25 00 00 	mov    WORD PTR [rip+0x2522],ax        # 10e1f2 <_idt+0x1f2>
		idt_install_interrupt(IRQ_PIT, (uintptr_t)asm_irq0);
  10bcd0:	b8 e6 c7 10 00       	mov    eax,0x10c7e6
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bcd5:	66 89 15 1a 25 00 00 	mov    WORD PTR [rip+0x251a],dx        # 10e1f6 <_idt+0x1f6>
  10bcdc:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10bcdf:	66 89 05 1a 25 00 00 	mov    WORD PTR [rip+0x251a],ax        # 10e200 <_idt+0x200>
	_idt[irq_number].ist = 0;
  10bce6:	c6 05 c7 24 00 00 00 	mov    BYTE PTR [rip+0x24c7],0x0        # 10e1b4 <_idt+0x1b4>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bced:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bcf1:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10bcf5:	c6 05 c9 24 00 00 8e 	mov    BYTE PTR [rip+0x24c9],0x8e        # 10e1c5 <_idt+0x1c5>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bcfc:	66 89 15 03 25 00 00 	mov    WORD PTR [rip+0x2503],dx        # 10e206 <_idt+0x206>
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bd03:	89 05 ff 24 00 00    	mov    DWORD PTR [rip+0x24ff],eax        # 10e208 <_idt+0x208>
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bd09:	ba 18 00 00 00       	mov    edx,0x18
		idt_install_interrupt(IRQ_KEYBOARD, (uintptr_t)asm_irq1);
  10bd0e:	b8 ee c7 10 00       	mov    eax,0x10c7ee
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bd13:	66 89 15 e8 24 00 00 	mov    WORD PTR [rip+0x24e8],dx        # 10e202 <_idt+0x202>
	_idt[irq_number].ist = 0;
  10bd1a:	c6 05 a3 24 00 00 00 	mov    BYTE PTR [rip+0x24a3],0x0        # 10e1c4 <_idt+0x1c4>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bd21:	48 89 c2             	mov    rdx,rax
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10bd24:	c6 05 aa 24 00 00 8e 	mov    BYTE PTR [rip+0x24aa],0x8e        # 10e1d5 <_idt+0x1d5>
	_idt[irq_number].ist = 0;
  10bd2b:	c6 05 a2 24 00 00 00 	mov    BYTE PTR [rip+0x24a2],0x0        # 10e1d4 <_idt+0x1d4>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10bd32:	c6 05 ac 24 00 00 8e 	mov    BYTE PTR [rip+0x24ac],0x8e        # 10e1e5 <_idt+0x1e5>
	_idt[irq_number].ist = 0;
  10bd39:	c6 05 a4 24 00 00 00 	mov    BYTE PTR [rip+0x24a4],0x0        # 10e1e4 <_idt+0x1e4>
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bd40:	48 c1 ea 10          	shr    rdx,0x10
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10bd44:	c6 05 aa 24 00 00 8e 	mov    BYTE PTR [rip+0x24aa],0x8e        # 10e1f5 <_idt+0x1f5>
	_idt[irq_number].ist = 0;
  10bd4b:	c6 05 a2 24 00 00 00 	mov    BYTE PTR [rip+0x24a2],0x0        # 10e1f4 <_idt+0x1f4>
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10bd52:	c6 05 ac 24 00 00 8e 	mov    BYTE PTR [rip+0x24ac],0x8e        # 10e205 <_idt+0x205>
	_idt[irq_number].ist = 0;
  10bd59:	c6 05 a4 24 00 00 00 	mov    BYTE PTR [rip+0x24a4],0x0        # 10e204 <_idt+0x204>
	_idt[irq_number].offset_0_15 = (uint16_t)(irq_handler_addr & 0xFFFF);
  10bd60:	66 89 05 a9 24 00 00 	mov    WORD PTR [rip+0x24a9],ax        # 10e210 <_idt+0x210>
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bd67:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].offset_16_31 = (uint16_t)((irq_handler_addr >> 16) & 0xFFFF);
  10bd6b:	66 89 15 a4 24 00 00 	mov    WORD PTR [rip+0x24a4],dx        # 10e216 <_idt+0x216>
	_idt[irq_number].offset_32_63 = (uint32_t)((irq_handler_addr >> 32) & 0xFFFFFFFF);
  10bd72:	89 05 a0 24 00 00    	mov    DWORD PTR [rip+0x24a0],eax        # 10e218 <_idt+0x218>
    idt_encode_entry((uintptr_t)&_idt[0x80], (uintptr_t)asm_syscall_handler, true);
  10bd78:	b8 be c6 10 00       	mov    eax,0x10c6be
	_idt[irq_number].type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | PRIVILEGE_LEVEL_0; 
  10bd7d:	c6 05 91 24 00 00 8e 	mov    BYTE PTR [rip+0x2491],0x8e        # 10e215 <_idt+0x215>
	entry->offset_0_15 = (uint16_t)(handler_addr & 0xFFFF);
  10bd84:	66 89 05 75 2a 00 00 	mov    WORD PTR [rip+0x2a75],ax        # 10e800 <_idt+0x800>
	entry->offset_16_31 = (uint16_t)((handler_addr >> 16) & 0xFFFF);
  10bd8b:	48 89 c2             	mov    rdx,rax
	entry->offset_32_63 = (uint32_t)((handler_addr >> 32) & 0xFFFFFFFF);
  10bd8e:	48 c1 e8 20          	shr    rax,0x20
	entry->offset_16_31 = (uint16_t)((handler_addr >> 16) & 0xFFFF);
  10bd92:	48 c1 ea 10          	shr    rdx,0x10
	entry->offset_32_63 = (uint32_t)((handler_addr >> 32) & 0xFFFFFFFF);
  10bd96:	89 05 6c 2a 00 00    	mov    DWORD PTR [rip+0x2a6c],eax        # 10e808 <_idt+0x808>
    idt_encode_entry((uintptr_t)&_idt[0x31], (uintptr_t)asm_spurious_interrupt_handler, true);
  10bd9c:	b8 4a c6 10 00       	mov    eax,0x10c64a
	entry->offset_16_31 = (uint16_t)((handler_addr >> 16) & 0xFFFF);
  10bda1:	66 89 15 5e 2a 00 00 	mov    WORD PTR [rip+0x2a5e],dx        # 10e806 <_idt+0x806>
  10bda8:	48 89 c2             	mov    rdx,rax
	entry->offset_0_15 = (uint16_t)(handler_addr & 0xFFFF);
  10bdab:	66 89 05 5e 25 00 00 	mov    WORD PTR [rip+0x255e],ax        # 10e310 <_idt+0x310>
	entry->offset_16_31 = (uint16_t)((handler_addr >> 16) & 0xFFFF);
  10bdb2:	48 c1 ea 10          	shr    rdx,0x10
	entry->offset_32_63 = (uint32_t)((handler_addr >> 32) & 0xFFFFFFFF);
  10bdb6:	48 c1 e8 20          	shr    rax,0x20
	_idt[irq_number].code_segment_selector = GDT_RING0_CODE;
  10bdba:	66 89 0d 51 24 00 00 	mov    WORD PTR [rip+0x2451],cx        # 10e212 <_idt+0x212>
	_idt[irq_number].ist = 0;
  10bdc1:	c6 05 4c 24 00 00 00 	mov    BYTE PTR [rip+0x244c],0x0        # 10e214 <_idt+0x214>
	entry->type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | (is_user_accessible ?  PRIVILEGE_LEVEL_3 : PRIVILEGE_LEVEL_0); 
  10bdc8:	c6 05 36 2a 00 00 ee 	mov    BYTE PTR [rip+0x2a36],0xee        # 10e805 <_idt+0x805>
	entry->code_segment_selector = GDT_RING0_CODE;
  10bdcf:	66 89 35 2c 2a 00 00 	mov    WORD PTR [rip+0x2a2c],si        # 10e802 <_idt+0x802>
	entry->ist = 0;
  10bdd6:	c6 05 27 2a 00 00 00 	mov    BYTE PTR [rip+0x2a27],0x0        # 10e804 <_idt+0x804>
	entry->offset_16_31 = (uint16_t)((handler_addr >> 16) & 0xFFFF);
  10bddd:	66 89 15 32 25 00 00 	mov    WORD PTR [rip+0x2532],dx        # 10e316 <_idt+0x316>
	entry->offset_32_63 = (uint32_t)((handler_addr >> 32) & 0xFFFFFFFF);
  10bde4:	89 05 2e 25 00 00    	mov    DWORD PTR [rip+0x252e],eax        # 10e318 <_idt+0x318>
	entry->type_and_attributes = PRESENT_BIT | TYPE_INTERRUPT_GATE_64 | (is_user_accessible ?  PRIVILEGE_LEVEL_3 : PRIVILEGE_LEVEL_0); 
  10bdea:	c6 05 24 25 00 00 ee 	mov    BYTE PTR [rip+0x2524],0xee        # 10e315 <_idt+0x315>
	entry->code_segment_selector = GDT_RING0_CODE;
  10bdf1:	66 44 89 05 19 25 00 	mov    WORD PTR [rip+0x2519],r8w        # 10e312 <_idt+0x312>
  10bdf8:	00 
	entry->ist = 0;
  10bdf9:	c6 05 14 25 00 00 00 	mov    BYTE PTR [rip+0x2514],0x0        # 10e314 <_idt+0x314>
    } __attribute__((packed)) idtr = { sizeof(_idt) - 1, (uintptr_t)_idt };
  10be00:	66 44 89 0c 24       	mov    WORD PTR [rsp],r9w
  10be05:	48 c7 44 24 02 00 e0 	mov    QWORD PTR [rsp+0x2],0x10e000
  10be0c:	10 00 
    asm volatile ("lidt %0" : : "m"(idtr));
  10be0e:	0f 01 1c 24          	lidt   [rsp]
    asm volatile ("sti");
  10be12:	fb                   	sti    
  g_p2_table.entries[1] = (uintptr_t)&g_p1_table.entries[0] | PAGE_WRITEABLE_BIT | PAGE_PRESENT_BIT;
  10be13:	b8 00 d0 10 00       	mov    eax,0x10d000


  kmem_initalize();

  //NOTE(Torin) Setup keyboard event stack
  globals.keyboard.scancode_event_stack = globals.keyboard.scancode_event_stack0;
  10be18:	48 c7 05 85 49 01 00 	mov    QWORD PTR [rip+0x14985],0x1207b0        # 1207a8 <globals+0x10648>
  10be1f:	b0 07 12 00 
  10be23:	48 83 c8 03          	or     rax,0x3


	if (multiboot2_magic != MULTIBOOT2_BOOTLOADER_MAGIC) {
  10be27:	48 81 ff 89 62 d7 36 	cmp    rdi,0x36d76289
  10be2e:	48 89 05 d3 81 01 00 	mov    QWORD PTR [rip+0x181d3],rax        # 124008 <g_p2_table+0x8>
  10be35:	74 1d                	je     10be54 <kernel_longmode_entry+0xa04>
		klog_error("the kernel was not booted with a multiboot2 compliant bootloader!");
  10be37:	be 60 15 10 00       	mov    esi,0x101560
  10be3c:	31 c0                	xor    eax,eax
  10be3e:	bf 60 01 11 00       	mov    edi,0x110160
  10be43:	e8 48 e3 ff ff       	call   10a190 <klog_write_fmt>
		kpanic();
  10be48:	bf 60 01 11 00       	mov    edi,0x110160
  10be4d:	e8 1e d3 ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10be52:	fa                   	cli    
  10be53:	f4                   	hlt    
	}

	if (multiboot2_address & 7) {
  10be54:	f6 c3 07             	test   bl,0x7
  10be57:	0f 85 51 03 00 00    	jne    10c1ae <kernel_longmode_entry+0xd5e>
	}

  struct multiboot_tag_framebuffer *fb_mbtag = 0; 
  uintptr_t rsdp_physical_address = 0;
	struct multiboot_tag *tag = (struct multiboot_tag *)(multiboot2_address + 8);
	while (tag->type != MULTIBOOT_TAG_TYPE_END) {
  10be5d:	8b 53 08             	mov    edx,DWORD PTR [rbx+0x8]
	struct multiboot_tag *tag = (struct multiboot_tag *)(multiboot2_address + 8);
  10be60:	48 8d 43 08          	lea    rax,[rbx+0x8]
	while (tag->type != MULTIBOOT_TAG_TYPE_END) {
  10be64:	85 d2                	test   edx,edx
  10be66:	0f 84 09 03 00 00    	je     10c175 <kernel_longmode_entry+0xd25>
  10be6c:	31 ed                	xor    ebp,ebp
  10be6e:	31 db                	xor    ebx,ebx
  10be70:	eb 1e                	jmp    10be90 <kernel_longmode_entry+0xa40>
		switch (tag->type) {
  10be72:	83 fa 0f             	cmp    edx,0xf
  10be75:	74 1e                	je     10be95 <kernel_longmode_entry+0xa45>
  10be77:	83 fa 08             	cmp    edx,0x8
  10be7a:	48 0f 44 d8          	cmove  rbx,rax
        }
        #endif
      };

		}
		tag = (struct multiboot_tag *)(((uint8_t *)tag) + ((tag->size + 7) & ~7));
  10be7e:	8b 48 04             	mov    ecx,DWORD PTR [rax+0x4]
  10be81:	8d 51 07             	lea    edx,[rcx+0x7]
  10be84:	83 e2 f8             	and    edx,0xfffffff8
  10be87:	48 01 d0             	add    rax,rdx
	while (tag->type != MULTIBOOT_TAG_TYPE_END) {
  10be8a:	8b 10                	mov    edx,DWORD PTR [rax]
  10be8c:	85 d2                	test   edx,edx
  10be8e:	74 0b                	je     10be9b <kernel_longmode_entry+0xa4b>
		switch (tag->type) {
  10be90:	83 fa 0e             	cmp    edx,0xe
  10be93:	75 dd                	jne    10be72 <kernel_longmode_entry+0xa22>
        rsdp_physical_address = (uintptr_t)acpi_info->rsdp;
  10be95:	48 8d 68 08          	lea    rbp,[rax+0x8]
			} break;
  10be99:	eb e3                	jmp    10be7e <kernel_longmode_entry+0xa2e>
	}

  //NOTE(Torin) Initalize the framebuffer
  if(fb_mbtag == 0) {
  10be9b:	48 85 db             	test   rbx,rbx
  10be9e:	49 89 ec             	mov    r12,rbp
  10bea1:	0f 84 d3 02 00 00    	je     10c17a <kernel_longmode_entry+0xd2a>
    kassert(0 && "MULTIBOOT FAILED TO PROVIDE FRAMEBUFFER TAG");
  }

  if(fb_mbtag->common.framebuffer_type != MULTIBOOT_FRAMEBUFFER_TYPE_RGB){
  10bea7:	80 7b 1d 01          	cmp    BYTE PTR [rbx+0x1d],0x1
  10beab:	0f 84 34 02 00 00    	je     10c0e5 <kernel_longmode_entry+0xc95>
    klog_info("this is a text buffer");
  10beb1:	be 90 0f 10 00       	mov    esi,0x100f90
  10beb6:	bf 60 01 11 00       	mov    edi,0x110160
  10bebb:	31 c0                	xor    eax,eax
  10bebd:	e8 ce e2 ff ff       	call   10a190 <klog_write_fmt>
    fb->pitch = fb_mbtag->common.framebuffer_pitch; 
    klog_debug("framebuffer: width: %u, height: %u, depth: %u", fb->width, fb->height, (uint32_t)fb->depth);
  }


  if(rsdp_physical_address == 0){
  10bec2:	48 85 ed             	test   rbp,rbp
  10bec5:	0f 84 e8 01 00 00    	je     10c0b3 <kernel_longmode_entry+0xc63>
    kassert(0 && "MULTIBOOT FAILED TO PROVIDE LOCATION OF RSDP");
  }

  System_Info *sys = &globals.system_info;
  parse_root_system_descriptor((RSDP_Descriptor_1*)rsdp_physical_address, sys);
  10becb:	be f0 07 12 00       	mov    esi,0x1207f0
  10bed0:	4c 89 e7             	mov    rdi,r12
  10bed3:	bb e0 00 11 00       	mov    ebx,0x1100e0
  10bed8:	e8 c3 e9 ff ff       	call   10a8a0 <parse_root_system_descriptor>
  {
    //TODO(Torin 2016-08-29) This should probably be established after
    //the other cpus are initalized
    extern uintptr_t stack_top;
    uintptr_t stack_top_ptr = (uintptr_t)&stack_top;
    sys->kernel_stack_address = stack_top_ptr;
  10bedd:	48 c7 05 28 49 01 00 	mov    QWORD PTR [rip+0x14928],0x127002        # 120810 <globals+0x106b0>
  10bee4:	02 70 12 00 
  for (size_t i = 0; i < size; i++) {
  10bee8:	31 c0                	xor    eax,eax
		dest[i] = value;
  10beea:	c6 80 e0 00 11 00 00 	mov    BYTE PTR [rax+0x1100e0],0x0
  for (size_t i = 0; i < size; i++) {
  10bef1:	48 83 c0 01          	add    rax,0x1
  10bef5:	48 83 f8 6c          	cmp    rax,0x6c
  10bef9:	75 ef                	jne    10beea <kernel_longmode_entry+0xa9a>
    memset(&g_tss_entry, 0x00, sizeof(g_tss_entry));
    g_tss_entry.rsp0 = stack_top_ptr;
    g_tss_entry.ist1 = stack_top_ptr;
    klog_debug("tss rsp0: 0x%X", g_tss_entry.rsp0);
  10befb:	31 c0                	xor    eax,eax
  10befd:	ba 02 70 12 00       	mov    edx,0x127002
  10bf02:	be a6 0f 10 00       	mov    esi,0x100fa6
  10bf07:	bf 60 01 11 00       	mov    edi,0x110160
    g_tss_entry.rsp0 = stack_top_ptr;
  10bf0c:	48 c7 05 cd 41 00 00 	mov    QWORD PTR [rip+0x41cd],0x127002        # 1100e4 <g_tss_entry+0x4>
  10bf13:	02 70 12 00 
    g_tss_entry.ist1 = stack_top_ptr;
  10bf17:	48 c7 05 e2 41 00 00 	mov    QWORD PTR [rip+0x41e2],0x127002        # 110104 <g_tss_entry+0x24>
  10bf1e:	02 70 12 00 
    klog_debug("tss rsp0: 0x%X", g_tss_entry.rsp0);
  10bf22:	e8 69 e2 ff ff       	call   10a190 <klog_write_fmt>
  descriptor.base_address_16_23 = (base_address >> 16) & 0xFF;
  10bf27:	48 89 d8             	mov    rax,rbx
  struct GDT_System_Descriptor descriptor = {};
  10bf2a:	48 c7 44 24 08 00 00 	mov    QWORD PTR [rsp+0x8],0x0
  10bf31:	00 00 
  descriptor.base_address_0_15  = (base_address >> 0) & 0xFFFF;
  10bf33:	66 89 5c 24 02       	mov    WORD PTR [rsp+0x2],bx
  descriptor.base_address_16_23 = (base_address >> 16) & 0xFF;
  10bf38:	48 c1 e8 10          	shr    rax,0x10
  struct GDT_System_Descriptor descriptor = {};
  10bf3c:	c6 44 24 10 00       	mov    BYTE PTR [rsp+0x10],0x0
  descriptor.available = 1;
  10bf41:	c6 44 24 06 10       	mov    BYTE PTR [rsp+0x6],0x10
  descriptor.base_address_16_23 = (base_address >> 16) & 0xFF;
  10bf46:	88 44 24 04          	mov    BYTE PTR [rsp+0x4],al
  descriptor.base_address_24_31 = (base_address >> 24) & 0xFF;
  10bf4a:	48 89 d8             	mov    rax,rbx
  descriptor.base_address_32_63 = (base_address >> 32) & 0xFFFFFFFF;
  10bf4d:	48 c1 eb 20          	shr    rbx,0x20
  descriptor.base_address_24_31 = (base_address >> 24) & 0xFF;
  10bf51:	48 c1 e8 18          	shr    rax,0x18
  descriptor.base_address_32_63 = (base_address >> 32) & 0xFFFFFFFF;
  10bf55:	89 5c 24 09          	mov    DWORD PTR [rsp+0x9],ebx
  descriptor.privlege_level = privlege_level;
  10bf59:	c6 44 24 05 e9       	mov    BYTE PTR [rsp+0x5],0xe9
  descriptor.base_address_24_31 = (base_address >> 24) & 0xFF;
  10bf5e:	66 25 ff 00          	and    ax,0xff
  10bf62:	66 89 44 24 07       	mov    WORD PTR [rsp+0x7],ax
  descriptor.segment_limit_0_15 = (segment_limit >> 0) & 0xFFFF;
  10bf67:	b8 ff 00 00 00       	mov    eax,0xff
  10bf6c:	66 89 04 24          	mov    WORD PTR [rsp],ax
	for (size_t i = 0; i < size; i++) {
  10bf70:	31 c0                	xor    eax,eax
		dest[i] = src[i];
  10bf72:	0f b6 14 04          	movzx  edx,BYTE PTR [rsp+rax*1]
	for (size_t i = 0; i < size; i++) {
  10bf76:	48 83 c0 01          	add    rax,0x1
		dest[i] = src[i];
  10bf7a:	88 90 47 87 10 00    	mov    BYTE PTR [rax+0x108747],dl
	for (size_t i = 0; i < size; i++) {
  10bf80:	48 83 f8 11          	cmp    rax,0x11
  10bf84:	75 ec                	jne    10bf72 <kernel_longmode_entry+0xb22>
  klog_debug("tss base address: 0x%X", base_address);
  10bf86:	31 c0                	xor    eax,eax
  10bf88:	ba e0 00 11 00       	mov    edx,0x1100e0
  10bf8d:	be b5 0f 10 00       	mov    esi,0x100fb5
  10bf92:	bf 60 01 11 00       	mov    edi,0x110160
  10bf97:	e8 f4 e1 ff ff       	call   10a190 <klog_write_fmt>
  klog_debug("tss limit: 0x%X", segment_limit);
  10bf9c:	ba ff 00 00 00       	mov    edx,0xff
  10bfa1:	be cc 0f 10 00       	mov    esi,0x100fcc
  10bfa6:	bf 60 01 11 00       	mov    edi,0x110160
  10bfab:	31 c0                	xor    eax,eax
  10bfad:	e8 de e1 ff ff       	call   10a190 <klog_write_fmt>

}

static inline
void tss_ldr(const uint16_t selector_index){
  asm volatile("cli");
  10bfb2:	fa                   	cli    
  
  //@Research
  //TODO(Torin: 2016-08-24) AMD64 system manual has the task_register with the above structure
  //It appears that is incorrect and its just a flat selector_index.  Make sure this is the case!
  uint16_t value = selector_index | 0b00; //This is probably what was ment?
  klog_debug("task_register selector_index: 0x%X", (uint32_t)value);
  10bfb3:	31 c0                	xor    eax,eax
  10bfb5:	ba 28 00 00 00       	mov    edx,0x28
  10bfba:	be 48 16 10 00       	mov    esi,0x101648
  10bfbf:	bf 60 01 11 00       	mov    edi,0x110160
  10bfc4:	e8 c7 e1 ff ff       	call   10a190 <klog_write_fmt>
  //asm volatile ("ltr %0" : : "a"(task_register.packed));
  asm volatile ("ltr %0" : : "a"(value));
  10bfc9:	b8 28 00 00 00       	mov    eax,0x28
  10bfce:	0f 00 d8             	ltr    ax
  asm volatile("sti");
  10bfd1:	fb                   	sti    
    //TODO(Torin) Real page allocator
    //NOTE(Torin) Arbitrarly maps the lapic and ioapic into the kernels virtual addresss space
    //And initalizes the iopapic and lapic
    sys->lapic_virtual_address = 0x0C200000;
    sys->ioapic_virtual_address = 0x0C400000;
    kmem_map_physical_to_virtual_2MB(sys->lapic_physical_address, sys->lapic_virtual_address);
  10bfd2:	48 8b 3d 17 48 01 00 	mov    rdi,QWORD PTR [rip+0x14817]        # 1207f0 <globals+0x10690>
  10bfd9:	be 00 00 20 0c       	mov    esi,0xc200000
    sys->lapic_virtual_address = 0x0C200000;
  10bfde:	48 c7 05 17 48 01 00 	mov    QWORD PTR [rip+0x14817],0xc200000        # 120800 <globals+0x106a0>
  10bfe5:	00 00 20 0c 
    sys->ioapic_virtual_address = 0x0C400000;
  10bfe9:	48 c7 05 14 48 01 00 	mov    QWORD PTR [rip+0x14814],0xc400000        # 120808 <globals+0x106a8>
  10bff0:	00 00 40 0c 
  10bff4:	41 bc 36 00 00 00    	mov    r12d,0x36
    kmem_map_physical_to_virtual_2MB(sys->lapic_physical_address, sys->lapic_virtual_address);
  10bffa:	e8 b1 ec ff ff       	call   10acb0 <kmem_map_physical_to_virtual_2MB>
    kmem_map_physical_to_virtual_2MB(sys->ioapic_physical_address, sys->ioapic_virtual_address);
  10bfff:	48 8b 35 02 48 01 00 	mov    rsi,QWORD PTR [rip+0x14802]        # 120808 <globals+0x106a8>
  10c006:	48 8b 3d eb 47 01 00 	mov    rdi,QWORD PTR [rip+0x147eb]        # 1207f8 <globals+0x10698>
  10c00d:	e8 9e ec ff ff       	call   10acb0 <kmem_map_physical_to_virtual_2MB>
  10c012:	44 89 e0             	mov    eax,r12d
  10c015:	e6 43                	out    0x43,al
  10c017:	bd a9 ff ff ff       	mov    ebp,0xffffffa9
  10c01c:	89 e8                	mov    eax,ebp
  10c01e:	e6 40                	out    0x40,al
  10c020:	bb 04 00 00 00       	mov    ebx,0x4
  10c025:	89 d8                	mov    eax,ebx
  10c027:	e6 40                	out    0x40,al
    pit_configure_timer(1000);
    asm volatile("hlt");
  10c029:	f4                   	hlt    
    klog_debug("got that irq yo");
  10c02a:	be dc 0f 10 00       	mov    esi,0x100fdc
  10c02f:	31 c0                	xor    eax,eax
  10c031:	bf 60 01 11 00       	mov    edi,0x110160
  10c036:	e8 55 e1 ff ff       	call   10a190 <klog_write_fmt>
    kgfx_draw_log_if_dirty(&globals.log);
  10c03b:	bf 60 01 11 00       	mov    edi,0x110160
  10c040:	e8 2b d1 ff ff       	call   109170 <kgfx_draw_log_if_dirty>
    asm volatile("sti");
  10c045:	fb                   	sti    
  10c046:	b8 20 00 00 00       	mov    eax,0x20
  10c04b:	e6 21                	out    0x21,al
  10c04d:	44 89 e0             	mov    eax,r12d
  10c050:	e6 43                	out    0x43,al
  10c052:	89 e8                	mov    eax,ebp
  10c054:	e6 40                	out    0x40,al
  10c056:	89 d8                	mov    eax,ebx
  10c058:	e6 40                	out    0x40,al
    write_port_uint8(0x21, 0x20);
    pit_configure_timer(1000);
    asm volatile ("hlt");
  10c05a:	f4                   	hlt    
  asm volatile("sti");
}

static void
lapic_initalize(uintptr_t apic_register_base) {
	asm volatile ("cli");
  10c05b:	fa                   	cli    
  10c05c:	b8 fe ff ff ff       	mov    eax,0xfffffffe
  10c061:	e6 21                	out    0x21,al
  10c063:	b8 ff ff ff ff       	mov    eax,0xffffffff
  10c068:	e6 a1                	out    0xa1,al
  uint32_t volatile *lapic = (uint32_t volatile *)(lapic_base + register_offset);
  10c06a:	48 8b 05 8f 47 01 00 	mov    rax,QWORD PTR [rip+0x1478f]        # 120800 <globals+0x106a0>
  lapic[0] = value;
  10c071:	c7 80 f0 00 00 00 31 	mov    DWORD PTR [rax+0xf0],0x131
  10c078:	01 00 00 
  //TODO(Torin) I dont think that this is configured correctly
  static const uint64_t APIC_SIVR_OFFSET = 0xF0;
  static const uint32_t SIVR_ENABLE = 1 << 8;
  static const uint32_t SIVR_FOCUS_CHECKING = 1 << 9;
  lapic_write_register(apic_register_base, APIC_SIVR_OFFSET, 0x31 | SIVR_ENABLE);
	asm volatile("sti");
  10c07b:	fb                   	sti    
    //klog_debug("lapic: physical = 0x%X, virtual = 0x%X", sys->lapic_physical_address, sys->ioapic_virtual_address);




    ioapic_initalize(sys->ioapic_virtual_address);
  10c07c:	48 8b 05 85 47 01 00 	mov    rax,QWORD PTR [rip+0x14785]        # 120808 <globals+0x106a8>
  asm volatile("cli");
  10c083:	fa                   	cli    
  ioapic[0] = offset;
  10c084:	c7 00 12 00 00 00    	mov    DWORD PTR [rax],0x12
  ioapic[4] = value;
  10c08a:	c7 40 10 21 00 00 00 	mov    DWORD PTR [rax+0x10],0x21
  ioapic[0] = offset;
  10c091:	c7 00 13 00 00 00    	mov    DWORD PTR [rax],0x13
  ioapic[4] = value;
  10c097:	c7 40 10 00 00 00 00 	mov    DWORD PTR [rax+0x10],0x0
  asm volatile("sti");
  10c09e:	fb                   	sti    
    klog_debug("apic initalized");
  10c09f:	be ec 0f 10 00       	mov    esi,0x100fec
  10c0a4:	bf 60 01 11 00       	mov    edi,0x110160
  10c0a9:	31 c0                	xor    eax,eax
  10c0ab:	e8 e0 e0 ff ff       	call   10a190 <klog_write_fmt>
  //pci_scan_devices();
  //kgfx_draw_log_if_dirty(&globals.log);

  //lapic_configure_timer(sys->lapic_virtual_address, 0xFFFF, 0x20, 1);

	while(1) { asm volatile("hlt"); };
  10c0b0:	f4                   	hlt    
  10c0b1:	eb fd                	jmp    10c0b0 <kernel_longmode_entry+0xc60>
    kassert(0 && "MULTIBOOT FAILED TO PROVIDE LOCATION OF RSDP");
  10c0b3:	41 b8 7d 0f 10 00    	mov    r8d,0x100f7d
  10c0b9:	b9 69 01 00 00       	mov    ecx,0x169
  10c0be:	ba 10 16 10 00       	mov    edx,0x101610
  10c0c3:	be 80 12 10 00       	mov    esi,0x101280
  10c0c8:	31 c0                	xor    eax,eax
  10c0ca:	bf 60 01 11 00       	mov    edi,0x110160
  10c0cf:	e8 bc e0 ff ff       	call   10a190 <klog_write_fmt>
  10c0d4:	bf 60 01 11 00       	mov    edi,0x110160
  10c0d9:	e8 92 d0 ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10c0de:	fa                   	cli    
  10c0df:	f4                   	hlt    
  10c0e0:	e9 e6 fd ff ff       	jmp    10becb <kernel_longmode_entry+0xa7b>
    uintptr_t page_offset = kmem_map_unaligned_physical_to_aligned_virtual_2MB(fb_mbtag->common.framebuffer_addr, framebuffer_virtual_address, PAGE_USER_ACCESS_BIT);
  10c0e5:	48 8b 43 08          	mov    rax,QWORD PTR [rbx+0x8]
  kmem_map_physical_to_virtual_2MB_ext(physical_address_to_map, virtual_address, flags);
  10c0e9:	ba 04 00 00 00       	mov    edx,0x4
  10c0ee:	be 00 00 00 0a       	mov    esi,0xa000000
	uint64_t displacement_from_page_boundray = requested_physical_address & 0x1FFFFF;
  10c0f3:	49 89 c5             	mov    r13,rax
  10c0f6:	41 81 e5 ff ff 1f 00 	and    r13d,0x1fffff
  physical_address_to_map -= displacement_from_page_boundray;
  10c0fd:	4c 29 e8             	sub    rax,r13
  10c100:	48 89 c7             	mov    rdi,rax
  kmem_map_physical_to_virtual_2MB_ext(physical_address_to_map, virtual_address, flags);
  10c103:	e8 c8 e6 ff ff       	call   10a7d0 <kmem_map_physical_to_virtual_2MB_ext>
    kmem_map_physical_to_virtual_2MB_ext(fb_mbtag->common.framebuffer_addr - page_offset + 0x200000, framebuffer_virtual_address + 0x200000, PAGE_USER_ACCESS_BIT);
  10c108:	48 8b 43 08          	mov    rax,QWORD PTR [rbx+0x8]
  10c10c:	ba 04 00 00 00       	mov    edx,0x4
  10c111:	be 00 00 20 0a       	mov    esi,0xa200000
  10c116:	48 8d b8 00 00 20 00 	lea    rdi,[rax+0x200000]
  10c11d:	4c 29 ef             	sub    rdi,r13
  10c120:	e8 ab e6 ff ff       	call   10a7d0 <kmem_map_physical_to_virtual_2MB_ext>
    fb->width = fb_mbtag->common.framebuffer_width; 
  10c125:	8b 53 14             	mov    edx,DWORD PTR [rbx+0x14]
    fb->height = fb_mbtag->common.framebuffer_height;
  10c128:	8b 4b 18             	mov    ecx,DWORD PTR [rbx+0x18]
    klog_debug("framebuffer: width: %u, height: %u, depth: %u", fb->width, fb->height, (uint32_t)fb->depth);
  10c12b:	be e0 15 10 00       	mov    esi,0x1015e0
    fb->buffer = (uint8_t *)framebuffer_virtual_address;
  10c130:	48 c7 05 3d 47 01 00 	mov    QWORD PTR [rip+0x1473d],0xa000000        # 120878 <globals+0x10718>
  10c137:	00 00 00 0a 
    klog_debug("framebuffer: width: %u, height: %u, depth: %u", fb->width, fb->height, (uint32_t)fb->depth);
  10c13b:	bf 60 01 11 00       	mov    edi,0x110160
    fb->width = fb_mbtag->common.framebuffer_width; 
  10c140:	89 15 22 47 01 00    	mov    DWORD PTR [rip+0x14722],edx        # 120868 <globals+0x10708>
    fb->height = fb_mbtag->common.framebuffer_height;
  10c146:	89 0d 20 47 01 00    	mov    DWORD PTR [rip+0x14720],ecx        # 12086c <globals+0x1070c>
    fb->depth = fb_mbtag->common.framebuffer_bpp / 8; 
  10c14c:	44 0f b6 43 1c       	movzx  r8d,BYTE PTR [rbx+0x1c]
  10c151:	41 c0 e8 03          	shr    r8b,0x3
  10c155:	44 88 05 18 47 01 00 	mov    BYTE PTR [rip+0x14718],r8b        # 120874 <globals+0x10714>
    fb->pitch = fb_mbtag->common.framebuffer_pitch; 
  10c15c:	8b 43 10             	mov    eax,DWORD PTR [rbx+0x10]
    klog_debug("framebuffer: width: %u, height: %u, depth: %u", fb->width, fb->height, (uint32_t)fb->depth);
  10c15f:	41 83 e0 1f          	and    r8d,0x1f
    fb->pitch = fb_mbtag->common.framebuffer_pitch; 
  10c163:	89 05 07 47 01 00    	mov    DWORD PTR [rip+0x14707],eax        # 120870 <globals+0x10710>
    klog_debug("framebuffer: width: %u, height: %u, depth: %u", fb->width, fb->height, (uint32_t)fb->depth);
  10c169:	31 c0                	xor    eax,eax
  10c16b:	e8 20 e0 ff ff       	call   10a190 <klog_write_fmt>
  10c170:	e9 4d fd ff ff       	jmp    10bec2 <kernel_longmode_entry+0xa72>
	while (tag->type != MULTIBOOT_TAG_TYPE_END) {
  10c175:	45 31 e4             	xor    r12d,r12d
  uintptr_t rsdp_physical_address = 0;
  10c178:	31 ed                	xor    ebp,ebp
    kassert(0 && "MULTIBOOT FAILED TO PROVIDE FRAMEBUFFER TAG");
  10c17a:	41 b8 7d 0f 10 00    	mov    r8d,0x100f7d
  10c180:	b9 54 01 00 00       	mov    ecx,0x154
  10c185:	ba a8 15 10 00       	mov    edx,0x1015a8
  10c18a:	be 80 12 10 00       	mov    esi,0x101280
  10c18f:	31 c0                	xor    eax,eax
  10c191:	bf 60 01 11 00       	mov    edi,0x110160
  10c196:	e8 f5 df ff ff       	call   10a190 <klog_write_fmt>
  10c19b:	bf 60 01 11 00       	mov    edi,0x110160
  10c1a0:	e8 cb cf ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10c1a5:	fa                   	cli    
  10c1a6:	f4                   	hlt    
  10c1a7:	31 db                	xor    ebx,ebx
  10c1a9:	e9 f9 fc ff ff       	jmp    10bea7 <kernel_longmode_entry+0xa57>
		klog_error("unaligned multiboot_info!");
  10c1ae:	be 63 0f 10 00       	mov    esi,0x100f63
  10c1b3:	31 c0                	xor    eax,eax
  10c1b5:	bf 60 01 11 00       	mov    edi,0x110160
  10c1ba:	e8 d1 df ff ff       	call   10a190 <klog_write_fmt>
		kpanic();
  10c1bf:	bf 60 01 11 00       	mov    edi,0x110160
  10c1c4:	e8 a7 cf ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10c1c9:	fa                   	cli    
  10c1ca:	f4                   	hlt    
  10c1cb:	e9 8d fc ff ff       	jmp    10be5d <kernel_longmode_entry+0xa0d>

000000000010c1d0 <ktask_context_switch>:
void ktask_context_switch(uint64_t thread_id, Task_Info *task_info){
  10c1d0:	55                   	push   rbp
  10c1d1:	53                   	push   rbx
  10c1d2:	48 89 fd             	mov    rbp,rdi
  10c1d5:	48 89 f3             	mov    rbx,rsi
  10c1d8:	48 83 ec 08          	sub    rsp,0x8
  for(size_t i = 0; i < globals.system_info.cpu_count; i++){
  10c1dc:	8b 15 76 46 01 00    	mov    edx,DWORD PTR [rip+0x14676]        # 120858 <globals+0x106f8>
  uint32_t volatile *lapic_register = (uint32_t volatile *)(lapic_base + register_offset);
  10c1e2:	48 8b 05 17 46 01 00 	mov    rax,QWORD PTR [rip+0x14617]        # 120800 <globals+0x106a0>
  10c1e9:	85 d2                	test   edx,edx
  return lapic_register[0];
  10c1eb:	8b 40 20             	mov    eax,DWORD PTR [rax+0x20]
  10c1ee:	74 08                	je     10c1f8 <ktask_context_switch+0x28>
    if(globals.system_info.cpu_lapic_ids[0] == lapic_id) return i;
  10c1f0:	39 05 22 46 01 00    	cmp    DWORD PTR [rip+0x14622],eax        # 120818 <globals+0x106b8>
  10c1f6:	74 1d                	je     10c215 <ktask_context_switch+0x45>
  klog_error("UNREGISTER LAPIC ID WAS USED TO GFT CPU ID");
  10c1f8:	be 90 14 10 00       	mov    esi,0x101490
  10c1fd:	31 c0                	xor    eax,eax
  10c1ff:	bf 60 01 11 00       	mov    edi,0x110160
  10c204:	e8 87 df ff ff       	call   10a190 <klog_write_fmt>
  kpanic();
  10c209:	bf 60 01 11 00       	mov    edi,0x110160
  10c20e:	e8 5d cf ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10c213:	fa                   	cli    
  10c214:	f4                   	hlt    
  Thread_Context *ctx = &task_info->threads[thread_id];
  10c215:	48 8d 44 ad 00       	lea    rax,[rbp+rbp*4+0x0]
  10c21a:	48 c1 e0 03          	shl    rax,0x3
  10c21e:	48 8d 94 03 00 03 00 	lea    rdx,[rbx+rax*1+0x300]
  10c225:	00 
  10c226:	48 89 93 00 0d 00 00 	mov    QWORD PTR [rbx+0xd00],rdx
  asm_enter_usermode((uintptr_t)ctx->rip, ctx->rsp);
  10c22d:	48 01 c3             	add    rbx,rax
  10c230:	48 8b b3 10 03 00 00 	mov    rsi,QWORD PTR [rbx+0x310]
  10c237:	48 8b bb 18 03 00 00 	mov    rdi,QWORD PTR [rbx+0x318]
}
  10c23e:	48 83 c4 08          	add    rsp,0x8
  10c242:	5b                   	pop    rbx
  10c243:	5d                   	pop    rbp
  asm_enter_usermode((uintptr_t)ctx->rip, ctx->rsp);
  10c244:	e9 eb 05 00 00       	jmp    10c834 <asm_enter_usermode>
  10c249:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

000000000010c250 <klog_add_input_character>:

void klog_add_input_character(Circular_Log *log, const char c){
  if(c < ' ' || c > '~') return;
  10c250:	8d 46 e0             	lea    eax,[rsi-0x20]
  10c253:	3c 5e                	cmp    al,0x5e
  10c255:	76 02                	jbe    10c259 <klog_add_input_character+0x9>
  10c257:	f3 c3                	repz ret 
  10c259:	48 8d 97 20 05 01 00 	lea    rdx,[rdi+0x10520]
  while(!__sync_bool_compare_and_swap(&lock->lock, 0, 1));
  10c260:	45 31 c0             	xor    r8d,r8d
  10c263:	b9 01 00 00 00       	mov    ecx,0x1
  10c268:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  10c26f:	00 
  10c270:	44 89 c0             	mov    eax,r8d
  10c273:	f0 0f b1 0a          	lock cmpxchg DWORD PTR [rdx],ecx
  10c277:	75 f7                	jne    10c270 <klog_add_input_character+0x20>
  __sync_synchronize();
  10c279:	0f ae f0             	mfence 
  spinlock_aquire(&log->spinlock);
  if(log->input_buffer_count > sizeof(log->input_buffer)) {
  10c27c:	48 8b 87 18 05 01 00 	mov    rax,QWORD PTR [rdi+0x10518]
  10c283:	48 3d 00 01 00 00    	cmp    rax,0x100
  10c289:	77 1a                	ja     10c2a5 <klog_add_input_character+0x55>
    spinlock_release(&log->spinlock);
    return;
  }
  log->input_buffer[log->input_buffer_count++] = c;
  10c28b:	48 8d 50 01          	lea    rdx,[rax+0x1]
  10c28f:	48 89 97 18 05 01 00 	mov    QWORD PTR [rdi+0x10518],rdx
  10c296:	40 88 b4 07 18 04 01 	mov    BYTE PTR [rdi+rax*1+0x10418],sil
  10c29d:	00 
  log->is_dirty = true;
  10c29e:	c6 87 24 05 01 00 01 	mov    BYTE PTR [rdi+0x10524],0x1
  __sync_synchronize(); 
  10c2a5:	0f ae f0             	mfence 
  lock->lock = 0;
  10c2a8:	c7 87 20 05 01 00 00 	mov    DWORD PTR [rdi+0x10520],0x0
  10c2af:	00 00 00 
  10c2b2:	c3                   	ret    
  10c2b3:	0f 1f 00             	nop    DWORD PTR [rax]
  10c2b6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10c2bd:	00 00 00 

000000000010c2c0 <klog_remove_last_input_character>:
  spinlock_release(&log->spinlock);
}

void klog_remove_last_input_character(Circular_Log *log){
  10c2c0:	48 8d 97 20 05 01 00 	lea    rdx,[rdi+0x10520]
  while(!__sync_bool_compare_and_swap(&lock->lock, 0, 1));
  10c2c7:	31 f6                	xor    esi,esi
  10c2c9:	b9 01 00 00 00       	mov    ecx,0x1
  10c2ce:	66 90                	xchg   ax,ax
  10c2d0:	89 f0                	mov    eax,esi
  10c2d2:	f0 0f b1 0a          	lock cmpxchg DWORD PTR [rdx],ecx
  10c2d6:	75 f8                	jne    10c2d0 <klog_remove_last_input_character+0x10>
  __sync_synchronize();
  10c2d8:	0f ae f0             	mfence 
  spinlock_aquire(&log->spinlock);
  if(log->input_buffer_count > 0) {
  10c2db:	48 8b 87 18 05 01 00 	mov    rax,QWORD PTR [rdi+0x10518]
  10c2e2:	48 85 c0             	test   rax,rax
  10c2e5:	74 13                	je     10c2fa <klog_remove_last_input_character+0x3a>
    log->input_buffer[log->input_buffer_count] = 0;
  10c2e7:	c6 84 07 18 04 01 00 	mov    BYTE PTR [rdi+rax*1+0x10418],0x0
  10c2ee:	00 
    log->input_buffer_count -= 1;
  10c2ef:	48 83 e8 01          	sub    rax,0x1
  10c2f3:	48 89 87 18 05 01 00 	mov    QWORD PTR [rdi+0x10518],rax
  }
  log->is_dirty = true;
  10c2fa:	c6 87 24 05 01 00 01 	mov    BYTE PTR [rdi+0x10524],0x1
  __sync_synchronize(); 
  10c301:	0f ae f0             	mfence 
  lock->lock = 0;
  10c304:	c7 87 20 05 01 00 00 	mov    DWORD PTR [rdi+0x10520],0x0
  10c30b:	00 00 00 
  10c30e:	c3                   	ret    
  10c30f:	90                   	nop

000000000010c310 <klog_disable>:
}

	

void klog_disable(){
  globals.is_logging_disabled = true;
  10c310:	c6 05 f1 52 01 00 01 	mov    BYTE PTR [rip+0x152f1],0x1        # 121608 <globals+0x114a8>
  10c317:	c3                   	ret    
  10c318:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  10c31f:	00 

000000000010c320 <klog_enable>:
}

void klog_enable(){
  globals.is_logging_disabled = false;
  10c320:	c6 05 e1 52 01 00 00 	mov    BYTE PTR [rip+0x152e1],0x0        # 121608 <globals+0x114a8>
  10c327:	c3                   	ret    
  10c328:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  10c32f:	00 

000000000010c330 <kshell_process_command>:
static void
kshell_unimplemented_command(const char *text, size_t length){
  klog_error("%s is an unimplemented command!", text);
}

void kshell_process_command(const char *input, size_t length){
  10c330:	41 55                	push   r13
  10c332:	41 54                	push   r12
  for(size_t i = 0; i < length; i++) 
  10c334:	31 c0                	xor    eax,eax
  10c336:	55                   	push   rbp
  10c337:	53                   	push   rbx
  10c338:	48 83 ec 08          	sub    rsp,0x8
    if(str0[i] != str1[i]) return 0;
  10c33c:	0f b6 98 fc 0f 10 00 	movzx  ebx,BYTE PTR [rax+0x100ffc]
  10c343:	38 1c 07             	cmp    BYTE PTR [rdi+rax*1],bl
  10c346:	0f 85 94 00 00 00    	jne    10c3e0 <kshell_process_command+0xb0>
  for(size_t i = 0; i < length; i++) 
  10c34c:	48 83 c0 01          	add    rax,0x1
  10c350:	48 83 f8 04          	cmp    rax,0x4
  10c354:	75 e6                	jne    10c33c <kshell_process_command+0xc>
  klog_info("kshell command list:");
  10c356:	be 4a 10 10 00       	mov    esi,0x10104a
  10c35b:	bf 60 01 11 00       	mov    edi,0x110160
  10c360:	31 c0                	xor    eax,eax
  10c362:	e8 29 de ff ff       	call   10a190 <klog_write_fmt>
  KShell_Command_Metalist
  10c367:	ba fc 0f 10 00       	mov    edx,0x100ffc
  10c36c:	be 5f 10 10 00       	mov    esi,0x10105f
  10c371:	bf 60 01 11 00       	mov    edi,0x110160
  10c376:	31 c0                	xor    eax,eax
  10c378:	e8 13 de ff ff       	call   10a190 <klog_write_fmt>
  10c37d:	ba 01 10 10 00       	mov    edx,0x101001
  10c382:	be 5f 10 10 00       	mov    esi,0x10105f
  10c387:	bf 60 01 11 00       	mov    edi,0x110160
  10c38c:	31 c0                	xor    eax,eax
  10c38e:	e8 fd dd ff ff       	call   10a190 <klog_write_fmt>
  10c393:	ba 0f 10 10 00       	mov    edx,0x10100f
  10c398:	be 5f 10 10 00       	mov    esi,0x10105f
  10c39d:	bf 60 01 11 00       	mov    edi,0x110160
  10c3a2:	31 c0                	xor    eax,eax
  10c3a4:	e8 e7 dd ff ff       	call   10a190 <klog_write_fmt>
  10c3a9:	ba 14 10 10 00       	mov    edx,0x101014
  10c3ae:	be 5f 10 10 00       	mov    esi,0x10105f
  10c3b3:	bf 60 01 11 00       	mov    edi,0x110160
  10c3b8:	31 c0                	xor    eax,eax
  10c3ba:	e8 d1 dd ff ff       	call   10a190 <klog_write_fmt>
  10c3bf:	ba 41 10 10 00       	mov    edx,0x101041
  10c3c4:	be 5f 10 10 00       	mov    esi,0x10105f
  }
  KShell_Command_Metalist
  #undef _

  klog_error("%s is not a shell command", input);
}
  10c3c9:	48 83 c4 08          	add    rsp,0x8
  klog_error("%s is not a shell command", input);
  10c3cd:	bf 60 01 11 00       	mov    edi,0x110160
  10c3d2:	31 c0                	xor    eax,eax
}
  10c3d4:	5b                   	pop    rbx
  10c3d5:	5d                   	pop    rbp
  10c3d6:	41 5c                	pop    r12
  10c3d8:	41 5d                	pop    r13
  klog_error("%s is not a shell command", input);
  10c3da:	e9 b1 dd ff ff       	jmp    10a190 <klog_write_fmt>
  10c3df:	90                   	nop
    if(str0[i] != str1[i]) return 0;
  10c3e0:	31 c0                	xor    eax,eax
  10c3e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  10c3e8:	0f b6 0c 07          	movzx  ecx,BYTE PTR [rdi+rax*1]
  10c3ec:	38 88 01 10 10 00    	cmp    BYTE PTR [rax+0x101001],cl
  10c3f2:	75 1c                	jne    10c410 <kshell_process_command+0xe0>
  for(size_t i = 0; i < length; i++) 
  10c3f4:	48 83 c0 01          	add    rax,0x1
  10c3f8:	48 83 f8 0d          	cmp    rax,0xd
  10c3fc:	75 ea                	jne    10c3e8 <kshell_process_command+0xb8>
}
  10c3fe:	58                   	pop    rax
  10c3ff:	5b                   	pop    rbx
  10c400:	5d                   	pop    rbp
  10c401:	41 5c                	pop    r12
  10c403:	41 5d                	pop    r13
  10c405:	c3                   	ret    
  10c406:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10c40d:	00 00 00 
    if(str0[i] != str1[i]) return 0;
  10c410:	31 c0                	xor    eax,eax
  10c412:	0f b6 14 07          	movzx  edx,BYTE PTR [rdi+rax*1]
  10c416:	38 90 0f 10 10 00    	cmp    BYTE PTR [rax+0x10100f],dl
  10c41c:	75 1a                	jne    10c438 <kshell_process_command+0x108>
  for(size_t i = 0; i < length; i++) 
  10c41e:	48 83 c0 01          	add    rax,0x1
  10c422:	48 83 f8 04          	cmp    rax,0x4
  10c426:	75 ea                	jne    10c412 <kshell_process_command+0xe2>
  klog_error("%s is an unimplemented command!", text);
  10c428:	48 89 fa             	mov    rdx,rdi
  10c42b:	be 70 16 10 00       	mov    esi,0x101670
  10c430:	eb 97                	jmp    10c3c9 <kshell_process_command+0x99>
  10c432:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    if(str0[i] != str1[i]) return 0;
  10c438:	31 c0                	xor    eax,eax
  10c43a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  10c440:	0f b6 34 07          	movzx  esi,BYTE PTR [rdi+rax*1]
  10c444:	40 38 b0 14 10 10 00 	cmp    BYTE PTR [rax+0x101014],sil
  10c44b:	75 7b                	jne    10c4c8 <kshell_process_command+0x198>
  for(size_t i = 0; i < length; i++) 
  10c44d:	48 83 c0 01          	add    rax,0x1
  10c451:	48 83 f8 0e          	cmp    rax,0xe
  10c455:	75 e9                	jne    10c440 <kshell_process_command+0x110>
  10c457:	4c 8b 2d aa 43 01 00 	mov    r13,QWORD PTR [rip+0x143aa]        # 120808 <globals+0x106a8>
  kdebug_ioapic_log_irq_map(globals.system_info.ioapic_virtual_address);
  10c45e:	41 bc 10 00 00 00    	mov    r12d,0x10
  }
}

static void
kdebug_ioapic_log_irq_map(uintptr_t ioapic_base){
  for(size_t i = 0; i < 8; i++){
  10c464:	31 ed                	xor    ebp,ebp
  ioapic[0] = offset;
  10c466:	45 89 65 00          	mov    DWORD PTR [r13+0x0],r12d
  return ioapic[4];
  10c46a:	41 8b 5d 10          	mov    ebx,DWORD PTR [r13+0x10]
    IOAPIC_IRQR_LOW irqr_low = {};
    //IOAPIC_IRQR_HIGH irqr_high = {};
    irqr_low.packed = ioapic_read_register(ioapic_base, 0x10 + (i * 2));
    //irqr_high.packed = ioapic_read_register(ioapic_base, 0x10 + (i * 2) + 1);
    klog_debug("IRQ %u", (uint32_t)i);
  10c46e:	89 ea                	mov    edx,ebp
  10c470:	31 c0                	xor    eax,eax
  10c472:	be 23 10 10 00       	mov    esi,0x101023
  10c477:	bf 60 01 11 00       	mov    edi,0x110160
  10c47c:	e8 0f dd ff ff       	call   10a190 <klog_write_fmt>
    klog_debug("  vector: %u", (uint32_t)irqr_low.vector);
  10c481:	0f b6 d3             	movzx  edx,bl
  10c484:	31 c0                	xor    eax,eax
  10c486:	be 2a 10 10 00       	mov    esi,0x10102a
  10c48b:	bf 60 01 11 00       	mov    edi,0x110160
    klog_debug("  mask %u", (uint32_t)irqr_low.mask);
  10c490:	c1 eb 0f             	shr    ebx,0xf
  for(size_t i = 0; i < 8; i++){
  10c493:	48 83 c5 01          	add    rbp,0x1
    klog_debug("  vector: %u", (uint32_t)irqr_low.vector);
  10c497:	e8 f4 dc ff ff       	call   10a190 <klog_write_fmt>
    klog_debug("  mask %u", (uint32_t)irqr_low.mask);
  10c49c:	89 da                	mov    edx,ebx
  10c49e:	31 c0                	xor    eax,eax
  10c4a0:	be 37 10 10 00       	mov    esi,0x101037
  10c4a5:	83 e2 01             	and    edx,0x1
  10c4a8:	bf 60 01 11 00       	mov    edi,0x110160
  10c4ad:	41 83 c4 02          	add    r12d,0x2
  10c4b1:	e8 da dc ff ff       	call   10a190 <klog_write_fmt>
  for(size_t i = 0; i < 8; i++){
  10c4b6:	48 83 fd 08          	cmp    rbp,0x8
  10c4ba:	75 aa                	jne    10c466 <kshell_process_command+0x136>
  10c4bc:	e9 3d ff ff ff       	jmp    10c3fe <kshell_process_command+0xce>
  10c4c1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
    if(str0[i] != str1[i]) return 0;
  10c4c8:	31 c0                	xor    eax,eax
  10c4ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
  10c4d0:	0f b6 1c 07          	movzx  ebx,BYTE PTR [rdi+rax*1]
  10c4d4:	38 98 41 10 10 00    	cmp    BYTE PTR [rax+0x101041],bl
  10c4da:	0f 85 e0 00 00 00    	jne    10c5c0 <kshell_process_command+0x290>
  for(size_t i = 0; i < length; i++) 
  10c4e0:	48 83 c0 01          	add    rax,0x1
  10c4e4:	48 83 f8 08          	cmp    rax,0x8
  10c4e8:	75 e6                	jne    10c4d0 <kshell_process_command+0x1a0>
  lapic_configure_timer(globals.system_info.lapic_virtual_address, 0x00, 0x20, 0);
  10c4ea:	48 8b 05 0f 43 01 00 	mov    rax,QWORD PTR [rip+0x1430f]        # 120800 <globals+0x106a0>
  uint64_t pid = ktask_create_process((uintptr_t)TEST_PROGRAM_ELF, &globals.task_info);
  10c4f1:	be 80 08 12 00       	mov    esi,0x120880
  10c4f6:	bf a0 17 10 00       	mov    edi,0x1017a0
  lapic[0] = value;
  10c4fb:	c7 80 80 03 00 00 00 	mov    DWORD PTR [rax+0x380],0x0
  10c502:	00 00 00 
  10c505:	c7 80 e0 03 00 00 03 	mov    DWORD PTR [rax+0x3e0],0x3
  10c50c:	00 00 00 
  10c50f:	c7 80 20 03 00 00 20 	mov    DWORD PTR [rax+0x320],0x20
  10c516:	00 00 00 
  10c519:	e8 d2 e8 ff ff       	call   10adf0 <ktask_create_process>
  if(pid == KTASK_INVALID_PID) return;
  10c51e:	48 83 f8 ff          	cmp    rax,0xffffffffffffffff
  10c522:	0f 84 d6 fe ff ff    	je     10c3fe <kshell_process_command+0xce>
  uint64_t thread_id = ktask_create_thread(pid, p->start_address, &globals.task_info);
  10c528:	48 8d 0c 40          	lea    rcx,[rax+rax*2]
  10c52c:	ba 80 08 12 00       	mov    edx,0x120880
  10c531:	48 89 c7             	mov    rdi,rax
  10c534:	48 8b 34 cd 88 08 12 	mov    rsi,QWORD PTR [rcx*8+0x120888]
  10c53b:	00 
  10c53c:	e8 7f e9 ff ff       	call   10aec0 <ktask_create_thread>
  for(size_t i = 0; i < globals.system_info.cpu_count; i++){
  10c541:	8b 15 11 43 01 00    	mov    edx,DWORD PTR [rip+0x14311]        # 120858 <globals+0x106f8>
  10c547:	48 89 c3             	mov    rbx,rax
  uint32_t volatile *lapic_register = (uint32_t volatile *)(lapic_base + register_offset);
  10c54a:	48 8b 05 af 42 01 00 	mov    rax,QWORD PTR [rip+0x142af]        # 120800 <globals+0x106a0>
  10c551:	85 d2                	test   edx,edx
  return lapic_register[0];
  10c553:	8b 40 20             	mov    eax,DWORD PTR [rax+0x20]
  10c556:	74 08                	je     10c560 <kshell_process_command+0x230>
    if(globals.system_info.cpu_lapic_ids[0] == lapic_id) return i;
  10c558:	39 05 ba 42 01 00    	cmp    DWORD PTR [rip+0x142ba],eax        # 120818 <globals+0x106b8>
  10c55e:	74 1d                	je     10c57d <kshell_process_command+0x24d>
  klog_error("UNREGISTER LAPIC ID WAS USED TO GFT CPU ID");
  10c560:	be 90 14 10 00       	mov    esi,0x101490
  10c565:	31 c0                	xor    eax,eax
  10c567:	bf 60 01 11 00       	mov    edi,0x110160
  10c56c:	e8 1f dc ff ff       	call   10a190 <klog_write_fmt>
  kpanic();
  10c571:	bf 60 01 11 00       	mov    edi,0x110160
  10c576:	e8 f5 cb ff ff       	call   109170 <kgfx_draw_log_if_dirty>
  10c57b:	fa                   	cli    
  10c57c:	f4                   	hlt    
  Thread_Context *ctx = &task_info->threads[thread_id];
  10c57d:	48 8d 04 9b          	lea    rax,[rbx+rbx*4]
  10c581:	48 c1 e0 03          	shl    rax,0x3
  10c585:	48 8d 90 80 0b 12 00 	lea    rdx,[rax+0x120b80]
  asm_enter_usermode((uintptr_t)ctx->rip, ctx->rsp);
  10c58c:	48 05 60 01 11 00    	add    rax,0x110160
  10c592:	48 8b b0 30 0a 01 00 	mov    rsi,QWORD PTR [rax+0x10a30]
  10c599:	48 8b b8 38 0a 01 00 	mov    rdi,QWORD PTR [rax+0x10a38]
  Thread_Context *ctx = &task_info->threads[thread_id];
  10c5a0:	48 89 15 d9 4f 01 00 	mov    QWORD PTR [rip+0x14fd9],rdx        # 121580 <globals+0x11420>
}
  10c5a7:	48 83 c4 08          	add    rsp,0x8
  10c5ab:	5b                   	pop    rbx
  10c5ac:	5d                   	pop    rbp
  10c5ad:	41 5c                	pop    r12
  10c5af:	41 5d                	pop    r13
  asm_enter_usermode((uintptr_t)ctx->rip, ctx->rsp);
  10c5b1:	e9 7e 02 00 00       	jmp    10c834 <asm_enter_usermode>
  10c5b6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10c5bd:	00 00 00 
  klog_error("%s is not a shell command", input);
  10c5c0:	48 89 fa             	mov    rdx,rdi
  10c5c3:	be 64 10 10 00       	mov    esi,0x101064
  10c5c8:	e9 fc fd ff ff       	jmp    10c3c9 <kshell_process_command+0x99>
  10c5cd:	0f 1f 00             	nop    DWORD PTR [rax]

000000000010c5d0 <klog_submit_input_to_shell>:
  if(log->input_buffer_count > 0){
  10c5d0:	48 8b b7 18 05 01 00 	mov    rsi,QWORD PTR [rdi+0x10518]
  10c5d7:	48 85 f6             	test   rsi,rsi
  10c5da:	75 04                	jne    10c5e0 <klog_submit_input_to_shell+0x10>
  10c5dc:	f3 c3                	repz ret 
  10c5de:	66 90                	xchg   ax,ax
    log->is_dirty = true;
  10c5e0:	c6 87 24 05 01 00 01 	mov    BYTE PTR [rdi+0x10524],0x1
    log->input_buffer_count = 0;
  10c5e7:	48 c7 87 18 05 01 00 	mov    QWORD PTR [rdi+0x10518],0x0
  10c5ee:	00 00 00 00 
    kshell_process_command(log->input_buffer, length);
  10c5f2:	48 81 c7 18 04 01 00 	add    rdi,0x10418
  10c5f9:	e9 32 fd ff ff       	jmp    10c330 <kshell_process_command>
  10c5fe:	66 90                	xchg   ax,ax

000000000010c600 <asm_double_fault_handler>:
  10c600:	fa                   	cli    
  10c601:	c7 04 25 00 80 0b 00 	mov    DWORD PTR ds:0xb8000,0x2064
  10c608:	64 20 00 00 
  10c60c:	c7 04 25 04 80 0b 00 	mov    DWORD PTR ds:0xb8004,0x2066
  10c613:	66 20 00 00 
  10c617:	c7 04 25 08 80 0b 00 	mov    DWORD PTR ds:0xb8008,0x206c
  10c61e:	6c 20 00 00 
  10c622:	f4                   	hlt    
  10c623:	48 cf                	iretq  

000000000010c625 <asm_debug_handler>:
  10c625:	fa                   	cli    
  10c626:	c7 04 25 00 80 0b 00 	mov    DWORD PTR ds:0xb8000,0x61
  10c62d:	61 00 00 00 
  10c631:	c7 04 25 04 80 0b 00 	mov    DWORD PTR ds:0xb8004,0x62
  10c638:	62 00 00 00 
  10c63c:	c7 04 25 08 80 0b 00 	mov    DWORD PTR ds:0xb8008,0x63
  10c643:	63 00 00 00 
  10c647:	f4                   	hlt    
  10c648:	48 cf                	iretq  

000000000010c64a <asm_spurious_interrupt_handler>:
  10c64a:	48 cf                	iretq  

000000000010c64c <asm_irq_common_handler>:
  10c64c:	41 57                	push   r15
  10c64e:	41 56                	push   r14
  10c650:	41 55                	push   r13
  10c652:	41 54                	push   r12
  10c654:	41 53                	push   r11
  10c656:	41 52                	push   r10
  10c658:	41 51                	push   r9
  10c65a:	41 50                	push   r8
  10c65c:	55                   	push   rbp
  10c65d:	56                   	push   rsi
  10c65e:	57                   	push   rdi
  10c65f:	52                   	push   rdx
  10c660:	51                   	push   rcx
  10c661:	53                   	push   rbx
  10c662:	50                   	push   rax
  10c663:	e8 98 ec ff ff       	call   10b300 <irq_common_handler>
  10c668:	41 5f                	pop    r15
  10c66a:	41 5e                	pop    r14
  10c66c:	41 5d                	pop    r13
  10c66e:	41 5c                	pop    r12
  10c670:	41 5b                	pop    r11
  10c672:	41 5a                	pop    r10
  10c674:	41 59                	pop    r9
  10c676:	41 58                	pop    r8
  10c678:	5d                   	pop    rbp
  10c679:	5e                   	pop    rsi
  10c67a:	5f                   	pop    rdi
  10c67b:	5a                   	pop    rdx
  10c67c:	59                   	pop    rcx
  10c67d:	5b                   	pop    rbx
  10c67e:	58                   	pop    rax
  10c67f:	83 c4 08             	add    esp,0x8
  10c682:	fb                   	sti    
  10c683:	48 cf                	iretq  

000000000010c685 <asm_isr_common_handler>:
  10c685:	41 57                	push   r15
  10c687:	41 56                	push   r14
  10c689:	41 55                	push   r13
  10c68b:	41 54                	push   r12
  10c68d:	41 53                	push   r11
  10c68f:	41 52                	push   r10
  10c691:	41 51                	push   r9
  10c693:	41 50                	push   r8
  10c695:	55                   	push   rbp
  10c696:	56                   	push   rsi
  10c697:	57                   	push   rdi
  10c698:	52                   	push   rdx
  10c699:	51                   	push   rcx
  10c69a:	53                   	push   rbx
  10c69b:	50                   	push   rax
  10c69c:	e8 4f ea ff ff       	call   10b0f0 <isr_common_handler>
  10c6a1:	41 5f                	pop    r15
  10c6a3:	41 5e                	pop    r14
  10c6a5:	41 5d                	pop    r13
  10c6a7:	41 5c                	pop    r12
  10c6a9:	41 5b                	pop    r11
  10c6ab:	41 5a                	pop    r10
  10c6ad:	41 59                	pop    r9
  10c6af:	41 58                	pop    r8
  10c6b1:	5d                   	pop    rbp
  10c6b2:	5e                   	pop    rsi
  10c6b3:	5f                   	pop    rdi
  10c6b4:	5a                   	pop    rdx
  10c6b5:	59                   	pop    rcx
  10c6b6:	5b                   	pop    rbx
  10c6b7:	58                   	pop    rax
  10c6b8:	83 c4 10             	add    esp,0x10
  10c6bb:	fb                   	sti    
  10c6bc:	48 cf                	iretq  

000000000010c6be <asm_syscall_handler>:
  10c6be:	fa                   	cli    
  10c6bf:	48 8b 04 c5 e0 16 10 	mov    rax,QWORD PTR [rax*8+0x1016e0]
  10c6c6:	00 
  10c6c7:	ff d0                	call   rax
  10c6c9:	fb                   	sti    
  10c6ca:	48 cf                	iretq  

000000000010c6cc <asm_isr0>:
  10c6cc:	fa                   	cli    
  10c6cd:	6a 00                	push   0x0
  10c6cf:	6a 00                	push   0x0
  10c6d1:	eb b2                	jmp    10c685 <asm_isr_common_handler>

000000000010c6d3 <asm_isr1>:
  10c6d3:	fa                   	cli    
  10c6d4:	6a 00                	push   0x0
  10c6d6:	6a 01                	push   0x1
  10c6d8:	eb ab                	jmp    10c685 <asm_isr_common_handler>

000000000010c6da <asm_isr2>:
  10c6da:	fa                   	cli    
  10c6db:	6a 00                	push   0x0
  10c6dd:	6a 02                	push   0x2
  10c6df:	eb a4                	jmp    10c685 <asm_isr_common_handler>

000000000010c6e1 <asm_isr3>:
  10c6e1:	fa                   	cli    
  10c6e2:	6a 00                	push   0x0
  10c6e4:	6a 03                	push   0x3
  10c6e6:	eb 9d                	jmp    10c685 <asm_isr_common_handler>

000000000010c6e8 <asm_isr4>:
  10c6e8:	fa                   	cli    
  10c6e9:	6a 00                	push   0x0
  10c6eb:	6a 04                	push   0x4
  10c6ed:	eb 96                	jmp    10c685 <asm_isr_common_handler>

000000000010c6ef <asm_isr5>:
  10c6ef:	fa                   	cli    
  10c6f0:	6a 00                	push   0x0
  10c6f2:	6a 05                	push   0x5
  10c6f4:	eb 8f                	jmp    10c685 <asm_isr_common_handler>

000000000010c6f6 <asm_isr6>:
  10c6f6:	fa                   	cli    
  10c6f7:	6a 00                	push   0x0
  10c6f9:	6a 06                	push   0x6
  10c6fb:	eb 88                	jmp    10c685 <asm_isr_common_handler>

000000000010c6fd <asm_isr7>:
  10c6fd:	fa                   	cli    
  10c6fe:	6a 00                	push   0x0
  10c700:	6a 07                	push   0x7
  10c702:	eb 81                	jmp    10c685 <asm_isr_common_handler>

000000000010c704 <asm_isr8>:
  10c704:	fa                   	cli    
  10c705:	6a 08                	push   0x8
  10c707:	e9 79 ff ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c70c <asm_isr9>:
  10c70c:	fa                   	cli    
  10c70d:	6a 00                	push   0x0
  10c70f:	6a 09                	push   0x9
  10c711:	e9 6f ff ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c716 <asm_isr10>:
  10c716:	fa                   	cli    
  10c717:	6a 0a                	push   0xa
  10c719:	e9 67 ff ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c71e <asm_isr11>:
  10c71e:	fa                   	cli    
  10c71f:	6a 0b                	push   0xb
  10c721:	e9 5f ff ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c726 <asm_isr12>:
  10c726:	fa                   	cli    
  10c727:	6a 0c                	push   0xc
  10c729:	e9 57 ff ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c72e <asm_isr13>:
  10c72e:	fa                   	cli    
  10c72f:	6a 0d                	push   0xd
  10c731:	e9 4f ff ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c736 <asm_isr14>:
  10c736:	fa                   	cli    
  10c737:	6a 0e                	push   0xe
  10c739:	e9 47 ff ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c73e <asm_isr15>:
  10c73e:	fa                   	cli    
  10c73f:	6a 00                	push   0x0
  10c741:	6a 0f                	push   0xf
  10c743:	e9 3d ff ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c748 <asm_isr16>:
  10c748:	fa                   	cli    
  10c749:	6a 00                	push   0x0
  10c74b:	6a 10                	push   0x10
  10c74d:	e9 33 ff ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c752 <asm_isr17>:
  10c752:	fa                   	cli    
  10c753:	6a 11                	push   0x11
  10c755:	e9 2b ff ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c75a <asm_isr18>:
  10c75a:	fa                   	cli    
  10c75b:	6a 00                	push   0x0
  10c75d:	6a 12                	push   0x12
  10c75f:	e9 21 ff ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c764 <asm_isr19>:
  10c764:	fa                   	cli    
  10c765:	6a 00                	push   0x0
  10c767:	6a 13                	push   0x13
  10c769:	e9 17 ff ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c76e <asm_isr20>:
  10c76e:	fa                   	cli    
  10c76f:	6a 00                	push   0x0
  10c771:	6a 14                	push   0x14
  10c773:	e9 0d ff ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c778 <asm_isr21>:
  10c778:	fa                   	cli    
  10c779:	6a 00                	push   0x0
  10c77b:	6a 15                	push   0x15
  10c77d:	e9 03 ff ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c782 <asm_isr22>:
  10c782:	fa                   	cli    
  10c783:	6a 00                	push   0x0
  10c785:	6a 16                	push   0x16
  10c787:	e9 f9 fe ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c78c <asm_isr23>:
  10c78c:	fa                   	cli    
  10c78d:	6a 00                	push   0x0
  10c78f:	6a 17                	push   0x17
  10c791:	e9 ef fe ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c796 <asm_isr24>:
  10c796:	fa                   	cli    
  10c797:	6a 00                	push   0x0
  10c799:	6a 18                	push   0x18
  10c79b:	e9 e5 fe ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c7a0 <asm_isr25>:
  10c7a0:	fa                   	cli    
  10c7a1:	6a 00                	push   0x0
  10c7a3:	6a 19                	push   0x19
  10c7a5:	e9 db fe ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c7aa <asm_isr26>:
  10c7aa:	fa                   	cli    
  10c7ab:	6a 00                	push   0x0
  10c7ad:	6a 1a                	push   0x1a
  10c7af:	e9 d1 fe ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c7b4 <asm_isr27>:
  10c7b4:	fa                   	cli    
  10c7b5:	6a 00                	push   0x0
  10c7b7:	6a 1b                	push   0x1b
  10c7b9:	e9 c7 fe ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c7be <asm_isr28>:
  10c7be:	fa                   	cli    
  10c7bf:	6a 00                	push   0x0
  10c7c1:	6a 1c                	push   0x1c
  10c7c3:	e9 bd fe ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c7c8 <asm_isr29>:
  10c7c8:	fa                   	cli    
  10c7c9:	6a 00                	push   0x0
  10c7cb:	6a 1d                	push   0x1d
  10c7cd:	e9 b3 fe ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c7d2 <asm_isr30>:
  10c7d2:	fa                   	cli    
  10c7d3:	6a 00                	push   0x0
  10c7d5:	6a 1e                	push   0x1e
  10c7d7:	e9 a9 fe ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c7dc <asm_isr31>:
  10c7dc:	fa                   	cli    
  10c7dd:	6a 00                	push   0x0
  10c7df:	6a 1f                	push   0x1f
  10c7e1:	e9 9f fe ff ff       	jmp    10c685 <asm_isr_common_handler>

000000000010c7e6 <asm_irq0>:
  10c7e6:	fa                   	cli    
  10c7e7:	6a 00                	push   0x0
  10c7e9:	e9 5e fe ff ff       	jmp    10c64c <asm_irq_common_handler>

000000000010c7ee <asm_irq1>:
  10c7ee:	fa                   	cli    
  10c7ef:	6a 01                	push   0x1
  10c7f1:	e9 56 fe ff ff       	jmp    10c64c <asm_irq_common_handler>

000000000010c7f6 <asm_irq128>:
  10c7f6:	fa                   	cli    
  10c7f7:	68 80 00 00 00       	push   0x80
  10c7fc:	e9 4b fe ff ff       	jmp    10c64c <asm_irq_common_handler>

000000000010c801 <asm_longmode_entry>:
  10c801:	66 b8 08 00          	mov    ax,0x8
  10c805:	8e d8                	mov    ds,eax
  10c807:	8e c0                	mov    es,eax
  10c809:	8e e0                	mov    fs,eax
  10c80b:	8e e8                	mov    gs,eax
  10c80d:	66 b8 00 00          	mov    ax,0x0
  10c811:	8e d0                	mov    ss,eax
  10c813:	5f                   	pop    rdi
  10c814:	5e                   	pop    rsi
  10c815:	e8 36 ec ff ff       	call   10b450 <kernel_longmode_entry>

000000000010c81a <asm_exit_usermode>:
  10c81a:	fa                   	cli    
  10c81b:	66 b8 08 00          	mov    ax,0x8
  10c81f:	8e d8                	mov    ds,eax
  10c821:	8e c0                	mov    es,eax
  10c823:	8e e0                	mov    fs,eax
  10c825:	8e e8                	mov    gs,eax
  10c827:	66 b8 00 00          	mov    ax,0x0
  10c82b:	8e d0                	mov    ss,eax
  10c82d:	fb                   	sti    
  10c82e:	e8 fd e7 ff ff       	call   10b030 <kprocess_destroy>
  10c833:	f4                   	hlt    

000000000010c834 <asm_enter_usermode>:
  10c834:	fa                   	cli    
  10c835:	66 b8 13 00          	mov    ax,0x13
  10c839:	8e d8                	mov    ds,eax
  10c83b:	8e c0                	mov    es,eax
  10c83d:	8e e0                	mov    fs,eax
  10c83f:	8e e8                	mov    gs,eax
  10c841:	6a 13                	push   0x13
  10c843:	56                   	push   rsi
  10c844:	9c                   	pushf  
  10c845:	58                   	pop    rax
  10c846:	48 0d 00 02 00 00    	or     rax,0x200
  10c84c:	50                   	push   rax
  10c84d:	6a 23                	push   0x23
  10c84f:	57                   	push   rdi
  10c850:	48 cf                	iretq  
  10c852:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  10c859:	00 00 00 
  10c85c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

000000000010c860 <start>:
  10c860:	fa                   	cli    
  10c861:	bc 02 70 12 00       	mov    esp,0x127002
  10c866:	3d 89 62 d7 36       	cmp    eax,0x36d76289
  10c86b:	75 02                	jne    10c86f <start.no_multiboot>
  10c86d:	eb 07                	jmp    10c876 <start.valid_multiboot>

000000000010c86f <start.no_multiboot>:
  10c86f:	b0 30                	mov    al,0x30
  10c871:	e9 cf 00 00 00       	jmp    10c945 <error_handler>

000000000010c876 <start.valid_multiboot>:
  10c876:	6a 00                	push   0x0
  10c878:	53                   	push   rbx
  10c879:	6a 00                	push   0x0
  10c87b:	50                   	push   rax
  10c87c:	e8 8a 00 00 00       	call   10c90b <is_cpuid_supported>
  10c881:	e8 9d 00 00 00       	call   10c923 <is_longmode_supported>
  10c886:	e8 2b 00 00 00       	call   10c8b6 <setup_paging_tables>
  10c88b:	e8 50 00 00 00       	call   10c8e0 <enable_paging>
  10c890:	0f 20 c0             	mov    rax,cr0
  10c893:	66 83 e0 fb          	and    ax,0xfffb
  10c897:	66 83 c8 02          	or     ax,0x2
  10c89b:	0f 22 c0             	mov    cr0,rax
  10c89e:	0f 20 e0             	mov    rax,cr4
  10c8a1:	66 0d 00 06          	or     ax,0x600
  10c8a5:	0f 22 e0             	mov    cr4,rax
  10c8a8:	0f 01 15 58 87 10 00 	lgdt   [rip+0x108758]        # 215007 <stack_top+0xee005>
  10c8af:	ea                   	(bad)  
  10c8b0:	01 c8                	add    eax,ecx
  10c8b2:	10 00                	adc    BYTE PTR [rax],al
  10c8b4:	18 00                	sbb    BYTE PTR [rax],al

000000000010c8b6 <setup_paging_tables>:
  10c8b6:	b8 00 30 12 00       	mov    eax,0x123000
  10c8bb:	83 c8 07             	or     eax,0x7
  10c8be:	a3 00 20 12 00 b8 00 	movabs ds:0x124000b800122000,eax
  10c8c5:	40 12 
  10c8c7:	00 83 c8 07 a3 00    	add    BYTE PTR [rbx+0xa307c8],al
  10c8cd:	30 12                	xor    BYTE PTR [rdx],dl
  10c8cf:	00 b8 00 00 00 00    	add    BYTE PTR [rax+0x0],bh
  10c8d5:	0d 83 00 00 00       	or     eax,0x83
  10c8da:	a3                   	.byte 0xa3
  10c8db:	00 40 12             	add    BYTE PTR [rax+0x12],al
  10c8de:	00 c3                	add    bl,al

000000000010c8e0 <enable_paging>:
  10c8e0:	b8 00 20 12 00       	mov    eax,0x122000
  10c8e5:	0f 22 d8             	mov    cr3,rax
  10c8e8:	0f 20 e0             	mov    rax,cr4
  10c8eb:	83 c8 20             	or     eax,0x20
  10c8ee:	0f 22 e0             	mov    cr4,rax
  10c8f1:	b9 80 00 00 c0       	mov    ecx,0xc0000080
  10c8f6:	0f 32                	rdmsr  
  10c8f8:	0d 00 01 00 00       	or     eax,0x100
  10c8fd:	0f 30                	wrmsr  
  10c8ff:	0f 20 c0             	mov    rax,cr0
  10c902:	0d 00 00 00 80       	or     eax,0x80000000
  10c907:	0f 22 c0             	mov    cr0,rax
  10c90a:	c3                   	ret    

000000000010c90b <is_cpuid_supported>:
  10c90b:	9c                   	pushf  
  10c90c:	58                   	pop    rax
  10c90d:	89 c1                	mov    ecx,eax
  10c90f:	35 00 00 20 00       	xor    eax,0x200000
  10c914:	50                   	push   rax
  10c915:	9d                   	popf   
  10c916:	9c                   	pushf  
  10c917:	58                   	pop    rax
  10c918:	51                   	push   rcx
  10c919:	9d                   	popf   
  10c91a:	31 c8                	xor    eax,ecx
  10c91c:	74 01                	je     10c91f <is_cpuid_supported.no_cpuid>
  10c91e:	c3                   	ret    

000000000010c91f <is_cpuid_supported.no_cpuid>:
  10c91f:	b0 37                	mov    al,0x37
  10c921:	eb 22                	jmp    10c945 <error_handler>

000000000010c923 <is_longmode_supported>:
  10c923:	b8 00 00 00 80       	mov    eax,0x80000000
  10c928:	0f a2                	cpuid  
  10c92a:	3d 01 00 00 80       	cmp    eax,0x80000001
  10c92f:	72 10                	jb     10c941 <is_longmode_supported.no_longmode>
  10c931:	b8 01 00 00 80       	mov    eax,0x80000001
  10c936:	0f a2                	cpuid  
  10c938:	f7 c2 00 00 00 20    	test   edx,0x20000000
  10c93e:	74 01                	je     10c941 <is_longmode_supported.no_longmode>
  10c940:	c3                   	ret    

000000000010c941 <is_longmode_supported.no_longmode>:
  10c941:	b0 32                	mov    al,0x32
  10c943:	eb 00                	jmp    10c945 <error_handler>

000000000010c945 <error_handler>:
  10c945:	c7 05 00 80 0b 00 45 	mov    DWORD PTR [rip+0xb8000],0x4f524f45        # 1c494f <stack_top+0x9d94d>
  10c94c:	4f 52 4f 
  10c94f:	c7 05 04 80 0b 00 52 	mov    DWORD PTR [rip+0xb8004],0x4f3a4f52        # 1c495d <stack_top+0x9d95b>
  10c956:	4f 3a 4f 
  10c959:	c7 05 08 80 0b 00 20 	mov    DWORD PTR [rip+0xb8008],0x4f204f20        # 1c496b <stack_top+0x9d969>
  10c960:	4f 20 4f 
  10c963:	a2                   	.byte 0xa2
  10c964:	0a                   	.byte 0xa
  10c965:	80 0b 00             	or     BYTE PTR [rbx],0x0
  10c968:	f4                   	hlt    
